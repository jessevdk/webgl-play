(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Editor = require('./editor');
var Document = require('./document'); // jshint ignore:line
var ui = require('../ui/ui');
var glsl = require('../glsl/glsl');
var Store = require('./store');
var Renderer = require('./renderer');
var Signals = require('../signals/signals');
var marked = require('../vendor/marked');
var utils = require('../utils/utils');

require('./js-mode');

var defaultSettings = {
    author: null,
    license: null
};

var licenseDescriptions = {
    'CC 0': 'No Attribution',
    'CC BY': 'Attribution: This license lets others distribute, remix, tweak, and build upon your work, even commercially, as long as they credit you for the original creation. This is the most accommodating of licenses offered. Recommended for maximum dissemination and use of licensed materials.',
    'CC BY-NC': 'Attribution, Non Commercial: This license lets others remix, tweak, and build upon your work non-commercially, and although their new works must also acknowledge you and be non-commercial, they don’t have to license their derivative works on the same terms.',
    'CC BY-SA': 'Attribution, Share Alike: This license lets others remix, tweak, and build upon your work even for commercial purposes, as long as they credit you and license their new creations under the identical terms. This license is often compared to “copyleft” free and open source software licenses. All new works based on yours will carry the same license, so any derivatives will also allow commercial use. This is the license used by Wikipedia, and is recommended for materials that would benefit from incorporating content from Wikipedia and similarly licensed projects.',
    'CC BY-NC-SA': 'Attribution, Non Commercial, Share Alike: This license lets others remix, tweak, and build upon your work non-commercially, as long as they credit you and license their new creations under the identical terms.'
};

marked.setOptions({
    sanitize: true,
    smartypants: true
});

function App() {
    Signals.call(this);

    this.document = null;

    this._onDocumentChanged = this.registerSignal('notify::document');
    this._lastFocus = null;
    this._mode = null;

    this.settings = utils.merge({}, defaultSettings);

    window.addEventListener('error', (function(e) {
        var error = e.error;

        if (error.originalStack) {
            this._handleJsError(error);

            e.preventDefault();
            e.stopPropagation();
            return true;
        }
    }).bind(this));

    if (document.readyState === 'complete') {
        this._init();
    } else {
        document.addEventListener('DOMContentLoaded', this._init.bind(this));
    }
}

App.prototype = Object.create(Signals.prototype);
App.prototype.constructor = App;

App.prototype.find = function(elems) {
    var ret = {};

    for (var k in elems) {
        ret[k] = document.querySelector(elems[k]);
    }

    return ret;
};

App.prototype.newDocument = function(cb) {
    var doc = new Document(this);

    this.loadDocument(doc, {}, (function() {
        this._saveCurrentDoc();

        if (cb) {
            cb();
        }
    }).bind(this));
};

App.prototype.loadDocument = function(doc, options, cb) {
    if (doc === null) {
        this.newDocument(cb);
        return;
    }

    if (!Document.prototype.isPrototypeOf(doc)) {
        doc = Document.deserialize(doc);
    }

    this._loadDoc(doc, options, cb);
};

App.prototype._extractJsErrorLoc = function(e) {
    var stack;

    stack = e.originalStack || e.stack;
    var lines = stack.split('\n');

    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];

        // Chrome
        var anon = /, <anonymous>:([0-9]+):([0-9]+)\)$/;
        var m = line.match(anon);

        if (m) {
            return {
                line: parseInt(m[1]) - 1,
                column: parseInt(m[2])
            };
        }

        // Firefox
        var func = /> Function:([0-9]+):([0-9]+)$/;
        m = line.match(func);

        if (m) {
            return {
                line: parseInt(m[1]),
                column: parseInt(m[2])
            };
        }
    }

    return null;
};

App.prototype._handleJsError = function(e) {
    var message = e.message;
    var loc = this._extractJsErrorLoc(e);

    if (loc) {
        this.jsEditor.runtimeError({
            message: message,
            location: loc
        });
    } else {
        console.error(e.stack);
    }
};

App.prototype._updateRenderer = function() {
    var ret = this.renderer.update(this.document);

    var i, p;

    if (typeof ret === 'undefined') {
        var c = {
            c: this.renderer.context,
            Math: Math
        };

        if (this.renderer.program) {
            c.this = this.renderer.program;
        }

        this.jsEditor.completionContext(c);

        for (i = 0; i < this.document.programs.length; i++) {
            p = this.document.programs[i];
            p.error(null);
        }
    } else {
        var e = null;

        if (ret.js.extensions !== null) {
            e = ret.js.extensions;
        } else if (ret.js.init !== null) {
            e = ret.js.init;
        } else if (ret.js.run !== null) {
            e = ret.js.run;
        }

        if (e !== null) {
            this._handleJsError(e);
        }

        for (i = 0; i < this.document.programs.length; i++) {
            p = this.document.programs[i];
            var name = p.name();

            if (ret.programs !== null && name in ret.programs) {
                p.error(ret.programs[name]);
            } else {
                p.error(null);
            }
        }
    }
};

App.prototype._updateEditors = function() {
    var up = {};

    var names = ['vertex', 'fragment', 'js'];

    for (var i = 0; i < names.length; i++) {
        var editor = this[names[i] + 'Editor'];

        up[names[i]] = {
            data: editor.value(),
            history: editor.history()
        };
    }

    this._updateDocumentBy(up);
};

App.prototype._onDocumentBeforeActiveProgramChanged = function() {
    this._updateEditors();
};

App.prototype._onDocumentActiveProgramChanged = function() {
    var prg = this.document.activeProgram();

    var loading = this._loading;
    this._loading = true;

    this.vertexEditor.value(prg.vertex.data);
    this.vertexEditor.history(prg.vertex.history);

    this.fragmentEditor.value(prg.fragment.data);
    this.fragmentEditor.history(prg.fragment.history);

    this._loading = loading;
    this._saveCurrentDocWithDelay();
};

App.prototype._onDocumentTitleChanged = function() {
    this.title.textContent = this.document.title;
};

App.prototype._loadDocReal = function(doc, options) {
    options = utils.merge({
        preventPushState: false,
        showInfo: false
    }, options);

    if (this.document !== null) {
        this.document.off('notify-before::active-program', this._onDocumentBeforeActiveProgramChanged, this);
        this.document.off('notify::active-program', this._onDocumentActiveProgramChanged, this);
        this.document.off('notify::title', this._onDocumentTitleChanged, this);

        this.document.off('changed', this._onDocumentChanged, this);
    }

    this.document = doc;

    this._onDocumentActiveProgramChanged();

    this.jsEditor.value(doc.js.data);
    this.jsEditor.history(doc.js.history);

    if (doc.activeEditor !== null) {
        var editor = null;

        switch (doc.activeEditor.name) {
        case 'js':
            editor = this.jsEditor;
            break;
        case 'vertex':
            editor = this.vertexEditor;
            break;
        case 'fragment':
            editor = this.fragmentEditor;
            break;
        }

        if (editor !== null) {
            editor.focus();
            editor.cursor(doc.activeEditor.cursor);
        }
    } else {
        this.canvas.focus();
    }

    this.title.textContent = doc.title;

    if (doc.state && doc.state.panels) {
        for (var k in doc.state.panels) {
            var p = doc.state.panels[k];
            this.panels[k].position(p.position);
        }

        this._updateCanvasSize();
    }

    this._loading = false;
    this._updateRenderer();

    this.document.on('notify-before::active-program', this._onDocumentBeforeActiveProgramChanged, this);
    this.document.on('notify::active-program', this._onDocumentActiveProgramChanged, this);
    this.document.on('notify::title', this._onDocumentTitleChanged, this);
    this.document.on('changed', this._onDocumentHasChanged, this);

    var st = {
        mode: 'document'
    };

    if (doc.id) {
        st.id = doc.id;
    }

    var url;

    if (doc.share) {
        st.share = doc.share;
        url = global.Settings.frontend.dataQuery(doc.share);
    } else {
        url = global.Settings.frontend.url('');
    }

    if (!this._isLocal()) {
        if (!options.preventPushState) {
            global.history.pushState(st, doc.title, url);
        } else {
            global.history.replaceState(st, doc.title, url);
        }
    }

    this._onDocumentChanged();

    this.content.classList.add('loaded');
    this.content.classList.remove('loading');

    this._showDocument();

    if (options.showInfo) {
        this._showInfoPopup();
    }
};

App.prototype._loadDoc = function(doc, options, cb) {
    this._loading = true;

    if (this.document !== null) {
        this.content.classList.remove('loaded');
        this.content.classList.add('loading');

        setTimeout((function() {
            this._loadDocReal(doc, options);

            if (cb) {
                cb();
            }
        }).bind(this), 200);
    } else {
        this._loadDocReal(doc, options);

        if (cb) {
            cb();
        }
    }
};

App.prototype._onDocumentHasChanged = function(doc, opts) {
    this._saveCurrentDocWithDelay((function() {
        if ('vertex' in opts || 'fragment' in opts || 'js' in opts || 'programs' in opts) {
            this._updateRenderer();
        }
    }).bind(this));
};

App.prototype._serializeDocument = function(doc) {
    var ret = doc.serialize();

    ret.state = {
        panels: {}
    };

    for (var k in this.panels) {
        ret.state.panels[k] = {
            position: this.panels[k].position()
        };
    }

    return ret;
};

App.prototype._saveDoc = function(doc, cb) {
    if (this.document === null) {
        if (typeof cb === 'function') {
            cb(true);
        }

        return;
    }

    this._store.save(this._serializeDocument(doc), function(store, retdoc) {
        if (retdoc !== null) {
            doc.id = retdoc.id;
        }

        if (typeof cb === 'function') {
            cb(retdoc !== null);
        }
    });
};

App.prototype._saveCurrentDoc = function(cb) {
    this._saveDoc(this.document, cb);
};

App.prototype._saveCurrentDocWithDelay = function(cb) {
    if (this.document === null) {
        if (typeof cb === 'function') {
            cb(true);
        }

        return;
    }

    var doc = this.document;

    if (this._saveTimeout !== 0) {
        clearTimeout(this._saveTimeout);
        this._saveTimeout = 0;
    }

    this._saveTimeout = setTimeout((function() {
        this._saveTimeout = 0;

        if (doc === this.document) {
            this._saveCurrentDoc(cb);
        }
    }).bind(this), 500);
};

App.prototype._updateCanvasSize = function() {
    this.canvas.width = this.canvas.clientWidth;
    this.canvas.height = this.canvas.clientHeight;
};

App.prototype._initPanels = function() {
    var panels = document.querySelectorAll('.panel');

    this.panels = {};

    for (var i = 0; i < panels.length; i++) {
        var p = panels[i];

        this.panels[p.id] = new ui.Panel(p);
    }

    this.panels['panel-programs'].on('resized', (function() {
        this.vertexEditor.editor.refresh();
        this.fragmentEditor.editor.refresh();
        this.jsEditor.editor.refresh();
        this._updateCanvasSize();
    }).bind(this));

    this.panels['panel-main'].on('resized', (function() {
        this.vertexEditor.editor.refresh();
        this.fragmentEditor.editor.refresh();
        this.jsEditor.editor.refresh();
        this._updateCanvasSize();
    }).bind(this));

    this.panels['panel-program'].on('resized', (function() {
        this.vertexEditor.editor.refresh();
        this.fragmentEditor.editor.refresh();
    }).bind(this));

    this.panels['panel-js'].on('resized', (function() {
        this.jsEditor.editor.refresh();
        this._updateCanvasSize();
    }).bind(this));
};

App.prototype._updateDocumentBy = function(opts) {
    if (this._loading) {
        return;
    }

    this.document.update(opts);
};

App.prototype._updateDocument = function(name, editor) {
    if (this._loading) {
        return;
    }

    var up = {};

    up[name] = {
        data: editor.value(),
        history: editor.history()
    };

    this._updateDocumentBy(up);
};

App.prototype._initCanvas = function() {
    this.canvas = document.getElementById('view');

    var t = this.canvas.parentElement.querySelector('.editor-title');

    this.canvas.addEventListener('focus', (function() {
        t.classList.add('hidden');
        this._updateDocumentBy({activeEditor: null});

        this._lastFocus = this.canvas;
    }).bind(this, t));

    this.canvas.addEventListener('blur', (function() {
        t.classList.remove('hidden');
    }).bind(this, t));

    window.addEventListener('resize', (function() {
        this._updateCanvasSize();
    }).bind(this));

    this.renderer = new Renderer(this.canvas, document.getElementById('content'));

    this.renderer.on('notify::first-frame', (function(r, frame) {
        this.document.update({
            screenshot: frame
        });
    }).bind(this));

    this.renderer.on('notify::fullscreen', (function() {
        this._updateCanvasSize();
    }).bind(this));

    this.renderer.on('error', (function(r, type, e) {
        switch (type) {
        case 'js':
            this._handleJsError(e);
            break;
        case 'program':
            for (var i = 0; i < this.document.programs.length; i++) {
                var p = this.document.programs[i];

                if (p.name() === e.program) {
                    p.error(e.errors);
                }
            }

            break;
        }
    }).bind(this));
};

App.prototype._initEditors = function() {
    var elems = this.find({
        vertex: '#vertex-editor',
        fragment: '#fragment-editor',
        js: '#js-editor'
    });

    var opts = {
        theme: 'default webgl-play',
        indentUnit: 4,
        lineNumbers: true,
        rulers: [78]
    };

    for (var k in elems) {
        var tname = k + 'Editor';
        var elem = elems[k];

        this[tname] = global.CodeMirror(elem, opts);

        var p = elem.parentElement;
        var t = p.querySelector('.editor-title');

        this[tname].on('focus', (function(title, k, tname) {
            title.classList.add('hidden');

            this._updateDocumentBy({
                activeEditor: {
                    name: k,
                    cursor: this[tname].cursor()
                }
            });

            this._lastFocus = elems[k];
        }).bind(this, t, k, tname));

        this[tname].on('blur', (function(title) {
            title.classList.remove('hidden');
        }).bind(this, t));
    }

    var ctx = this.renderer.context;

    this.vertexEditor = new Editor(this.vertexEditor, ctx, glsl.source.VERTEX);
    this.fragmentEditor = new Editor(this.fragmentEditor, ctx, glsl.source.FRAGMENT);
    this.jsEditor = new Editor(this.jsEditor, ctx, 'javascript');

    var editors = {
        'vertex': this.vertexEditor,
        'fragment': this.fragmentEditor,
        'js': this.jsEditor
    };

    for (var n in editors) {
        editors[n].editor.on('changes', (function(n) {
            this._updateDocument(n, editors[n]);
        }).bind(this, n));

        editors[n].editor.on('cursorActivity', (function(n) {
            this._updateDocumentBy({
                activeEditor: {
                    name: n,
                    cursor: editors[n].cursor()
                }
            });
        }).bind(this, n));
    }

    this._parsedTimeout = 0;
    this.vertexEditor.on('notify::parsed', this._onEditorParsed, this);
    this.fragmentEditor.on('notify::parsed', this._onEditorParsed, this);
};

App.prototype._onEditorParsed = function() {
    if (this._parsedTimeout !== 0) {
        clearTimeout(this._parsedTimeout);
    }

    this._parsedTimeout = setTimeout((function() {
        this._parsedTimeout = 0;

        if (this.vertexEditor.parsed !== null && this.fragmentEditor.parsed !== null) {
            var linker = new glsl.linker.Linker(this.vertexEditor.parsed, this.fragmentEditor.parsed);
            var errors = linker.link();

            this.vertexEditor.externalErrors(errors.vertex);
            this.fragmentEditor.externalErrors(errors.fragment);
        }
    }).bind(this), 50);
};

App.prototype.message = function(type, m, options) {
    options = utils.merge({
        canCancel: true
    }, options);

    var div = document.createElement('div');
    this._message = div;

    div.classList.add('message');

    if (type) {
        div.classList.add(type);
    }

    if (typeof m === 'string') {
        div.textContent = m;
    } else {
        div.appendChild(m);
    }

    var overlay = this._addOverlay();
    document.body.appendChild(div);

    var w = div.offsetWidth;
    var h = div.offsetHeight;

    div.style.left = ((document.body.offsetWidth - w) / 2) + 'px';
    div.style.top = ((document.body.offsetHeight - h) / 2) + 'px';

    var remover = (function() {
        if (options.canCancel) {
            window.removeEventListener('keydown', this._messageKeydown);
            window.removeEventListener('mousedown', this._messageMousedown);

            document.body.removeChild(overlay);
            document.body.removeChild(div);
        }
    }).bind(this);

    this._messageKeydown = (function(e) {
        if (e.keyCode === 27) {
            remover();
        }
    }).bind(this);

    this._messageMousedown = (function(e) {
        if (e.pageX < div.offsetLeft || e.pageX > div.offsetLeft + div.offsetWidth ||
            e.pageY < div.offsetTop || e.pageY > div.offsetTop + div.offsetHeight) {
            remover();
        }
    }).bind(this);

    window.addEventListener('keydown', this._messageKeydown);
    window.addEventListener('mousedown', this._messageMousedown);

    return remover;
};

App.prototype._createLicenseSwitch = function(license, authors) {
    var initial = license || 'CC BY';

    if (authors && authors.length > 0) {
        initial = authors[authors.length - 1].license;
    }

    var values = [
        { name: '0', value: 'CC 0' },
        { name: 'BY', value: 'CC BY' },
        { name: 'BY-NC', value: 'CC BY-NC' },
        { name: 'BY-SA', value: 'CC BY-SA' },
        { name: 'BY-NC-SA', value: 'CC BY-NC-SA' }
    ];

    if (authors && authors.length > 0) {
        var lastlic = authors[authors.length - 1].license;

        if (lastlic === 'CC BY-SA' || lastlic === 'CC BY-NC-SA') {
            /*for (var i = 0; i < values.length; i++) {
                if (values[i].value !== lastlic) {
                    values[i].sensitive = false;
                }
            }*/

            initial = lastlic;
        }
    }

    for (var i = 0; i < values.length; i++) {
        values[i].title = licenseDescriptions[values[i].value];
    }

    return new ui.MultiSwitch({
        values: values,
        value: initial
    });
};

App.prototype._showPublishDialog = function() {
    var w = ui.Widget.createUi;

    var licenseSwitch = this._createLicenseSwitch(this.document.license || this.settings.license, this.document.authors);
    var publishButton = new ui.Button('Publish');
    var requestTokenButton = new ui.Button('Request Token');

    var authorInput = w('input', { classes: 'author', type: 'text', value: (this.document.author || this.settings.author || '') });
    var tokenInput = w('input', { classes: ['token', 'empty'], value: 'E-mail address or token', type: 'text', size: 30 });

    var description = this.document.description;

    if (!description) {
        description = '*You cannot publish documents without a description. You can edit the description by clicking on the document title in the main view*';
        publishButton.sensitive(false);
        requestTokenButton.sensitive(false);
    }

    var desc = marked(description);
    var tokenval = '';

    tokenInput.addEventListener('focus', (function() {
        tokenInput.classList.remove('empty');
        tokenInput.value = tokenval;
    }).bind(this));

    tokenInput.addEventListener('blur', (function() {
        tokenval = tokenInput.value;

        if (!tokenval) {
            tokenInput.value = 'E-mail address or token';
            tokenInput.classList.add('empty');
        }
    }).bind(this));

    var status = w('div', { classes: 'status' });

    var errorStatus = function(m, e) {
        status.classList.add('error');
        status.textContent = m;

        if (e) {
            e.focus();
            var f;

            f = function() {
                e.removeEventListener('input', f);
                e.removeEventListener('change', f);
                e.removeEventListener('blur', f);

                status.textContent = '';
                status.classList.remove('error');
            };

            e.addEventListener('input', f);
            e.addEventListener('change', f);
            e.addEventListener('blur', f);
        }
    };

    var okStatus = function(m) {
        status.classList.remove();
        status.textContent = m;
    };

    this.renderer.grabImage(300, 200, (function(screenshot) {
        var descDiv = w('div', { innerHTML: desc });

        if (!this.document.description) {
            descDiv.classList.add('empty');
        }

        var d = w('div', {
            classes: 'publish',
            children: [
                w('div', { classes: 'title', textContent: 'Publish document: ' + this.document.title }),
                w('div', { classes: 'description', textContent: 'Publishing stores the current document online and makes it available in the online gallery. Publishing a document requires a publishing token. You can request a new publishing token to be send by e-mail, or reuse a previously received token. To request a new token, enter your e-mail address in the Token field and press Request Token.'}),
                w('img', { classes: 'screenshot', src: screenshot }),
                w('div', { classes: 'contents', children:
                    w('table', { classes: 'contents', children: [
                        w('tr', { children: [
                            w('td', { textContent: 'Description:' }),
                            w('td', { classes: 'description', children: descDiv }),
                        ]}),

                        w('tr', { children: [
                            w('td', { textContent: 'Author:' }),
                            w('td', { children: authorInput }),
                        ]}),

                        w('tr', { children: [
                            w('td', { textContent: 'License, CC:' }),
                            licenseSwitch.e
                        ]}),

                        w('tr', { children: [
                            w('td', { textContent: 'Token:' }),
                            w('td', { children: tokenInput })
                        ]}),
                    ]}),
                }),
                w('div', { classes: 'actions', children: [
                    requestTokenButton.e,
                    publishButton.e,
                    status
                ] })
            ]
        });

        var rm = this.message('dialog', d);

        requestTokenButton.on('click', (function() {
            if (authorInput.value.length === 0) {
                errorStatus('Please provide an author name', authorInput);
                return;
            }

            if (tokenval.indexOf('@') === -1) {
                errorStatus('Please provide an e-mail address to send a new token to', tokenInput);
                return;
            }

            utils.post('g/new', {
                email: tokenInput.value,
                title: this.document.title,
                author: authorInput.value
            }, {
                success: function() {
                    okStatus('New request token has been sent and should arrive shortly');
                },

                error: function(req, e) {
                    errorStatus(e ? e.message : req.responseText);
                }
            });
        }).bind(this));

        var doc = this.document;

        publishButton.on('click', (function() {
            if (authorInput.value.length === 0) {
                errorStatus('Please provide an author name', authorInput);
                return;
            }

            if (!tokenval.match(/^[a-zA-Z]+$/)) {
                errorStatus('The specified token does not appear to be a valid token', tokenInput);
                return;
            }

            utils.post('g/update', {
                document: doc.remote(),
                author: authorInput.value,
                license: licenseSwitch.value(),
                screenshot: screenshot,
                token: tokenInput.value
            }, {
                success: (function(req, ret) {
                    if (doc !== this.document) {
                        return;
                    }

                    this.settings.license = licenseSwitch.value();
                    this.settings.author = authorInput.value;
                    this._store.saveAppSettings(this.settings);

                    this.document.license = licenseSwitch.value();
                    this.document.author = authorInput.value;
                    this._saveCurrentDocWithDelay();

                    // Update authors received from remote
                    this.document.authors = ret.document.authors;

                    // Make document shared
                    this._makeShared(ret.published.document);

                    rm();

                    this.message('ok', '\'' + doc.title + '\' has been successfully published in the gallery, thanks!');
                }).bind(this),

                error: (function(req, e) {
                    if (doc === this.document) {
                        errorStatus(e ? e.message : req.responseText);
                    }
                }).bind(this)
            });
        }).bind(this));
    }).bind(this));
};

App.prototype._showShareDialog = function() {
    var w = ui.Widget.createUi;

    var licenseSwitch = this._createLicenseSwitch(this.document.license || this.settings.license, this.document.authors);
    var shareButton = new ui.Button('Share');
    var authorInput = w('input', { classes: 'author', type: 'text', value: (this.document.author || this.settings.author || '') });

    var status = w('div', { classes: 'status' });

    var d = w('div', {
        classes: 'share',
        children: [
            w('div', { classes: 'title', textContent: 'Share document: ' + this.document.title }),
            w('table', { classes: 'contents', children: [
                w('tr', { classes: 'description', children: w('td', {
                    colspan: 2,
                    innerHTML: 'Sharing stores the current document online and makes it accessible by URL only.<br>The document will not appear in the online gallery.'
                }) } ),

                w('tr', { children: [
                    w('td', { textContent: 'Author:' }),
                    w('td', { children: authorInput }),
                ]}),

                w('tr', { children: [
                    w('td', { textContent: 'License, CC:' }),
                    licenseSwitch.e
                ]}),

                w('tr', { classes: 'actions', children: [
                    w('td', {
                        colspan: 2,
                        children: [
                            shareButton.e,
                            status
                        ]
                    }),
                ]})
            ]})
        ]
    });

    var rm = this.message('dialog', d);

    shareButton.on('click', (function() {
        var license = licenseSwitch.value();

        if (authorInput.value.length === 0 && license !== 'CC 0') {
            authorInput.focus();

            status.textContent = 'The selected license requires an author name to give credit';
            status.classList.add('error');

            return;
        }

        this.settings.license = license;
        this.settings.author = authorInput.value;
        this._store.saveAppSettings(this.settings);

        this.document.license = licenseSwitch.value();
        this.document.author = authorInput.value;
        this._saveCurrentDocWithDelay();

        rm();

        this._shareDocument(authorInput.value, licenseSwitch.value());
    }).bind(this));
};

App.prototype._onButtonShareClick = function() {
    this._showShareDialog();
};

App.prototype._onButtonPublishClick = function() {
    this._showPublishDialog();
};

App.prototype._showDocument = function() {
    if (this._mode === 'document') {
        return;
    }

    for (var i = 0; i < this.documentOnlyButtons.length; i++) {
        this.buttons[this.documentOnlyButtons[i]].sensitive(true);
    }

    this.main.classList.add('loaded');
    this.main.classList.remove('gallery');

    this._mode = 'document';
    localStorage.setItem('lastMode', 'document');

    if (!localStorage.getItem('firstVisited')) {
        localStorage.setItem('firstVisited', true);
        this._showIntro();
    }
};

App.prototype._galleryHasEmptyCellsInView = function(empties) {
    var y = this.gallery.scrollTop;
    var h = this.gallery.clientHeight;

    for (var i = 0; i < empties.length; i++) {
        var empty = empties[i];

        if (empty.offsetTop < y + h && empty.offsetTop + empty.offsetHeight > y) {
            return true;
        }
    }

    return false;
};

App.prototype._makeEmptyGalleryCells = function(table, nRows, nColumns) {
    var emptyCells = [];
    var w = ui.Widget.createUi;

    for (var r = 0; r < nRows; r++) {
        var tr = w('tr', {
            parent: table
        });

        for (var c = 0; c < nColumns; c++) {
            var div = w('div', {
                classes: 'gallery-item'
            });

            w('td', {
                parent: tr,
                children: div,
                classes: 'empty'
            });

            emptyCells.push(div);
        }
    }

    return emptyCells;
};

App.prototype._fillGalleryItem = function(container, item) {
    var w = ui.Widget.createUi;

    w('div', {
        classes: 'title',
        textContent: item.title,
        parent: container
    });

    var date = new Date(item.modificationDate);

    w('table', {
        classes: 'info',
        children: [
            w('tr', { children: [
                w('td', {
                    classes: 'screenshot',
                    children: w('img', {
                        src: global.Settings.backend.url('s/' + item.screenshot + '.png'),
                        parent: container
                    })
                }),

                w('td', { children: w('table', { classes: 'properties', children: [
                    w('tr', { children: [
                        w('td', { textContent: 'Author:' }),
                        w('td', { textContent: item.author })
                    ]}),
                    w('tr', { children: [
                        w('td', { textContent: 'License:' }),
                        w('td', { textContent: item.license, title: licenseDescriptions[item.license] })
                    ]}),
                    w('tr', { children: [
                        w('td', { textContent: 'Published:' }),
                        w('td', { textContent: this._relDate(date) })
                    ]}),
                    w('tr', { children: [
                        w('td', { textContent: 'Views:' }),
                        w('td', { textContent: item.views })
                    ]})
                ]})})
            ]})
        ],
        parent: container
    });

    var desc = marked(item.description);
    var div = document.createElement('div');
    div.innerHTML = desc;
    var shortDescription = div.querySelector('p');

    w('div', {
        classes: 'description',
        innerHTML: shortDescription.innerHTML,
        parent: container
    });

    container.addEventListener('click', (function() {
        this.loadRemoteDocument(item.document, (function(doc) {
            this.loadDocument(doc, { showInfo: true });

            var vkey = 'viewed:' + (item.parent ? item.parent : item.id);

            if (!localStorage.getItem(vkey)) {
                utils.post('g/' + item.parent + '/' + item.id + '/view');
                localStorage.setItem(vkey, true);
            }
        }).bind(this));
    }).bind(this));
};

App.prototype._isLocal = function() {
    return document.location.protocol.indexOf('file') === 0;
};

App.prototype._populateGallery = function() {
    // Clear previous gallery
    this.gallery.innerHTML = '';

    var w = ui.Widget.createUi;

    var table = w('table', {
        classes: 'gallery'
    });

    var colgroup = w('colgroup', { parent: table });

    // Estimate number of columns
    var width = this.content.clientWidth;
    var height = this.content.clientHeight;

    // These are just rough, conservative, estimates
    var pixPerCol = 550;
    var pixPerRow = 350;

    var nColumns = Math.max(1, Math.floor(width / pixPerCol));
    var nRows = Math.max(1, Math.ceil(height / pixPerRow));

    var maxBatchSize = 50;
    var maxRoundBatchSize = Math.floor(maxBatchSize / nColumns) * nColumns;

    var pageSize = nRows * nColumns;
    var pagePerBatch = 3;
    var batchSize = Math.min(maxRoundBatchSize, pagePerBatch * pageSize);

    nRows = batchSize / nColumns;

    var colWidth = (100 / nColumns) + '%';

    for (var i = 0; i < nColumns; i++) {
        var col = document.createElement('col');
        col.setAttribute('width', colWidth);
        colgroup.appendChild(col);
    }

    var cells = this._makeEmptyGalleryCells(table, nRows, nColumns);

    this.gallery.appendChild(table);

    var state = {
        populating: false,
        table: table,
        emptyCells: cells,
        pages: 0,
        pageSize: pageSize,
        pagePerBatch: pagePerBatch,
        batchSize: batchSize,
        nColumns: nColumns,
        nRows: nRows
    };

    var finalize = (function() {
        var trs = [];
        var i, tr;

        for (i = 0; i < state.emptyCells.length; i++) {
            var empty = state.emptyCells[i];
            var td = empty.parentNode;
            
            tr = td.parentNode;

            if (trs.indexOf(tr) === -1) {
                trs.push(tr);
            }

            tr.removeChild(td);
        }

        for (i = 0; i < trs.length; i++) {
            tr = trs[i];

            if (tr.childNodes.length === 0) {
                state.table.removeChild(tr);
            }
        }

        this._checkPopulateGallery = null;
    }).bind(this);

    this._checkPopulateGallery = (function(state) {
        // Check if we are looking at empty cells
        if (state.populating || !this._galleryHasEmptyCellsInView(state.emptyCells)) {
            return;
        }

        state.populating = true;

        // Ok, populate all the empty cells
        utils.getQuery('g', {
            page: state.pages,
            limit: state.batchSize
        }, {
            success: (function(req, ret) {
                if (this._mode !== 'gallery') {
                    return;
                }

                // Fill up to 'ret' empty cells
                for (var i = 0; i < ret.length; i++) {
                    this._fillGalleryItem(state.emptyCells[i], ret[i]);
                    state.emptyCells[i].parentNode.classList.remove('empty');
                }

                state.populating = false;

                if (ret.length < state.batchSize) {
                    var n = Math.ceil(ret.length / state.nColumns) * state.nColumns;
                    state.emptyCells = state.emptyCells.slice(n);

                    finalize();
                } else {
                    state.emptyCells = this._makeEmptyGalleryCells(state.table, state.nRows, state.nColumns);
                    this._checkPopulateGallery();
                }
            }).bind(this),

            error: (function(req, e) {
                if (this._mode !== 'gallery') {
                    return;
                }

                this.message('error', 'Error while requesting gallery: ' + (e ? e.message : req.responseText));
                finalize();
            }).bind(this)
        });
    }).bind(this, state);

    this._checkPopulateGallery();
};

App.prototype._showGallery = function(options) {
    if (this._mode === 'gallery') {
        return;
    }

    if (this._isLocal()) {
        // No gallery when running locally, but this is still called on initializing.
        // Instead, just show a new document
        this.newDocument();
        return;
    }

    options = utils.merge({
        preventPushState: false
    }, options);

    this._saveCurrentDoc((function() {
        for (var i = 0; i < this.documentOnlyButtons.length; i++) {
            this.buttons[this.documentOnlyButtons[i]].sensitive(false);
        }

        this.main.classList.add('loaded');
        this.main.classList.add('gallery');

        this.content.classList.add('loaded');
        this.content.classList.remove('loading');

        this.renderer.pause();

        this.document = null;
        this._mode = 'gallery';

        localStorage.setItem('lastMode', 'gallery');

        var st = {
            mode: 'gallery'
        };

        if (!this._isLocal()) {
            if (!options.preventPushState) {
                global.history.pushState(st, '',  global.Settings.frontend.url(''));
            } else {
                global.history.replaceState(st, '', global.Settings.frontend.url(''));
            }
        }

        this._populateGallery();

        if (!localStorage.getItem('firstVisited')) {
            localStorage.setItem('firstVisited', true);
            this._showIntro();
        }
    }).bind(this));
};

App.prototype._onButtonGalleryClick = function() {
    this._showGallery({
        preventPushState: false
    });
};

App.prototype._makeShared = function(share) {
    this._updateDocumentBy({
        share: share
    });

    var url = global.Settings.frontend.dataQuery(share);

    global.history.replaceState({
        mode: 'document',
        share: share
    }, '', url);

    // Return the full url
    return document.location.href;
};

App.prototype._shareDocument = function(author, license) {
    var doc = this.document;

    utils.post('d/new', {
        document: doc.remote(),
        author: author,
        license: license
    }, {
        success: (function(req, ret) {
            if (this.document === doc) {
                var url = this._makeShared(ret.hash);

                // Update document authors
                this.document.authors = ret.authors;
                this._saveCurrentDoc();

                var w = ui.Widget.createUi;

                var urle = w('span', {
                    textContent: url
                });

                var message = w('div', {
                    children: [
                        w('span', { textContent: 'Shared document at ' }),
                        urle
                    ]
                });

                this.message('ok', message);

                var selection = window.getSelection();
                var range = document.createRange();

                range.selectNodeContents(urle);

                selection.removeAllRanges();
                selection.addRange(range);
            }
        }).bind(this),

        error: (function(req, e) {
            if (this.document === doc) {
                this.message('error', 'Failed to upload document: ' + (e ? e.message : req.responseText));
            }
        }).bind(this)
    });
};

App.prototype._onButtonExportClick = function() {
    var saveas = require('../vendor/FileSaver');

    var blob = new Blob([JSON.stringify(this.document.remote(), undefined, 2)], {type: 'application/json;charset=utf-8'});
    saveas(blob, this.document.title + '.json');
};

App.prototype._initProgramsBar = function() {
    this.programsBar = new ui.ProgramsBar(document.getElementById('programs-sidebar'), this);
};

App.prototype._showOpenglPopup = function(popup) {
    var gl = this.renderer.context.gl;

    var exts = gl.getSupportedExtensions();
    exts.sort();

    for (var i = 0; i < exts.length; i++) {
        exts[i] = ui.Widget.createUi('div', {
            children: ui.Widget.createUi('a', {
                href: 'https://www.khronos.org/registry/webgl/extensions/' + exts[i],
                target: '_blank',
                textContent: exts[i]
            })
        });
    }

    var content = ui.Widget.createUi('table', {
        classes: 'opengl',
        children: [
            ui.Widget.createUi('tr', {
                children: [
                    ui.Widget.createUi('td', { textContent: 'Supported Extensions:' }),
                    ui.Widget.createUi('td', {
                        children: ui.Widget.createUi('div', {
                            classes: 'extensions',
                            children: exts
                        })
                    })
                ]
            })
        ]
    });

    var ext = gl.getExtension('WEBGL_debug_renderer_info');

    if (ext) {
        ui.Widget.createUi('tr', {
            children: [
                ui.Widget.createUi('td', { textContent: 'Vendor:' }),
                ui.Widget.createUi('td', { textContent: gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) }),
            ],
            parent: content
        });

        ui.Widget.createUi('tr', {
            children: [
                ui.Widget.createUi('td', { textContent: 'Renderer:' }),
                ui.Widget.createUi('td', { textContent: gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) }),
            ],
            parent: content
        });
    }

    popup.content(content);
};

App.prototype._showAboutPopup = function(cb) {
    var popup;

    var items = [
        { name: 'OpenGL Information', action: (function(popup) {
            this._showOpenglPopup(popup);
        }).bind(this) },
        { name: 'Source on Github', action: 'https://github.com/jessevdk/webgl-play' },
        { name: 'Issues on Github', action: 'https://github.com/jessevdk/webgl-play/issues' }
    ];

    var children = [];

    for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var li;

        if (typeof item.action === 'string') {
            var a = ui.Widget.createUi('a', {
                href: item.action,
                target: '_blank',
                textContent: item.name
            });

            a.addEventListener('click', function(e) {
                e.stopPropagation();
                popup.destroy();
            });

            li = ui.Widget.createUi('li', {
                children: a
            });

            li.addEventListener('click', (function(a) {
                a.click();
                popup.destroy();
            }).bind(this, a));
        } else {
            li = ui.Widget.createUi('li', {
                textContent: item.name
            });

            li.addEventListener('click', (function(action) {
                action(popup);
            }).bind(this, item.action));
        }

        children.push(li);
    }

    var content = ui.Widget.createUi('ul', {
        children: children,
        classes: 'about'
    });

    if (typeof global.Settings.hooks.about === 'function') {
        global.Settings.hooks.about(content);
    }

    popup = new ui.Popup(content, this.buttons.about.e);
    cb(popup);
};

App.prototype._initButtons = function() {
    var buttons = ['new', 'copy', 'export', 'models', 'open', 'about', 'gallery', 'share', 'publish'];

    this.buttons = {};

    this.documentOnlyButtons = [
        'copy',
        'export',
        'models',
        'share',
        'publish'
    ];

    for (var i = 0; i < buttons.length; i++) {
        var b = buttons[i];
        var elem = document.getElementById('button-' + b);

        if (elem) {
            var button = new ui.Button({ wrap: elem });

            var eh = '_onButton' + b[0].toUpperCase() + b.slice(1) + 'Click';

            if (eh in this) {
                button.on('click', this[eh], this);
            }

            this.buttons[b] = button;
        }
    }

    ui.Popup.on(this.buttons.open, this._showOpenPopup.bind(this));
    ui.Popup.on(this.buttons.models, this._showModelsPopup.bind(this));
    ui.Popup.on(this.buttons.about, this._showAboutPopup.bind(this));
};

App.prototype._onButtonCopyClick = function() {
    var title = 'Copy of ' + this.document.title;

    var doc = Document.deserialize(this._serializeDocument(this.document));

    doc.id = null;
    doc.title = title;

    this.loadDocument(doc);
};

App.prototype._relDate = function(date) {
    var now = new Date();
    var t = (now - date) / 1000;

    var MINUTE = 60;
    var HOUR = MINUTE * 60;
    var DAY = HOUR * 24;

    if (t < 29.5 * MINUTE) {
        var mins = Math.round(t / MINUTE);

        if (mins === 0) {
            return 'less than a minute ago';
        } else if (mins === 1) {
            return 'a minute ago';
        } else {
            return mins + ' minutes ago';
        }
    } else if (t < 45 * MINUTE) {
        return 'half an hour ago';
    } else if (t < 23.5 * HOUR) {
        var hours = Math.round(t / HOUR);

        if (hours === 1) {
            return 'an hour ago';
        } else {
            return hours + ' hours ago';
        }
    } else if (t < 7 * DAY) {
        var days = Math.round(t / DAY);

        if (days === 1) {
            return 'a day ago';
        } else {
            return days + ' days ago';
        }
    } else {
        return 'on ' + date.toDateString();
    }
};

App.prototype._showModelsPopup = function(cb) {
    var popup;

    this._store.models((function(store, ret) {
        var w = ui.Widget.createUi;
        var content = w('div', { classes: 'models' });

        var li = w('li', {
            classes: 'import',
            innerHTML: 'Import&nbsp;from&nbsp;file',
            title: 'Import a model from a local file'
        });

        li.addEventListener('click', (function() {
            var inp = w('input', { type: 'file', multiple: 'multiple' });

            inp.onchange = (function() {
                var reader = new ui.FilesReader(inp.files);
                var msg;

                if (inp.files.length === 1) {
                    msg = 'Importing 1 model from file';
                } else {
                    msg = 'Importing ' + inp.files.length + ' models from files';
                }

                var but = new ui.Button({
                    value: 'Close'
                });

                var remover = this.message('files', w('div', {
                    classes: 'files',
                    children: [
                        w('div', {
                            classes: 'title',
                            textContent: msg
                        }),

                        reader.e,

                        w('div', {
                            classes: 'actions',
                            children: but.e
                        })
                    ]
                }));

                but.on('click', (function() {
                    remover();
                }).bind(this));

                reader.on('loaded', (function(r, f, data) {
                    if (data !== null) {
                        this._store.addModel({
                            filename: f.name,
                            modificationTime: f.lastModifiedDate,
                            creationTime: new Date()
                        }, data, (function(store, model) {
                            reader.finished(f, model !== null);
                        }).bind(this));
                    }
                }).bind(this));

                reader.on('finished', (function() {
                    this._updateRenderer();
                }).bind(this));

                popup.destroy();
            }).bind(this);

            inp.click();
        }).bind(this));

        content.appendChild(li);

        var popup;

        for (var i = 0; i < ret.length; i++) {
            var sc = {
                classes: 'screenshot'
            };

            if (ret[i].screenshot) {
                sc.src = ret[i].screenshot;
            }

            li = w('li', {
                children: [
                    w('div', {
                        classes: 'screenshot-container',
                        children: w('img', sc)
                    }),

                    w('div', {
                        classes: 'filename',
                        textContent: ret[i].filename
                    }),

                    w('div', {
                        classes: 'modification-time',
                        textContent: 'Added ' + this._relDate(ret[i].creationTime)
                    }),

                    w('div', {
                        classes: 'delete',
                        textContent: '×',
                        title: 'Delete model'
                    })
                ]
            });

            var del = li.querySelector('.delete');

            del.addEventListener('click', (function(model, li, del, e) {
                var spinner = new ui.Spinner();

                del.textContent = '';
                del.classList.add('spinning');

                del.appendChild(spinner.e);
                spinner.start();

                this._store.deleteModel(model, (function(store, deleted) {
                    spinner.cancel();
                    del.removeChild(spinner.e);
                    del.classList.remove('spinning');

                    if (deleted) {
                        content.removeChild(li);
                        this._updateRenderer();
                    } else {
                        del.textContent = '×';
                    }
                }).bind(this));

                e.preventDefault();
                e.stopPropagation();
            }).bind(this, ret[i], li, del));

            content.appendChild(li);
        }

        popup = new ui.Popup(content, this.buttons.models.e);

        popup.on('destroy', (function() {
            if (this._lastFocus) {
                this._lastFocus.focus();
            }
        }).bind(this));

        cb(popup);
    }).bind(this));
};

App.prototype._showOpenPopup = function(cb) {
    var popup;

    this._store.all((function(store, ret) {
        var w = ui.Widget.createUi;
        var content = w('ul', { classes: 'documents' });

        var li = w('li', {
            classes: 'import',
            innerHTML: 'Import&nbsp;from&nbsp;file',
            title: 'Import a previously exported document'
        });

        li.addEventListener('click', (function() {
            var inp = w('input', { type: 'file', multiple: 'multiple' });

            inp.onchange = (function() {
                var reader = new ui.FilesReader(inp.files);
                var msg;

                if (inp.files.length === 1) {
                    msg = 'Importing 1 document from file';
                } else {
                    msg = 'Importing ' + inp.files.length + ' documents from files';
                }

                var but = new ui.Button({
                    value: 'Close'
                });

                var remover = this.message('files', w('div', {
                    classes: 'files',
                    children: [
                        w('div', {
                            classes: 'title',
                            textContent: msg
                        }),

                        reader.e,

                        w('div', {
                            classes: 'actions',
                            children: but.e
                        })
                    ]
                }));

                but.on('click', (function() {
                    remover();
                }).bind(this));

                var docs = new Array(inp.files.length);

                reader.on('loaded', (function(i, r, f, data) {
                    var doc = Document.fromRemote(null, JSON.parse(data));
                    this._saveDoc(doc);

                    docs[i] = doc;

                    r.finished(f, true);
                }).bind(this, i));

                reader.on('finished', (function() {
                    for (var i = docs.length - 1; i >= 0; i--) {
                        if (docs[i]) {
                            this.loadDocument(docs[i]);
                            break;
                        }
                    }
                }).bind(this));

                popup.destroy();
            }).bind(this);

            inp.click();
        }).bind(this));

        content.appendChild(li);

        for (var i = 0; i < ret.length; i++) {
            var sc = {
                classes: 'screenshot'
            };

            if (ret[i].screenshot) {
                sc.src = ret[i].screenshot;
            }

            li = w('li', {
                children: [
                    w('div', {
                        classes: 'screenshot-container',
                        children: w('img', sc)
                    }),

                    w('div', {
                        classes: 'title',
                        textContent: ret[i].title
                    }),

                    w('div', {
                        classes: 'modification-time',
                        textContent: 'Last modified ' + this._relDate(ret[i].modificationTime)
                    }),

                    w('div', {
                        classes: 'delete',
                        textContent: '×',
                        title: 'Delete document'
                    })
                ]
            });

            if (this.document !== null && ret[i].id === this.document.id) {
                var title = li.querySelector('.title');
                title.classList.add('active');
            }

            li.addEventListener('click', (function(doc) {
                this.loadDocument(Document.deserialize(doc));
                popup.destroy();
            }).bind(this, ret[i]));

            var del = li.querySelector('.delete');

            del.addEventListener('click', (function(doc, li, del, e) {
                if (content.querySelectorAll('li').length > 1) {
                    var spinner = new ui.Spinner();

                    del.textContent = '';
                    del.classList.add('spinning');

                    del.appendChild(spinner.e);
                    spinner.start();

                    this._store.delete(doc, (function(store, doc) {
                        spinner.cancel();
                        del.removeChild(spinner.e);
                        del.classList.remove('spinning');

                        if (doc) {
                            content.removeChild(li);

                            if (this.document && this.document.id === doc.id) {
                                delete this.document.id;
                            }
                        } else {
                            del.textContent = '×';
                        }
                    }).bind(this));
                }

                e.preventDefault();
                e.stopPropagation();
            }).bind(this, ret[i], li, del));

            content.appendChild(li);
        }

        popup = new ui.Popup(content, this.buttons.open.e);

        popup.on('destroy', (function() {
            if (this._lastFocus) {
                this._lastFocus.focus();
            }
        }).bind(this));

        cb(popup);
    }).bind(this));
};

App.prototype._onButtonNewClick = function() {
    this._saveCurrentDoc((function(saved) {
        if (saved) {
            this.newDocument();
        }
    }).bind(this));
};

App.prototype._addOverlay = function() {
    var overlay = document.createElement('div');
    overlay.classList.add('overlay');

    document.body.appendChild(overlay);
    overlay.offsetWidth; // jshint ignore:line
    overlay.classList.add('animate');

    return overlay;
};

App.prototype._showInfoPopup = function() {
    var w = ui.Widget.createUi;

    var title = w('input', { classes: 'title', value: this.document.title, type: 'text' });

    var authors = [];

    for (var i = 0; i < this.document.authors.length; i++) {
        var author = this.document.authors[i];

        authors.push(author.name + ' (' + author.license + ', ' + author.year + ')');
    }

    if (authors.length === 0) {
        authors = ['Unpublished'];
    }

    var props = w('table', {
        classes: 'properties',
        children: [
            w('tr', { children: [
                w('td', { textContent: 'Authors:' }),
                w('td', { textContent: authors.join(', ') })
            ]}),
        ]
    });

    var description = w('div', {
        classes: 'description'
    });

    var close = new ui.Button('Close Editor');
    close.e.classList.add('close');

    var editor = w('textarea');

    var content = w('div', {
        classes: 'info-popup',
        children: [
            title,
            props,
            description,
            close.e,
            editor
        ]
    });

    var f = (function() {
        this._updateDocumentBy({
            title: title.value
        });

        this._saveCurrentDocWithDelay();
    }).bind(this);

    title.addEventListener('input', f);
    title.addEventListener('change', f);

    var desc = (function() {
        if (this.document.description) {
            description.classList.remove('empty');
            return this.document.description;
        } else {
            description.classList.add('empty');
            return 'Description not set. Double-click to start editing.';
        }
    }).bind(this);

    description.innerHTML = marked(desc());

    var saveEditor = (function() {
        this._updateDocumentBy({
            description: editor.value
        });

        this._saveCurrentDocWithDelay();
    }).bind(this);

    editor.addEventListener('keydown', (function(e) {
        if (e.keyCode === 27) { // escape
            saveEditor();
            description.innerHTML = marked(desc());

            content.classList.remove('editing');
            close.e.classList.remove('animate');

            e.stopPropagation();
            e.preventDefault();
        }
    }).bind(this));

    editor.addEventListener('blur', (function() {
        if (content.classList.contains('editing')) {
            saveEditor();
        }
    }).bind(this));

    close.on('click', function() {
        saveEditor();
        description.innerHTML = marked(desc());

        content.classList.remove('editing');
        close.e.classList.remove('animate');
    }, this);

    description.addEventListener('dblclick', (function() {
        editor.value = this.document.description || '';

        content.classList.add('editing');
        close.e.offsetWidth; // jshint ignore:line
        close.e.classList.add('animate');

        editor.focus();

        editor.selectionStart = 0;
        editor.selectionEnd = 0;
    }).bind(this));

    var overlay = this._addOverlay();
    this._infoPopup = new ui.Popup(content, this.title);

    this._infoPopup.on('destroy', function() {
        if (content.classList.contains('editing')) {
            saveEditor();
        }

        this._infoPopup = null;
        document.body.removeChild(overlay);

        if (this._lastFocus) {
            this._lastFocus.focus();
        }
    }, this);
};

App.prototype._initTitle = function() {
    this.title = document.getElementById('document-title');
    ui.Popup.on(this.title, this._showInfoPopup.bind(this));
};

App.prototype._checkCompatibility = function() {
    var missing = [];

    var view = document.getElementById('view');

    if (!Renderer.getWebGLContext(view)) {
        missing.push({
            name: 'WebGL',
            description: 'It looks like WebGL is not supported in your browser, and this playground is all about WebGL!'
        });
    }

    // Check for IndexedDB
    if (typeof global.indexedDB === 'undefined') {
        missing.push({
            name: 'indexedDB',
            description: 'A suitable implementation of indexedDB could not be found. indexedDB is a local data storage which is used by the WebGL Playground to store documents.'
        });
    }

    if (typeof global.localStorage === 'undefined') {
        missing.push({
            name: 'localStorage',
            description: 'A suitable implementation of localStorage could not be found. localStorage is used by the WebGL Playground to track application states.'
        });
    }

    if (typeof global.history === 'undefined') {
        missing.push({
            name: 'history',
            description: 'A suitable implementation of history could not be found. history is used by the WebGL Playground to implement proper navigation in history while using the application.'
        });
    }

    if (missing.length !== 0) {
        var children = [];

        for (var i = 0; i < missing.length; i++) {
            var m = missing[i];

            children.push(ui.Widget.createUi('tr', {
                children: [
                    ui.Widget.createUi('td', { textContent: m.name }),
                    ui.Widget.createUi('td', { textContent: m.description })
                ]
            }));
        }

        var d = ui.Widget.createUi('div', {
            classes: 'compatibility',
            children: [
                ui.Widget.createUi('div', {
                    classes: 'title',
                    textContent: 'Sorry! The WebGL Playground does not support your browser'
                }),

                ui.Widget.createUi('table', {
                    children: children
                })
            ]
        });

        this.message('error', d, { canCancel: false });
        return false;
    } else {
        return true;
    }
};

App.prototype._initHistory = function() {
    if (!global.history) {
        return;
    }

    global.onpopstate = (function(e) {
        var st = e.state;

        if (st) {
            if (st.mode === 'document') {
                var f = (function(store, doc) {
                    if (doc) {
                        this.loadDocument(doc, { preventPushState: true });
                    }
                }).bind(this);

                if (st.id) {
                    this._store.byId(st.id, f);
                } else if (st.share) {
                    this._store.byShare(st.share, f);
                }
            } else {
                this._showGallery({
                    preventPushState: true
                });
            }
        } else {
            this._route((function(doc) {
                this.loadDocument(doc);
            }).bind(this), (function() {
                this._showGallery({
                    preventPushState: true
                });
            }).bind(this));
        }
    }).bind(this);
};

App.prototype.loadRemoteDocument = function(id, cb) {
    this._store.byShare(id, (function(_, doc) {
        if (doc !== null) {
            cb(doc);
        } else {
            utils.get('d/' + id + '.json', {
                success: (function(req, jdoc) {
                    var doc = Document.fromRemote(id, jdoc);

                    if (cb) {
                        cb(doc);
                    } else if (jdoc) {
                        this.loadDocument(doc);
                    }
                }).bind(this),

                error: (function(req, e) {
                    var msg = e ? e.message : req.responseText;
                    this.message('error', 'Failed to load document: ' + msg);
                }).bind(this)
            });
        }
    }).bind(this));
};

App.prototype._route = function(f, cb) {
    var m = document.location.pathname.match(/d\/([A-Za-z0-9]+)/);

    if (!m) {
        m = document.location.search.match(/\?d=([A-Za-z0-9]+)/);
    }

    if (m) {
        this.loadRemoteDocument(m[1], f);
    } else {
        cb();
    }
};

App.prototype._showIntro = function() {
    if (typeof global.Settings.hooks.intro !== 'function') {
        return;
    }

    var div = document.createElement('div');

    div.classList.add('intro');
    div.innerHTML = marked(global.Settings.hooks.intro());

    this.message('', div);
};

App.prototype._init = function() {
    if (!this._checkCompatibility()) {
        return;
    }

    this._store = new Store((function(store) {
        this._initHistory();

        store.appSettings((function(store, settings) {
            this.settings = utils.merge(defaultSettings, settings);
        }).bind(this));

        var f = (function(doc) {
            if (doc === null) {
                this._showGallery({
                    preventPushState: true
                });
            } else {
                var saved = localStorage.getItem('savedDocumentBeforeUnload');

                if (saved !== null && doc !== null) {
                    saved = JSON.parse(saved);

                    if (saved && typeof saved.id !== 'undefined' && saved.id === doc.id)
                    {
                        saved.modificationTime = new Date(saved.modificationTime);
                        saved.creationTime = new Date(saved.creationTime);

                        this.loadDocument(Document.deserialize(saved), {}, (function() {
                            this._saveCurrentDocWithDelay();
                        }).bind(this));

                        localStorage.setItem('savedDocumentBeforeUnload', null);

                        return;
                    }
                }

                this.loadDocument(doc);
            }
        }).bind(this);

        this._route(f, (function() {
            if (localStorage.getItem('lastMode') === 'document') {
                store.last((function(_, doc) {
                    f(doc);
                }).bind(this));
            } else {
                f(null);
            }
        }).bind(this));
    }).bind(this));

    this.main = document.getElementById('main');
    this.gallery = document.getElementById('gallery');
    this.content = document.getElementById('content');

    this._initProgramsBar();
    this._initCanvas();
    this._initEditors();
    this._initButtons();
    this._initPanels();
    this._initTitle();

    this._updateCanvasSize();

    window.onbeforeunload = (function() {
        if (this.mode === 'document' && this.document !== null) {
            this._updateEditors();
            localStorage.setItem('savedDocumentBeforeUnload', JSON.stringify(this._serializeDocument(this.document)));
        }
    }).bind(this);

    window.addEventListener('scroll', (function() {
        if (this._mode === 'gallery' && this._checkPopulateGallery) {
            this._checkPopulateGallery();
        }
    }).bind(this));
};

var app = new App();
module.exports = app;

// vi:ts=4:et

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../glsl/glsl":12,"../signals/signals":34,"../ui/ui":50,"../utils/utils":52,"../vendor/FileSaver":53,"../vendor/marked":56,"./document":2,"./editor":3,"./js-mode":5,"./renderer":7,"./store":8}],2:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


var Program = require('./program');
var Signals = require('../signals/signals');

function Document() {
    Signals.call(this);

    this.id = null;

    this.programs = [Program.default()];

    this.js = {
        data: "function init(c) {\n    this.box = new c.models.Box(c, 1, 1, 1);\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50);\n\n    this.view.transform\n        .rotateY(-Math.PI / 6)\n        .rotateX(-Math.PI / 6)\n        .translateForward(3);\n}\n\nfunction render(c) {\n    c.view(this.view);\n    this.box.render(c);\n}\n",
        history: { done: [], undone: [] }
    };

    // Remove ending newline
    this.js.data = this.js.data.slice(0, this.js.data.length - 1);

    this.title = 'Untitled';
    this.description = '';

    this.modificationTime = new Date();
    this.creationTime = new Date();
    this.activeEditor = null;
    this.screenshot = null;
    this.state = {};
    this.share = null;
    this.license = null;
    this.author = null;
    this.authors = [];

    this._activeProgram = this.programs[0];
    this._activeProgram._isDefault = true;

    this._defaultProgram = this._activeProgram;

    this._onNotifyTitle = this.registerSignal('notify::title');
    this._onNotifyDescription = this.registerSignal('notify::description');
    this._onNotifyBeforeActiveProgram = this.registerSignal('notify-before::active-program');
    this._onNotifyActiveProgram = this.registerSignal('notify::active-program');
    this._onProgramAdded = this.registerSignal('program-added');
    this._onProgramRemoved = this.registerSignal('program-removed');

    this._onChanged = this.registerSignal('changed');
}

Document.prototype = Object.create(Signals.prototype);
Document.prototype.constructor = Document;

Document.prototype.defaultProgram = function() {
    return this._defaultProgram;
};

Document.prototype._changed = function(opts) {
    this.modificationTime = new Date();
    this._onChanged(opts);
};

Document.prototype._onProgramNotifyName = function() {
    this._changed({
        programs: true
    });
};

Document.prototype.addProgram = function(program) {
    this.programs.push(program);
    this._onProgramAdded(program);

    program.on('notify::name', this._onProgramNotifyName, this);

    this._changed({
        programs: true
    });
};

Document.prototype.removeProgram = function(program) {
    var idx = this.programs.indexOf(program);

    if (idx >= 0 && !this.programs[idx].isDefault()) {
        console.log(idx);
        if (this._activeProgram === program) {
            if (idx !== 0) {
                this.activeProgram(this.programs[idx - 1]);
            } else {
                this.activeProgram(this.programs[idx + 1]);
            }
        }

        this.programs.splice(idx, 1);
        this._onProgramRemoved(program);

        program.off('notify::name', this._onProgramNotifyName, this);

        this._changed({
            programs: true
        });
    }
};

Document.prototype.activeProgram = function(program) {
    if (typeof program === 'undefined') {
        return this._activeProgram;
    }

    if (program !== this._activeProgram) {
        this._onNotifyBeforeActiveProgram();
        this._activeProgram = program;
        this._onNotifyActiveProgram();

        this._changed({
            activeProgram: true
        });
    }
};

Document.prototype.update = function(changes) {
    if ('vertex' in changes) {
        this._activeProgram.vertex = {
            data: changes.vertex.data,
            history: changes.vertex.history
        };
    }

    if ('fragment' in changes) {
        this._activeProgram.fragment = {
            data: changes.fragment.data,
            history: changes.fragment.history
        };
    }

    if ('js' in changes) {
        this.js = {
            data: changes.js.data,
            history: changes.js.history
        };
    }

    if ('title' in changes) {
        this.title = changes.title;
        this._onNotifyTitle();
    }

    if ('description' in changes) {
        this.description = changes.description;
        this._onNotifyDescription();
    }

    var i;

    if ('activeProgram' in changes) {
        for (i = 0; i < this.programs.length; i++) {
            if (this.programs[i].name() === changes.activeProgram) {
                this.activeProgram(this.programs[i]);
                break;
            }
        }
    }

    // Simple properties
    var props = ['activeEditor', 'screenshot', 'share', 'license', 'author'];

    for (i = 0; i < props.length; i++) {
        var p = props[i];

        if (p in changes) {
            this[p] = changes[p];
        }
    }

    this._changed(changes);
};

Document.fromRemote = function(share, doc) {
    var ret = new Document();

    ret.share = share;
    ret.programs = [];
    ret._defaultProgram = null;

    var i;

    for (i = 0; i < doc.programs.length; i++) {
        var prg = Program.fromRemote(doc.programs[i]);
        ret.programs.push(prg);

        if (prg.isDefault()) {
            ret._defaultProgram = prg;
        }
    }

    if (ret.programs.length === 0) {
        ret.programs.push(Program.default());
    }

    ret._activeProgram = ret.programs[0];

    if (!ret._defaultProgram) {
        ret._defaultProgram = ret.programs[0];
        ret.programs[0]._isDefault = true;
    }

    ret.js = {
        data: doc.javascript,
        history: {done: [], undone: []}
    };

    // Simple properties
    var props = ['title', 'description', 'authors'];

    for (i = 0; i < props.length; i++) {
        var p = props[i];
        ret[p] = doc[p];
    }

    ret.modificationTime = new Date();
    ret.creationTime = new Date(doc.creationTime);

    ret.state = {};

    return ret;
};

Document.prototype.remote = function() {
    var programs = [];

    for (var i = 0; i < this.programs.length; i++) {
        programs.push(this.programs[i].remote());
    }

    return {
        version: 1,
        title: this.title,
        description: this.description,
        programs: programs,
        javascript: this.js.data,
        creationTime: this.creationTime,
        authors: this.authors
    };
};

Document.prototype.serialize = function() {
    var programs = [];

    for (var i = 0; i < this.programs.length; i++) {
        var p = this.programs[i];
        programs.push(p.serialize());
    }

    var ret = {
        version: 1,
        programs: programs,
        activeProgram: this._activeProgram.name(),
        js: {
            data: this.js.data,
            history: this.js.history,
        },
        title: this.title,
        description: this.description,
        modificationTime: this.modificationTime,
        creationTime: this.creationTime,
        activeEditor: this.activeEditor,
        screenshot: this.screenshot,
        share: this.share,
        license: this.license,
        author: this.author,
        authors: this.authors
    };

    if (this.id !== null) {
        ret.id = this.id;
    }

    return ret;
};

Document.deserialize = function(doc) {
    var ret = new Document();

    ret.programs = [];
    ret._activeProgram = null;
    ret._defaultProgram = null;

    if ('id' in doc) {
        ret.id = doc.id;
    }

    var i;

    for (i = 0; i < doc.programs.length; i++) {
        var prg = Program.deserialize(doc.programs[i]);
        ret.programs.push(prg);

        if (prg.name() === doc.activeProgram) {
            ret._activeProgram = prg;
        }

        if (prg.isDefault()) {
            ret._defaultProgram = prg;
        }
    }

    if (ret.programs.length === 0) {
        ret.programs.push(Program.default());
    }

    if (!ret._defaultProgram) {
        ret._defaultProgram = ret.programs[0];
        ret.programs[0]._isDefault = true;
    }

    if (ret._activeProgram === null) {
        ret._activeProgram = ret.programs[0];
    }

    var props = ['title', 'description', 'modificationTime', 'creationTime', 'state', 'screenshot', 'share', 'license', 'author', 'authors', 'activeEditor'];

    for (i = 0; i < props.length; i++) {
        var p = props[i];

        if (p in doc) {
            ret[p] = doc[p];
        }
    }

    ret.js = {
        data: doc.js.data,
        history: doc.js.history
    };

    if (typeof ret.state === 'undefined') {
        ret.state = {};
    }

    return ret;
};

module.exports = Document;

// vi:ts=4:et

},{"../signals/signals":34,"./program":6}],3:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

require('./glsl-mode');

var glsl = require('../glsl/glsl');
var esprima = require('../vendor/esprima');
var Signals = require('../signals/signals');

window.esprima = esprima;

var CodeMirror = window.CodeMirror;

function Editor(editor, ctx, type) {
    Signals.call(this);

    this.editor = editor;
    this.type = type;

    this._completionContext = {};

    this.options = {
        checkTimeout: 300,
        historySize: 100
    };

    var keymap = {
        Tab: function(cm) {
            var start = cm.getCursor('from');
            var end = cm.getCursor('to');

            for (var i = start.line; i <= end.line; i++) {
                cm.indentLine(i);
            }
        },

        Backspace: function(cm) {
            var doc = cm.getDoc();
            var cur = doc.getCursor();

            if (!doc.somethingSelected() && cur.ch !== 0) {
                var line = doc.getLine(cur.line);

                var prefix = line.slice(0, cur.ch);

                for (var i = prefix.length - 1; i >= 0; i--) {
                    if (prefix[i] !== ' ') {
                        return CodeMirror.Pass;
                    }
                }

                var m = 0;

                if (cur.ch == line.length) {
                    m = line.length;
                } else {
                    var n = cm.getOption('indentUnit');

                    // all spaces, remove up to N indentUnit
                    m = prefix.length % n;

                    if (m === 0) {
                        m = n;
                    }
                }

                doc.replaceRange('', {line: cur.line, ch: cur.ch - m}, cur);

                if (cur.ch == line.length) {
                    CodeMirror.commands.delCharBefore(cm);
                    cur.line -= 1;
                }

                cm.indentLine(cur.line, null, true);

                return;
            }

            if (cur.ch === 0 && cur.line !== 0) {
                CodeMirror.commands.delCharBefore(cm);
                cm.indentLine(cur.line - 1, null, true);
                return;
            }

            return CodeMirror.Pass;
        },

        Enter: function(cm) {
            var doc = cm.getDoc();

            if (doc.somethingSelected()) {
                doc.replaceSelection('');
            }

            var cur = doc.getCursor();
            var line = doc.getLine(cur.line);

            for (var i = 0; i < line.length; i++) {
                if (line[i] != ' ') {
                    return CodeMirror.Pass;
                }
            }

            doc.replaceRange('', {line: cur.line, ch: 0}, {line: cur.line, ch: line.length});
            return CodeMirror.Pass;
        }
    };

    var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
    var mac = ios || /Mac/.test(navigator.platform);

    if (mac) {
        keymap['Cmd-Left'] = 'goLineLeftSmart';
    }

    if (type === glsl.source.VERTEX || type === glsl.source.FRAGMENT) {
        this._preprocessorOptions = glsl.preprocessor.Preprocessor.optionsFromContext(ctx.gl);

        this.builtins = glsl.builtins.Builtins.createForContext(ctx.gl, type);

        if (type === glsl.source.VERTEX) {
            this.editor.setOption('mode', 'glslv');
        } else {
            this.editor.setOption('mode', 'glslf');
        }
    } else {
        this.editor.setOption('mode', type);

        if (type === 'javascript') {
            keymap['.'] = (function(cm) {
                cm.replaceSelection('.');
                cm.indentLine(cm.getCursor().line);

                try {
                    this._hint();
                } catch (e) {
                    console.error(e);
                }
            }).bind(this);

            keymap['Ctrl-Space'] = (function() {
                try {
                    this._hint();
                } catch (e) {
                    console.error(e);
                }
            }).bind(this);

            var mode = this.editor.getMode();
            var indentOrig = mode.indent;

            mode.indent = function(state, textAfter) {
                var ret = indentOrig.call(this, state, textAfter);

                if (textAfter.length > 0 && textAfter[0] === '.') {
                    ret += editor.getOption('indentUnit');
                }

                return ret;
            };
        }
    }

    this._changeTimeout = 0;

    this._internalErrors = {
        markers: [],
        errors: []
    };

    this._externalErrors = {
        markers: [],
        errors: []
    };

    this._errorMessage = null;

    this.editor.on('change', this._onChange.bind(this));
    this.editor.on('cursorActivity', this._onCursorActivity.bind(this));

    editor.addKeyMap(keymap);

    this.parsed = null;
    this._onNotifyParsed = this.registerSignal('notify::parsed');
}

Editor.prototype = Object.create(Signals.prototype);
Editor.prototype.constructor = Editor;

Editor.prototype._hint = function() {
    this.editor.showHint({
        completeSingle: false,
        context: this._completionContext,
    });
};

Editor.prototype.completionContext = function(context) {
    if (!context) {
        return this._completionContext;
    }

    this._completionContext = context;
};

Editor.prototype._onCursorActivity = function() {
    var doc = this.editor.getDoc();
    var cursor = this.cursor();
    var marks = doc.findMarksAt(cursor);

    var errs = [], i;

    for (i = 0; i < marks.length; i++) {
        var m = marks[i];

        if (m.className === 'error') {
            errs.push(m.error);
        }
    }

    if (this._errorMessage !== null && (errs.length === 0 || this._errorMessage.errors[0] !== errs[0])) {
        this._errorMessage.widget.parentElement.removeChild(this._errorMessage.widget);
        this._errorMessage = null;
    }

    if (this._errorMessage === null && errs.length > 0) {
        var c = document.createElement('div');
        c.classList.add('error-message-container');

        var w = document.createElement('ul');
        w.classList.add('error-message');

        c.appendChild(w);

        for (i = 0; i < errs.length; i++) {
            var li = document.createElement('li');
            li.textContent = errs[i].formattedMessage();

            w.appendChild(li);
        }

        this._errorMessage = {
            errors: errs,
            widget: c
        };

        this.editor.addWidget({line: cursor.line, ch: 0}, this._errorMessage.widget, false, 'above');
        c.style.left = '';    }
};

Editor.prototype.focus = function() {
    this.editor.focus();
};

Editor.prototype.cursor = function(v) {
    if (typeof v === 'undefined') {
        return this.editor.getCursor();
    }

    this.editor.setCursor(v);
};

Editor.prototype.value = function(v) {
    var stripper = /[ \t]+$/gm;

    if (typeof v === 'undefined') {
        return this.editor.getValue().replace(stripper, '');
    }

    this.editor.setValue(v.replace(stripper, ''));

    if (this._changeTimeout !== 0) {
        clearTimeout(this._changeTimeout);
        this._changeTimeout = 0;
    }

    this._onChangeTimeout();
};

Editor.prototype.history = function(v) {
    if (typeof v === 'undefined') {
        var hist = this.editor.getHistory();

        var ret = {
            done: [],
            undone: []
        };

        if (hist.undone.length > this.options.historySize) {
            ret.undone = hist.undone.slice(0, this.options.historySize);
        } else {
            ret.undone = hist.undone;
        }

        if (ret.undone.length < this.options.historySize) {
            var rem = this.options.historySize - ret.undone.length;

            if (hist.done.length > rem) {
                ret.done = hist.done.slice(0, rem);
            } else {
                ret.done = hist.done;
            }
        }


        return ret;
    }

    this.editor.setHistory(v);
};

Editor.prototype._makeLoc = function(l) {
    return {line: l.line - 1, ch: l.column - 1};
};

Editor.prototype._onChangeTimeout = function() {
    this._changeTimeout = 0;

    if (this.type === glsl.source.VERTEX || this.type === glsl.source.FRAGMENT) {
        this._onChangeTimeoutGlsl();
    } else {
        this._onChangeTimeoutJs();
    }
};

Editor.prototype._onChangeTimeoutJs = function() {
    try {
        esprima.parse(this.value());
    } catch (e) {
        this.runtimeError({
            message: e.description,
            location: {
                line: e.lineNumber,
                column: e.column
            }
        });

        return;
    }

    this._processErrors(this._internalErrors, []);
};

Editor.prototype._onChangeTimeoutGlsl = function() {
    this.parsed = new glsl.ast.Parser(this.value(), this.type, {
        preprocessor: this._preprocessorOptions
    });

    glsl.sst.Annotate(this.parsed, {
        builtins: this.builtins
    });

    this._processErrors(this._internalErrors, this.parsed.errors());
    this._onNotifyParsed();
};

Editor.prototype.runtimeError = function(error) {
    var tok = this.editor.getTokenAt(CodeMirror.Pos(error.location.line - 1, error.location.column));

    var err = {
        location: {
            start: {
                line: error.location.line,
                column: tok.start + 1
            },
            end: {
                line: error.location.line,
                column: tok.end + 1
            }
        },

        message: error.message,

        formattedMessage: function() {
            return error.location.line + '.' + (tok.start + 1) + '-' + error.location.line + '.' + (tok.end + 1) + ': ' + error.message;
        }
    };

    this._processErrors(this._internalErrors, [err]);
};

Editor.prototype.externalErrors = function(errors) {
    this._processErrors(this._externalErrors, errors);
};

Editor.prototype._processErrors = function(ctx, errors) {
    var doc = this.editor.getDoc();

    ctx.errors = errors.slice(0);

    var i;

    for (i = 0; i < ctx.markers.length; i++) {
        ctx.markers[i].clear();
    }

    ctx.markers = [];

    if (this._internalErrors.errors.length === 0 && this._externalErrors.errors.length === 0) {
        this.editor.display.wrapper.classList.remove('error');
    } else {
        this.editor.display.wrapper.classList.add('error');
    }

    for (i = 0; i < errors.length; i++) {
        var e = errors[i];
        var m = doc.markText(this._makeLoc(e.location.start),
                             this._makeLoc(e.location.end), {
                                className: 'error',
                                title: e.message,
                                inclusiveLeft: false,
                                inclusiveRight: true
                             });

        m.error = e;
        ctx.markers.push(m);
    }

    this._onCursorActivity();
};

Editor.prototype._onChange = function() {
    if (this._changeTimeout !== 0) {
        clearTimeout(this._changeTimeout);
        this._changeTimeout = 0;
    }

    this._changeTimeout = setTimeout(this._onChangeTimeout.bind(this), this.options.checkTimeout);
};

module.exports = Editor;

// vi:ts=4:et

},{"../glsl/glsl":12,"../signals/signals":34,"../vendor/esprima":54,"./glsl-mode":4}],4:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var tokenizer = require('../glsl/tokenizer');
var source = require('../glsl/source');

var mode = function(config) {
    var wsource = {
        _stream: null,

        eof: function() {
            return this._stream.eol();
        },

        skip: function(r) {
            this._stream.eatWhile(r);
        },

        next: function(r) {
            var m = this._stream.match(r);

            if (m) {
                var start = this.location().copy();
                var end = start.advance(m[0]);

                return new tokenizer.Token(0, m[0], new source.Range(start, end));
            }

            return null;
        },

        location: function() {
            return new source.Location(this._stream.line, this._stream.column);
        },

        source: function() {
            return this._stream.current();
        }
    };

    function T(source) {
        tokenizer.Base.prototype.init.call(this, source);
    }

    T.prototype = new tokenizer.Base(tokenizer.Tokenizer, {
        floats: true,
        ints: true,
        bools: true,
        comments: true,
        skipComments: false
    });

    var t = new T(wsource);

    function Context(indented, column, closetok, align, prev) {
        this.indented = indented;
        this.column = column;
        this.closetok = closetok;
        this.align = align;
        this.prev = prev;
    }

    Context.push = function(state, column, closetok, align) {
        state.context = new Context(state.indented, column, closetok, align, state.context);
    };

    Context.pop = function(state) {
        var tok = state.context.closetok;

        if (tok == '}' || tok == ')') {
            state.indented = state.context.indented;
        }

        state.context = state.context.prev;
    };

    return {
        lineComment: '//',
        blockCommentStart: '/*',
        blockCommentEnd: '*/',
        electricChars: '{})',

        startState: function(baseColumn) {
            return {
                context: new Context((baseColumn || 0) - config.indentUnit, 0, '', false, null),
                indented: 0,
                startOfLine: true
            };
        },

        token: function(stream, state) {
            wsource._stream = stream;

            if (stream.sol()) {
                if (state.context.align === null) {
                    state.context.align = false;
                }

                state.indented = stream.indentation();
                state.startOfLine = true;
            }

            if (stream.eatSpace()) {
                return null;
            }

            if (state.startOfLine && stream.peek() == '#') {
                stream.skipToEnd();
                return 'meta';
            }

            if (state.context.align === null) {
                state.context.align = true;
            }

            var tok = t.next();

            state.startOfLine = false;

            switch (tok.id) {
            case t.T_IDENTIFIER:
                return 'identifier';
            case t.T_COMMENT:
                return 'comment';
            case t.T_FLOATCONSTANT:
            case t.T_INTCONSTANT:
            case t.T_BOOLCONSTANT:
                return 'number';
            case t.T_CONST:
            case t.T_UNIFORM:
            case t.T_VARYING:
            case t.T_ATTRIBUTE:
            case t.T_PRECISION:
            case t.T_INVARIANT:
            case t.T_IN:
            case t.T_OUT:
            case t.T_INOUT:
            case t.T_HIGH_PRECISION:
            case t.T_MEDIUM_PRECISION:
            case t.T_LOW_PRECISION:
                return 'qualifier';
            case t.T_BOOL:
            case t.T_INT:
            case t.T_FLOAT:
            case t.T_VEC2:
            case t.T_VEC3:
            case t.T_VEC4:
            case t.T_IVEC2:
            case t.T_IVEC3:
            case t.T_IVEC4:
            case t.T_BVEC2:
            case t.T_BVEC3:
            case t.T_BVEC4:
            case t.T_MAT2:
            case t.T_MAT3:
            case t.T_MAT4:
            case t.T_SAMPLER2D:
            case t.T_SAMPLERCUBE:
            case t.T_VOID:
                return 'builtin';
            case t.T_FOR:
            case t.T_WHILE:
            case t.T_DO:
            case t.T_IF:
            case t.T_ELSE:
            case t.T_STRUCT:
            case t.T_FOR:
            case t.T_RETURN:
            case t.T_DISCARD:
            case t.T_BREAK:
            case t.T_CONTINUE:
                return 'keyword';
            case t.T_PLUS:
            case t.T_DASH:
            case t.T_STAR:
            case t.T_SLASH:
            case t.T_EQUAL:
            case t.T_EQ_OP:
            case t.T_NE_OP:
            case t.T_LE_OP:
            case t.T_GE_OP:
            case t.T_ANGLE_RIGHT:
            case t.T_ANGLE_LEFT:
            case t.T_INC_OP:
            case t.T_DEC_OP:
            case t.T_MUL_ASSIGN:
            case t.T_DIV_ASSIGN:
            case t.T_ADD_ASSIGN:
            case t.T_SUB_ASSIGN:
            case t.T_AND_OP:
            case t.T_OR_OP:
            case t.T_XOR_OP:
            case t.T_DOT:
            case t.T_QUESTION:
            case t.T_COLON:
                return 'operator';
            case t.T_LEFT_BRACE:
                Context.push(state, stream.column(), '}', null);
                break;
            case t.T_LEFT_PAREN:
                Context.push(state, stream.column(), ')', null);
                break;
            case t.T_RIGHT_BRACE:
            case t.T_RIGHT_PAREN:
                if (state.context.closetok == tok.text) {
                    Context.pop(state);
                }
                break;
            }

            return null;
        },

        indent: function(state, textAfter) {
            var ctx = state.context;
            var closing = false, ret;

            if (textAfter) {
                closing = (ctx.closetok == textAfter.charAt(0));
            }

            if (ctx.align) {
                ret = ctx.column;

                if (!closing) {
                    ret += 1;
                }

                return ret;
            }

            ret = ctx.indented;

            if (!closing) {
                ret += config.indentUnit;
            }

            return ret;
        }
    };
};

var CodeMirror = window.CodeMirror;

CodeMirror.defineMode('glslv', mode);
CodeMirror.defineMode('glslf', mode);

CodeMirror.defineMIME('text/x-glslv', 'glslv');
CodeMirror.defineMIME('text/x-glslf', 'glslf');

/* vi:ts=4:et */

},{"../glsl/source":15,"../glsl/tokenizer":17}],5:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('../utils/utils');

var CodeMirror = window.CodeMirror;

function render(element, self, data) {
    var t = data.text;
    var prev = 0;

    var icon = document.createElement('span');
    icon.classList.add('icon');

    if (typeof data.obj === 'function') {
        icon.textContent = 'm';
        icon.classList.add('function');
    } else {
        icon.textContent = 'd';
        icon.classList.add('data');
    }

    element.appendChild(icon);

    var span = document.createElement('span');
    var e;

    for (var i = 0; i < data.pos.length; i++) {
        var p = data.pos[i];

        if (p.start !== prev) {
            e = document.createElement('span');
            e.textContent = t.slice(prev, p.start);

            span.appendChild(e);
        }

        e = document.createElement('span');
        e.classList.add('match');
        e.textContent = t.slice(p.start, p.end + 1);
        span.appendChild(e);

        prev = p.end + 1;
    }

    if (prev != t.length) {
        e = document.createElement('span');
        e.textContent = t.slice(prev);
        span.appendChild(e);
    }

    element.appendChild(span);
}

function match(item, pattern) {
    var ip = 0;
    var i = 0;
    var d = 0;
    var pos = [];

    if (item.length > 0 && item[0] === '_') {
        return false;
    }

    while (i < item.length && ip != pattern.length) {
        if (item[i] == pattern[ip]) {
            if (pos.length === 0 || pos[pos.length - 1].end != i - 1) {
                pos.push({start: i, end: i});
            } else {
                pos[pos.length - 1].end = i;
            }

            ip++;
        } else {
            d++;
        }

        i++;
    }

    if (ip !== pattern.length) {
        return false;
    }

    return {
        distance: d,
        pos: pos
    };
}

function iterPrev(iter) {
    while (true) {
        var start;

        if (iter.tok.start === 0) {
            if (iter.line === 0) {
                iter.tok = null;
                return iter;
            }

            iter.line--;

            var l = iter.editor.getLine(iter.line);
            start = l.length;
        } else {
            start = iter.tok.start;
        }

        iter.tok = iter.editor.getTokenAt(CodeMirror.Pos(iter.line, start));

        if (iter.tok.start !== 0 && !(iter.tok.type === null && iter.tok.string.match(/^\s*$/))) {
            break;
        }
    }

    return iter;
}

function sanitizeDescription(s) {
    var esc = utils.htmlEscape(s);

    var r = /\{@link.*?([^\s]+)\}/;
    return esc.replace(r, '<b>$1</b>');
}

function fillInfo(info, completion, doc) {
    while (info.firstChild) {
        info.removeChild(info.firstChild);
    }

    var description = sanitizeDescription(doc.description);

    var title = document.createElement('div');
    title.classList.add('title');

    var i;

    if (doc.kind === 'class' || doc.kind === 'function') {
        var args = [];

        if (typeof doc.params !== 'undefined') {
            for (i = 0; i < doc.params.length; i++) {
                args.push(doc.params[i].name);
            }
        }

        title.textContent = completion.text + '(' + args.join(', ') + ') - ';
    }

    var desc = description;
    var dot = desc.indexOf('.');

    if (dot !== -1) {
        title.innerHTML += desc.slice(0, dot + 1);
        desc = desc.slice(dot + 1).trim();

        if (desc.length === 0) {
            desc = null;
        }
    } else {
        title.innerHTML += desc;
        desc = null;
    }

    info.appendChild(title);

    if (desc !== null) {
        var d = document.createElement('div');
        d.classList.add('description');
        d.innerHTML = desc;

        info.appendChild(d);
    }

    if (typeof doc.params !== 'undefined' && doc.params.length > 0) {
        var table = document.createElement('table');
        table.classList.add('params');

        for (i = 0; i < doc.params.length; i++) {
            var p = doc.params[i];

            var row = document.createElement('tr');
            var name = document.createElement('td');
            
            description = document.createElement('td');

            name.textContent = p.name;
            description.textContent = p.description;

            row.appendChild(name);
            row.appendChild(description);

            table.appendChild(row);
        }

        info.appendChild(table);
    }
}

function hint(editor, options) {
    var cur = editor.getCursor();

    var context = {};

    if (typeof options !== 'undefined' && typeof options.context !== 'undefined') {
        context = options.context;
    }

    var iter = {
        editor: editor,
        line: cur.line,
        tok: editor.getTokenAt(cur)
    };

    if (iter.tok.type === 'string' || iter.tok.type === 'comment') {
        return;
    }

    var ctx = [];
    var replace;

    if (iter.tok.string === '.') {
        ctx.unshift('');

        replace = {
            start: cur.ch,
            end: cur.ch
        };

        iterPrev(iter);
    } else {
        replace = iter.tok;
    }

    while (true) {
        if (iter.tok === null) {
            break;
        }

        if (iter.tok.type === 'property' || iter.tok.type === 'keyword' || (iter.tok.type !== null && iter.tok.type.indexOf('variable') === 0)) {
            ctx.unshift(iter.tok.string);

            iterPrev(iter);

            if (iter.tok === null || iter.tok.string !== '.') {
                break;
            }

            iterPrev(iter);
        } else {
            break;
        }
    }

    if (ctx.length === 0) {
        return;
    }

    var obj = context;

    var i;

    for (i = 0; i < ctx.length - 1; i++) {
        obj = obj[ctx[i]];

        if (obj === null || typeof obj === 'undefined') {
            return;
        }
    }

    var f = ctx[ctx.length - 1].toLowerCase();
    var matches = [];

    var names = Object.getOwnPropertyNames(obj);
    var seen = {}, m, k;

    for (i = 0; i < names.length; i++) {
        k = names[i];
        m = match(k.toLowerCase(), f);

        seen[k] = true;

        if (m !== false) {
            try {
                matches.push({text: k, d: m.distance, pos: m.pos, obj: obj[k]});
            } catch (e) {}
        }
    }

    for (k in obj) {
        if (k in seen) {
            continue;
        }

        m = match(k.toLowerCase(), f);

        if (m !== false) {
            try {
                matches.push({text: k, d: m.distance, pos: m.pos, obj: obj[k]});
            } catch (e) {}
        }
    }

    matches.sort(function(a, b) {
        if (a.d < b.d) {
            return -1;
        } else if (a.d > b.d) {
            return 1;
        }

        if (a.text < b.text) {
            return -1;
        } else if (a.text > b.text) {
            return 1;
        }

        return 0;
    });

    var completions = [];

    for (i = 0; i < matches.length; i++) {
        completions.push({
            text: matches[i].text,
            render: render,
            pos: matches[i].pos,
            obj: matches[i].obj
        });
    }

    var ret = {
        list: completions,
        from: CodeMirror.Pos(cur.line, replace.start),
        to: CodeMirror.Pos(cur.line, replace.end),
    };

    var parent = Object.getPrototypeOf(obj).constructor;

    CodeMirror.on(ret, 'select', function(completion, element) {
        var obj = completion.obj;
        var doc = null;

        if (typeof obj !== 'undefined' &&
            obj !== null &&
            typeof obj.__doc__ !== 'undefined') {
            doc = obj.__doc__;
        } else if (typeof parent !== 'undefined' &&
                   parent !== null &&
                   typeof parent.__doc__ !== 'undefined' &&
                   typeof parent.__doc__.members !== 'undefined' &&
                   typeof parent.__doc__.members[completion.text] !== 'undefined') {
            doc = {
                description: parent.__doc__.members[completion.text]
            };
        }

        var ul = element.parentNode;
        var info = editor._infoPopup;

        if (typeof info === 'undefined') {
            info = null;
        }

        if (doc === null && info !== null) {
            document.body.removeChild(info);
            delete editor._infoPopup;

            ul.classList.remove('showing-info');
        } else if (doc !== null) {
            if (info === null) {
                info = document.createElement('div');
                info.classList.add('hints-info');

                document.body.appendChild(info);
                editor._infoPopup = info;
            }

            fillInfo(info, completion, doc);

            info.style.left = (ul.offsetLeft + ul.offsetWidth) + 'px';
            info.style.top = ul.offsetTop + 'px';

            ul.classList.add('showing-info');
        }
    });

    CodeMirror.on(ret, 'close', function() {
        if (editor._infoPopup) {
            document.body.removeChild(editor._infoPopup);
            delete editor._infoPopup;
        }
    });

    return ret;
}

CodeMirror.registerHelper('hint', 'javascript', hint);

// vi:ts=4:et

},{"../utils/utils":52}],6:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


var Signals = require('../signals/signals');

function Program(name, v, f) {
    Signals.call(this);

    this.vertex = {
        data: v,
        history: { done: [], undone: [] }
    };

    this.fragment = {
        data: f,
        history: { done: [], undone: [] }
    };

    this._name = name;
    this._onNotifyName = this.registerSignal('notify::name');
    this._onNotifyError = this.registerSignal('notify::error');

    this._isDefault = false;
    this._error = null;
}

Program.prototype = Object.create(Signals.prototype);
Program.prototype.constructor = Program;

Program.default = function() {
    var v = "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n}\n";
    var f = "#version 100\n\nprecision mediump float;\n\nvoid main() {\n    gl_FragColor = vec4(0.5, 0.5, 0.5, 1);\n}\n";

    // Remove ending newline
    v = v.slice(0, v.length - 1);
    f = f.slice(0, f.length - 1);

    return new Program('Default', v, f);
};

Program.prototype.error = function(error) {
    if (typeof error === 'undefined') {
        return this._error;
    }

    this._error = error;
    this._onNotifyError();
};

Program.prototype.isDefault = function() {
    return this._isDefault;
};

Program.prototype.name = function(name) {
    if (typeof name === 'undefined') {
        return this._name;
    }

    if (this._name !== name) {
        var prev = this._name;

        this._name = name;
        this._onNotifyName(prev);
    }
};

Program.prototype._compileShader = function(gl, type, source) {
    var ret = gl.createShader(type);

    gl.shaderSource(ret, source);
    gl.compileShader(ret);

    var log = gl.getShaderInfoLog(ret);

    if (log.length === 0) {
        log = null;
    } else {
        gl.deleteShader(ret);
        ret = 0;
    }

    return {
        id: ret,
        error: log
    };
};

Program.prototype._definesToString = function(defines) {
    if (defines) {
        var ret = '';

        for (var k in defines) {
            ret += '#define ' + k + ' ' + defines[k] + '\n';
        }

        return ret;
    } else {
        return '';
    }
};

Program.prototype._sourceWithDefines = function(source, defines) {
    var m = source.match(/^\s*#version .*\n/);

    if (!m) {
        return defines + source;
    }

    var split = m.index + m[0].length;
    return source.slice(0, split) + defines + source.slice(split);
};

Program.prototype.compile = function(gl, defines) {
    var defs = this._definesToString(defines);

    var v = this._compileShader(gl, gl.VERTEX_SHADER, this._sourceWithDefines(this.vertex.data, defs));
    var f = this._compileShader(gl, gl.FRAGMENT_SHADER, this._sourceWithDefines(this.fragment.data, defs));
    var p = 0;

    var attrs = {
        'v_Position': 0,
        'v_Normal': 1,
        'v_TexCoord': 2
    };

    var error = null;

    if (v.id === 0 || f.id === 0) {
        if (v.id !== 0) {
            gl.deleteShader(v.id);
            v.id = 0;
        }

        if (f.id !== 0) {
            gl.deleteShader(f.id);
            f.id = 0;
        }
    } else {
        p = gl.createProgram();

        gl.attachShader(p, v.id);
        gl.attachShader(p, f.id);

        for (var attr in attrs) {
            gl.bindAttribLocation(p, attrs[attr], attr);
        }

        gl.linkProgram(p);

        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
            error = 'linking: ' + gl.getProgramInfoLog(p);
        } else {
            gl.validateProgram(p);

            if (!gl.getProgramParameter(p, gl.VALIDATE_STATUS)) {
                error = 'validation: ' + gl.getProgramInfoLog(p);
            }
        }
    }

    return {
        vertex: v,
        fragment: f,
        program: p,
        attributes: attrs,
        isDefault: this._isDefault,
        error: error,
        name: this._name
    };
};

Program.fromRemote = function(p) {
    var ret = new Program();

    ret.vertex = {
        data: p.vertex,
        history: {done: [], undone: []}
    };

    ret.fragment = {
        data: p.fragment,
        history: {done: [], undone: []}
    };

    ret._name = p.name;
    ret._isDefault = p.isDefault || false;

    return ret;
};

Program.prototype.remote = function() {
    return {
        version: 1,
        name: this._name,
        vertex: this.vertex.data,
        fragment: this.fragment.data,
        isDefault: this._isDefault
    };
};

Program.prototype.serialize = function() {
    return {
        version: 1,
        name: this._name,
        vertex: {
            data: this.vertex.data,
            history: this.vertex.history
        },
        fragment: {
            data: this.fragment.data,
            history: this.fragment.history
        },
        isDefault: this._isDefault
    };
};

Program.deserialize = function(program) {
    var ret = new Program();

    ret.vertex = {
        data: program.vertex.data,
        history: program.vertex.history
    };

    ret.fragment = {
        data: program.fragment.data,
        history: program.fragment.history
    };

    ret._name = program.name;
    ret._isDefault = program.isDefault;

    return ret;
};

module.exports = Program;

// vi:ts=4:et

},{"../signals/signals":34}],7:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Signals = require('../signals/signals');
var utils = require('../utils/utils');

/**
 * The javascript context.
 *
 * @constructor
 */
function JsContext(gl) {
    /**
     * The webgl context. This is the WebGLRenderingContext obtained
     * from the canvas.
     */
    this.gl = gl;

    /**
     * The models module. This module contains various high-level
     * utilities for creating and working with object models.
     */
    this.models = require('../models/models');

    /**
     * The math module. This module contains basic math types, including
     * vectors, matrices, quaternions and transforms. Note that this
     * module is provided by glMatrix, with a small number of additional
     * types and functions (such as transform).
     */
    this.math = require('../math/math');

    this.ui = require('./ui');

    /**
     * The shared program.
     */
    this.program = {};

    /**
     * A map of program names to compiled GLSL programs.
     */
    this.programs = {};
    this._defaultProgram = null;

    /**
     * A persistent state. You can use this to store and retrieve persistent state
     * between recompilations of your program.
     */
    this.state = {};

    this._signals = new Signals();
    this._signals.onEvent = this._signals.registerSignal('event');

    this._view = null;
    this._defines = {};

    this._signals.onDefine = this._signals.registerSignal('define');
}

JsContext.__doc__ = {"description":"The javascript context.","kind":"class","refid":"JsContext","members":{"gl":"The webgl context. This is the WebGLRenderingContext obtained\nfrom the canvas.","models":"The models module. This module contains various high-level\nutilities for creating and working with object models.","math":"The math module. This module contains basic math types, including\nvectors, matrices, quaternions and transforms. Note that this\nmodule is provided by glMatrix, with a small number of additional\ntypes and functions (such as transform).","program":"The shared program.","programs":"A map of program names to compiled GLSL programs.","state":"A persistent state. You can use this to store and retrieve persistent state\nbetween recompilations of your program."}};


/**
 * Get/set the current rendering view.
 *
 * When called without parameters, obtains the current rendering view,
 * otherwise sets it. The view is a model with an associated projection
 * and viewport. See {@link models.View} for more information on
 * constructing a view. All model rendering after setting a view will
 * use that views information to render.
 *
 * @param view the new view to set, or not provided to obtain the current view.
 */
JsContext.prototype.view = function(view) {
    if (typeof view === 'undefined') {
        return this._view;
    }

    if (this._view !== null) {
        this._view.unbind(this);
    }

    this._view = view;
    view.updateViewport(this);

    view.bind(this);
}

JsContext.prototype.view.__doc__ = {"description":"Get/set the current rendering view.\n\nWhen called without parameters, obtains the current rendering view,\notherwise sets it. The view is a model with an associated projection\nand viewport. See {@link models.View} for more information on\nconstructing a view. All model rendering after setting a view will\nuse that views information to render.","kind":"function","refid":"JsContext#view","params":[{"description":"the new view to set, or not provided to obtain the current view.","name":"view"}]};
;

JsContext.prototype.define = function(program, name, value) {
    if (!(program in this._defines)) {
        this._defines[program] = {};
    }

    this._defines[program][name] = value;
    this._signals.onDefine(program);
};

JsContext.prototype.defines = function(program, defines) {
    if (!(program in this._defines)) {
        this._defines[program] = {};
    }

    var prg = this._defines[program];

    for (var k in defines) {
        prg[k] = defines[k];
    }

    this._signals.onDefine(program);
};

JsContext.prototype.requireExtension = function(ext) {
    var e = this.gl.getExtension(ext);

    if (!e) {
        throw new Error('Missing required extension ' + ext);
    }

    return e;
};

JsContext.prototype.requireExtensions = function(exts) {
    var ret = {};

    for (var i = 0; i < exts.length; i++) {
        var e = this.requireExtension(exts[i]);

        ret[exts[i]] = e;
    }

    return ret;
};

JsContext.prototype.getExtension = function(ext) {
    return this.gl.getExtension(ext);
};

JsContext.prototype.getExtensions = function(exts) {
    var ret = {};

    for (var i = 0; i < exts.length; i++) {
        var e = this.gl.getExtension(exts[i]);

        if (e) {
            ret[exts[i]] = e;
        }
    }

    return ret;
};

/**
 * Find a GLSL program by name. If the name is not given, or null, then
 * the default program will be returned.
 *
 * @param name the program name.
 * @returns a program object.
 */
JsContext.prototype.findProgram = function(name) {
    if (!name) {
        return this._defaultProgram;
    }

    if (!(name in this.programs)) {
        return null;
    }

    return this.programs[name];
}

JsContext.prototype.findProgram.__doc__ = {"description":"Find a GLSL program by name. If the name is not given, or null, then\nthe default program will be returned.","kind":"function","refid":"JsContext#findProgram","params":[{"description":"the program name.","name":"name"}]};
;

function Renderer(canvas, fullscreenParent, options) {
    Signals.call(this);

    this.options = utils.merge({
        thumbnailWidth: 80,
        thumbnailHeight: 45
    }, options);

    this.canvas = canvas;
    this._canvasContainer = canvas.parentElement;
    this._canvasParent = this._canvasContainer.parentElement;

    this._fullscreenParent = fullscreenParent;
    this._isFullscreen = false;

    this._hideUi = false;

    this.context = this._createContext();
    this.program = null;
    this._mousePressed = false;
    this._frameCounter = 0;

    this._lastDocument = null;
    this._grabs = [];

    this._onNotifyFirstFrame = this.registerSignal('notify::first-frame');
    this._onNotifyFullscreen = this.registerSignal('notify::fullscreen');

    this._onError = this.registerSignal('error');

    var events = ['mousedown', 'mouseup', 'mousemove', 'keyup', 'keypress', 'wheel'];

    for (var i = 0; i < events.length; i++) {
        canvas.addEventListener(events[i], this._onPassEvent.bind(this));
    }

    canvas.addEventListener('keydown', this._onKeydown.bind(this));

    this._ui = [];
}

Renderer.prototype = Object.create(Signals.prototype);
Renderer.prototype.constructor = Renderer;

Renderer.prototype._onKeydown = function(e) {
    this._event(e);

    if (!e.defaultPrevented) {
        switch (e.keyCode) {
        case 70: // f
            this.toggleFullscreen();
            break;
        case 85: // u
            this.toggleUi();
            break;
        case 27: // escape
            if (this._isFullscreen) {
                this.toggleFullscreen();
            }
            break;
        case 32: // Space
            if (this._anim === 0) {
                this.start();
            } else {
                this.pause();
            }
            break;
        }
    }
};

Renderer.prototype._onPassEvent = function(e) {
    if (e.type === 'mousedown') {
        this._mousePressed = true;

        this._onMousemove = (function(e) {
            this._event(e);

            e.preventDefault();
            e.stopPropagation();
        }).bind(this);

        this._onMouseup = (function(e) {
            this._event(e);
            this._mousePressed = false;

            window.removeEventListener('mousemove', this._onMousemove);
            window.removeEventListener('mouseup', this._onMouseup);
        }).bind(this);

        window.addEventListener('mousemove', this._onMousemove);
        window.addEventListener('mouseup', this._onMouseup);
    }

    if ((e.type !== 'mousemove' && e.type !== 'mouseup') || !this._mousePressed) {
        this._event(e);
    }
};

Renderer.prototype._event = function(e) {
    if (this.program && typeof this.program.event === 'function') {
        try {
            this.program.event.call(this.program, this.context, e);
        } catch (err) {
            this._onError('js', err);
            this.pause();
        }
    }

    if (!e.defaultPrevented) {
        this.context._signals.onEvent(e);
    }
};

Renderer.getWebGLContext = function(canvas) {
    var ctx = canvas.getContext('webgl');

    if (!ctx) {
        ctx = canvas.getContext('experimental-webgl');
    }

    return ctx;
};

Renderer.prototype._createContext = function() {
    var ctx = Renderer.getWebGLContext(this.canvas);
    var ret = new JsContext(ctx);

    ret.ui.add = this._uiAdd.bind(this);
    return ret;
};

Renderer.prototype._removeUi = function(ui) {
    for (var i = 0; i < ui.length; i++) {
        ui[i].e.parentElement.removeChild(ui[i].e);
    }
};

Renderer.prototype.update = function(doc) {
    var complete = true;

    var errors = {
        js: {
            parse: null,
            run: null,
            init: null,
            extensions: null
        },
        programs: null
    };

    var func = null;

    // Compile javascript
    try {
        // jshint ignore:start
        func = new Function(doc.js.data
                            + '\n\nreturn {init: typeof init !== "undefined" ? init : null'
                            + ', render: typeof render !== "undefined" ? render : null'
                            + ', save: typeof save !== "undefined" ? save : null'
                            + ', event: typeof event !== "undefined" ? event : null'
                            + ', extensions: typeof extensions !== "undefined" ? extensions : null};');
        // jshint ignore:end
    } catch (e) {
        console.error(e.stack);

        errors.js.parse = e;
        complete = false;
    }

    var state = {};

    if ((doc === this._lastDocument || this._lastDocument === null) && this.program && this.program.save) {
        try {
            var nstate = this.program.save.call(this.program, this.context);

            if (typeof nstate !== 'undefined') {
                state = nstate;
            }
        } catch (e) {
            console.error(e.stack);
        }
    }

    var nctx = this._createContext();
    nctx.state = state;

    var obj = {};
    var ret = null;

    if (func !== null) {
        try {
            ret = func.call(obj);
        } catch (e) {
            console.error(e.stack);

            errors.js.run = e;
            complete = false;
        }
    }

    if (ret !== null && complete && ret.extensions) {
        try {
            ret.extensions.call(ret, nctx);
        } catch (e) {
            console.error(e.stack);

            errors.js.extensions = e;
            complete = false;
        }
    }

    // Compile all programs
    var programs = {};
    var defaultProgram = null;
    var originalPrograms = {};

    for (var i = 0; i < doc.programs.length; i++) {
        var p = doc.programs[i];
        var prog = p.compile(this.context.gl, nctx._defines[p.name()]);

        originalPrograms[p.name()] = p;

        if (prog.vertex.error !== null || prog.fragment.error !== null || prog.error !== null) {
            if (errors.programs === null) {
                errors.programs = {};
            }

            if (prog.vertex.error !== null) {
                console.error(p.name() + '(vertex): ' + prog.vertex.error);
            }

            if (prog.fragment.error !== null) {
                console.error(p.name() + '(fragment): ' + prog.fragment.error);
            }

            if (prog.error !== null) {
                console.error(p.name() + '(program): ' + prog.error);
            }

            errors.programs[p.name()] = {
                vertex: prog.vertex.error,
                fragment: prog.fragment.error,
                program: prog.error
            };

            complete = false;
        }

        programs[p.name()] = prog;

        if (prog.isDefault) {
            defaultProgram = prog;
        }
    }

    nctx._defaultProgram = defaultProgram;

    nctx._signals.on('define', (function(_, program) {
        var p = originalPrograms[program];

        if (p) {
            var prog = p.compile(nctx.gl, nctx._defines[program]);

            if (prog.vertex.error !== null || prog.fragment.error !== null || prog.error !== null) {
                this._onError('program', {
                    errors: {
                        program: prog.error,
                        vertex: prog.vertex.error,
                        fragment: prog.fragment.error
                    },

                    program: p.name()
                });
            } else {
                programs[program] = prog;

                if (program === nctx._defaultProgram.name) {
                    nctx._defaultProgram = prog;
                }
            }

        }
    }).bind(this));

    var prevUi = this._ui;
    this._ui = [];

    if (ret !== null && complete && ret.init) {
        try {
            ret.init.call(ret, nctx);
        } catch (e) {
            console.error(e.stack);

            errors.js.init = e;
            complete = false;
        }
    }

    if (!complete) {
        this._removeUi(this._ui);
        this._ui = prevUi;
        return errors;
    }

    this._removeUi(prevUi);

    this.context = nctx;
    this.context.programs = programs;

    this.program = ret;

    this._lastDocument = doc;
    this._frameCounter = 0;
    this.start();
};

Renderer.prototype._extractUiIds = function(ui, prefix, ret) {
    if (typeof ui._settings.id !== 'undefined') {
        if (prefix) {
            prefix += '.' + ui._settings.id;
        } else {
            prefix = ui._settings.id;
        }

        ret[prefix] = ui;
    }

    for (var i = 0; i < ui.children.length; i++) {
        this._extractUiIds(ui.children[i], prefix, ret);
    }

    return ret;
};

Renderer.prototype._uiAdd = function(ui, placement) {
    this._canvasContainer.appendChild(ui.e);
    this._ui.push(ui);

    if (placement) {
        for (var p in placement) {
            var v = placement[p];

            if (typeof v === 'number') {
                v += 'px';
            }

            ui.e.style[p] = v;
        }
    }

    return this._extractUiIds(ui, '', {});
};

Renderer.prototype._grabImageReal = function(width, height) {
    var canvas = document.createElement('canvas');

    var r = this.canvas.height / this.canvas.width;

    // Half down sample N times until we reach thumbnail_width
    var pw = this.canvas.width;
    var ph = this.canvas.height;

    var step = 1.8;

    var w = Math.floor(pw / step);
    var h = Math.floor(ph / step);

    var thumbnail = {
        width: width,
        height: height
    };

    // Keep aspect ratio
    if (pw > thumbnail.width / thumbnail.height * ph) {
        thumbnail.height = (thumbnail.width / pw) * ph;
    } else {
        thumbnail.width = (thumbnail.height / ph) * pw;
    }

    canvas.width = Math.max(w, thumbnail.width);
    canvas.height = Math.floor(canvas.width * r);

    var ctx = canvas.getContext('2d');

    var source = this.canvas;
    ctx.globalCompositeOperation = 'copy';

    // Iteratively scale down the original image size by a factor of 2
    // until we reach the desired size. Doing it in one step gives poor
    // results due to the standard (and non-controllable) 2x2 bilinear
    // filter that most browsers use.
    while (true) {
        if (w < thumbnail.width) {
            w = thumbnail.width;
        }

        h = Math.floor(w * r);
        ph = Math.floor(pw * r);

        ctx.drawImage(source, 0, 0, pw, ph, 0, 0, w, h);
        source = canvas;

        if (w === thumbnail.width) {
            break;
        }

        pw = w;
        w = Math.floor(w / step);
    }

    // Set canvas to the correct final size so we can get the data url from it.
    // Note that doing this blanks the canvas, so we first get the image data,
    // then resize the canvas and put back the image data. Finally we can get
    // the correctly sized data URL.
    var img = ctx.getImageData(0, 0, w, Math.floor(w * r));
    canvas.width = w;
    canvas.height = Math.floor(w * r);
    ctx.putImageData(img, 0, 0);

    return canvas.toDataURL();
};

Renderer.prototype._grabThumbnail = function() {
    return this._grabImageReal(this.options.thumbnailWidth, this.options.thumbnailHeight);
};

Renderer.prototype.grabImage = function(width, height, cb) {
    this._grabs.push({
        width: width,
        height: height,
        cb: cb
    });
};

Renderer.prototype.doRender = function() {
    this._anim = requestAnimationFrame(this.doRender.bind(this));

    if (this.program.render) {
        this.context._renderedSomething = false;

        try {
            this.program.render.call(this.program, this.context);
        } catch (e) {
            this._onError('js', e);
            console.error(e.stack);
            this.pause();
            return;
        }

        if (this.context._renderedSomething) {
            this._frameCounter++;

            if (this._frameCounter === 1) {
                var dataurl = this._grabThumbnail();
                this._onNotifyFirstFrame(dataurl);
            }

            if (this._grabs.length > 0) {
                for (var i = 0; i < this._grabs.length; i++) {
                    var g = this._grabs[i];

                    g.cb(this._grabImageReal(g.width, g.height));
                }

                this._grabs = [];
            }
        }
    }
};

Renderer.prototype.start = function() {
    if (this._anim !== 0) {
        cancelAnimationFrame(this._anim);
        this._anim = 0;
    }

    this._anim = requestAnimationFrame(this.doRender.bind(this));
};

Renderer.prototype.pause = function() {
    if (this._anim !== 0) {
        cancelAnimationFrame(this._anim);
        this._anim = 0;
    }
};

Renderer.prototype.toggleUi = function() {
    if (this._hideUi) {
        this._canvasContainer.classList.remove('hide-ui');
    } else {
        this._canvasContainer.classList.add('hide-ui');
    }

    this._hideUi = !this._hideUi;
};

Renderer.prototype.toggleFullscreen = function() {
    var hasFocus = (document.activeElement === this.canvas);

    this._canvasContainer.parentElement.removeChild(this._canvasContainer);

    if (this._isFullscreen) {
        this._canvasParent.appendChild(this._canvasContainer);
        this._canvasContainer.classList.remove('fullscreen');
    } else {
        this._fullscreenParent.appendChild(this._canvasContainer);
        this._canvasContainer.classList.add('fullscreen');
    }

    if (hasFocus) {
        this.canvas.focus();
    }

    this._isFullscreen = !this._isFullscreen;
    this._onNotifyFullscreen();
};

module.exports = Renderer;

// vi:ts=4:et

},{"../math/math":18,"../models/models":24,"../signals/signals":34,"../utils/utils":52,"./ui":9}],8:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function Store(ready) {
    this._db = null;
    this._ready = ready;

    var version = 6;

    //indexedDB.deleteDatabase('webgl-play');
    var req = window.indexedDB.open('webgl-play', version);

    req.onsuccess = this._onsuccess.bind(this);
    req.onerror = this._onerror.bind(this);
    req.onupgradeneeded = this._onupgradeneeded.bind(this);
}

Store.prototype.saveAppSettings = function(settings) {
    var tr = this._db.transaction('app-settings', 'readwrite');
    var store = tr.objectStore('app-settings');
    var req;

    if (!('id' in settings)) {
        req = store.add(settings);
    } else {
        req = store.put(settings);
    }

    req.onsuccess = function(e) {
        if (e.target.result) {
            settings.id = e.target.result;
        }
    };
};

Store.prototype.appSettings = function(cb) {
    var tr = this._db.transaction('app-settings');
    var store = tr.objectStore('app-settings');

    var req = store.openCursor();

    req.onsuccess = (function(ev) {
        if (ev.target.result) {
            cb(this, ev.target.result.value);
        } else {
            cb(this, {});
        }
    }).bind(this);

    req.onerror = (function() {
        cb(this, {});
    }).bind(this);
};

Store.prototype.objectToCache = function(url, filename, date, obj) {
    var tr = this._db.transaction('object-cache', 'readwrite');
    var store = tr.objectStore('object-cache');

    store.put({
        date: date,
        filename: filename
    }, url + '-date');

    store.put({
        object: obj,
        filename: filename
    }, url);
};

Store.prototype.objectFromCache = function(url, date, cb) {
    var tr = this._db.transaction('object-cache');
    var store = tr.objectStore('object-cache');

    var req = store.get(url + '-date');

    req.onsuccess = (function(ev) {
        if (ev.target.result) {
            var d = ev.target.result.date;

            if (d.getTime() === date.getTime()) {
                req = store.get(url);

                req.onsuccess = (function(ev) {
                    if (ev.target.result) {
                        cb(this, ev.target.result.object);
                    } else {
                        cb(this, null);
                    }
                }).bind(this);

                req.onerror = (function(ev) {
                    console.error('database error', ev);
                    cb(this, null);
                }).bind(this);
            } else {
                cb(this, null);
            }
        } else {
            cb(this, null);
        }
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.delete = function(doc, cb) {
    if (!('id' in doc)) {
        cb(this, null);
        return;
    }

    var tr = this._db.transaction('documents', 'readwrite');
    var store = tr.objectStore('documents');

    var req = store.delete(doc.id);

    req.onsuccess = (function() {
        cb(this, doc);
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.byShare = function(share, cb) {
    var tr = this._db.transaction('documents');
    var store = tr.objectStore('documents');
    var idx = store.index('share');

    var req = idx.get(share);

    req.onsuccess = (function(ev) {
        if (ev.target.result) {
            cb(this, ev.target.result);
        } else {
            cb(this, null);
        }
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.byId = function(id, cb) {
    var tr = this._db.transaction('documents');
    var store = tr.objectStore('documents');
    var req = store.get(id);

    req.onsuccess = (function(ev) {
        if (ev.target.result) {
            cb(this, ev.target.result);
        } else {
            cb(this, null);
        }
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.last = function(cb) {
    var tr = this._db.transaction('documents');
    var store = tr.objectStore('documents');
    var idx = store.index('modificationTime');

    var req = idx.openCursor(null, 'prev');

    req.onsuccess = (function(ev) {
        if (ev.target.result) {
            cb(this, ev.target.result.value);
        } else {
            cb(this, null);
        }
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.all = function(cb) {
    var tr = this._db.transaction('documents');
    var store = tr.objectStore('documents');
    var idx = store.index('modificationTime');

    var req = idx.openCursor(null, 'prev');

    var ret = [];

    req.onsuccess = (function(ev) {
        var res = ev.target.result;

        if (res) {
            ret.push(res.value);
            res.continue();
        } else {
            cb(this, ret);
        }
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, ret);
    }).bind(this);
};

Store.prototype.addModel = function(model, data, cb) {
    if (!('filename' in model)) {
        cb(this, null);
        return;
    }

    var tr = this._db.transaction(['models', 'model-data'], 'readwrite');
    var models = tr.objectStore('models');
    var modelData = tr.objectStore('model-data');

    models.put(model);
    modelData.put({
        filename: model.filename,
        creationTime: model.creationTime,
        modificationTime: model.modificationTime,
        data: data
    });

    tr.oncomplete = (function() {
        cb(this, model);
    }).bind(this);

    tr.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.modelData = function(filename, cb) {
    var tr = this._db.transaction('model-data');
    var store = tr.objectStore('model-data');

    var req = store.get(filename);

    req.onsuccess = (function(e) {
        if (e.target.result) {
            cb(this, e.target.result);
        } else {
            cb(this, null);
        }
    }).bind(this);

    req.onerror = (function(e) {
        console.error('database error', e);
        cb(this, null);
    }).bind(this);
};

Store.prototype.deleteModel = function(model, cb) {
    if (!('filename' in model)) {
        cb(this, null);
        return;
    }

    var tr = this._db.transaction(['models', 'model-data', 'object-cache'], 'readwrite');

    tr.objectStore('models').delete(model.filename);
    tr.objectStore('model-data').delete(model.filename);

    var cacheStore = tr.objectStore('object-cache');
    var req = cacheStore.index('filename').openCursor('local:' + model.filename);

    req.onsuccess = function(e) {
        if (e.target) {
            var cursor = e.target.result;

            if (cursor) {
                cacheStore.delete(cursor.primaryKey);
                cursor.continue();
            }
        }
    };

    tr.oncomplete = (function() {
        cb(this, model);
    }).bind(this);

    tr.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, null);
    }).bind(this);
};

Store.prototype.models = function(cb) {
    var tr = this._db.transaction('models');
    var store = tr.objectStore('models');
    var req = store.openCursor();

    var ret = [];

    req.onsuccess = (function(ev) {
        var res = ev.target.result;

        if (res) {
            ret.push(res.value);
            res.continue();
        } else {
            cb(this, ret);
        }
    }).bind(this);

    req.onerror = (function(ev) {
        console.error('database error', ev);
        cb(this, ret);
    }).bind(this);
};

Store.prototype.save = function(doc, cb) {
    var tr = this._db.transaction('documents', 'readwrite');
    var store = tr.objectStore('documents');

    tr.onerror = (function(ev) {
        console.error('error saving doc', ev);

        if (typeof cb === 'function') {
            cb(this, null);
        }
    }).bind(this);

    var req;

    if (!('id' in doc)) {
        req = store.add(doc);
    } else {
        req = store.put(doc);
    }

    req.onsuccess = (function(ev) {
        if (!('id' in doc)) {
            doc.id = ev.target.result;
        }

        if (typeof cb === 'function') {
            cb(this, doc);
        }
    }).bind(this);
};

Store.prototype._onsuccess = function(e) {
    this._db = e.target.result;

    if (typeof this._ready === 'function') {
        this._ready(this);
    }
};

Store.prototype._onerror = function(e) {
    console.error('Database error', e);
};

Store.prototype._onupgradeneeded = function(e) {
    var db = e.target.result;
    var tr = e.currentTarget.transaction;

    var documentsStore;
    var objectCacheStore;
    var modelsStore;
    var modelDataStore;

    // Initial database
    if (e.oldVersion <= 0) {
        documentsStore = db.createObjectStore('documents', { autoIncrement: true, keyPath: 'id' });

        documentsStore.createIndex('modificationTime', 'modificationTime', { unique: false });
        documentsStore.createIndex('creationTime', 'creationTime', { unique: false });
        documentsStore.createIndex('title', 'title', { unique: false });
    } else {
        documentsStore = tr.objectStore('documents');
    }

    // Add object cache
    if (e.oldVersion <= 1) {
        objectCacheStore = db.createObjectStore('object-cache');
    } else {
        objectCacheStore = tr.objectStore('object-cache');
    }

    // Add index on share key
    if (e.oldVersion <= 2) {
        documentsStore.createIndex('share', 'share', { unique: false });
    }

    // Add stores for local models
    if (e.oldVersion <= 3) {
        modelsStore = db.createObjectStore('models', { keyPath: 'filename' });
        modelDataStore = db.createObjectStore('model-data', { keyPath: 'filename' });
    } else {
        modelsStore = tr.objectStore('models');
        modelDataStore = tr.objectStore('model-data');
    }

    // Add index for local models
    if (e.oldVersion <= 4) {
        objectCacheStore.createIndex('filename', 'filename', { unique: false });
    }

    var appSettingsStore;

    // Add app-settings
    if (e.oldVersion <= 5) {
        appSettingsStore = db.createObjectStore('app-settings', { autoIncrement: true, keyPath: 'id' });
    }
};

module.exports = Store;

// vi:ts=4:et

},{}],9:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var ui = require('../ui/ui');

function grid(props) {
    return new ui.Grid(props);
}

function label(props) {
    if (typeof props === 'string') {
        props = {
            value: props
        };
    }

    return new ui.Label(props);
}

function multiswitch(props) {
    return new ui.MultiSwitch(props);
}

function onoff(props) {
    return new ui.OnOff(props);
}

function slider(props) {
    return new ui.Slider(props);
}

function colorPicker(props) {
    return new ui.ColorPicker(props);
}

exports.grid = grid;
exports.label = label;
exports.multiswitch = multiswitch;
exports.onoff = onoff;
exports.slider = slider;
exports.colorPicker = colorPicker;

// vi:ts=4:et

},{"../ui/ui":50}],10:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

var glsl = {
    tokenizer: require('./tokenizer'),
    preprocessor: require('./preprocessor'),
    source: require('./source')
};

var Tn = glsl.tokenizer.Tokenizer;

var SYNC_FAIL       = 0,
    SYNC_OK         = 1,
    SYNC_OK_CONSUME = 2;

function Error(loc, message) {
    glsl.source.Error.call(this, loc, message);
}

Error.prototype = Object.create(glsl.source.Error.prototype);
Error.prototype.constructor = Error;

function Node() {
    this.incomplete = true;
}

exports.Node = Node;

Node.create = function(name, constructor, parent) {
    if (typeof parent === 'undefined') {
        parent = Node;
    }

    var ret = Object.create(parent.prototype);

    ret.nodeName = name;
    ret.constructor = constructor;

    return ret;
};

Node.prototype._valueIsEmpty = function(v) {
    if (v === null) {
        return true;
    }

    if (v === false) {
        return true;
    }

    if (v === 0) {
        return true;
    }

    if (Array.prototype.isPrototypeOf(v) && v.length === 0) {
        return true;
    }

    if (Object.prototype.isPrototypeOf(v)) {
        for (var prop in v) {
            if (v.hasOwnProperty(prop)) {
                return false;
            }
        }

        return true;
    }

    return false;
};

Node.prototype.complete = function() {
    this.incomplete = false;
    return this;
};

Node.prototype._marshalObjectIsRef = function(value, inctype) {
    if (Node.prototype.isPrototypeOf(value) &&
        value.marshalCanRef() &&
        typeof value.__marshalRefId != 'undefined') {

        value.__marshalRef++;

        var ret = '';

        if (inctype) {
            ret += value.nodeName;
        }

        return ret + '@' + value.__marshalRefId;
    }

    return null;
};

Node.prototype.marshalNodeName = function() {
    return this.nodeName;
};

Node.prototype.marshalCanRef = function() {
    return true;
};

Node.prototype._marshalObject = function(value, ctx) {
    var ret = {};

    var isref = this._marshalObjectIsRef(value, false);

    if (isref !== null) {
        return isref;
    }

    if (Node.prototype.isPrototypeOf(value) && value.marshalCanRef()) {
        value.__marshalRef = 1;
        value.__marshalRefId = ctx.__marshalRefId++;
        value.__marshalled = ret;

        ctx.objects.push(value);
    }

    for (var k in value) {
        if (k[0] != '_' && value.hasOwnProperty(k) && !this._valueIsEmpty(value[k])) {
            var name = k;
            var val = value[k];

            if (typeof val == 'object' && typeof val.marshalNodeName === 'function') {
                name += '(' + val.marshalNodeName() + ')';
            }

            ret[name] = this._marshalValue(val, ctx);
        }
    }

    return ret;
};

Node.prototype._marshalArray = function(value, ctx) {
    var ret = new Array(value.length);

    for (var i = 0; i < value.length; i++) {
        var val = value[i];

        if (typeof val == 'object' && Node.prototype.isPrototypeOf(val)) {
            var isref = this._marshalObjectIsRef(val, true);

            if (isref === null) {
                var h = {};
                h[val.nodeName] = this._marshalValue(val, ctx);

                ret[i] = h;
            } else {
                ret[i] = isref;
            }
        } else {
            ret[i] = this._marshalValue(val, ctx);
        }
    }

    return ret;
};

Node.prototype._marshalValue = function(value, ctx) {
    if (typeof value === 'undefined') {
        return 'undefined';
    }

    if (typeof value != 'object') {
        return value;
    }

    if (Array.prototype.isPrototypeOf(value)) {
        return this._marshalArray(value, ctx);
    }

    var ret = this._marshalObjectIsRef(value, false);

    if (ret === null) {
        if (typeof value.marshal == 'function') {
            ret = value.marshal(ctx);
        } else {
            ret = this._marshalObject(value, ctx);
        }
    }

    return ret;
};

Node.prototype.marshal = function(ctx) {
    var ownedCtx = false;

    if (typeof ctx === 'undefined') {
        ctx = {
            __marshalRefId: 1,
            objects: []
        };

        ownedCtx = true;
    }

    var ret = this._marshalObject(this, ctx);

    if (ownedCtx) {
        for (var i = 0; i < ctx.objects.length; i++) {
            var obj = ctx.objects[i];

            if (obj.__marshalRef > 1) {
                obj.__marshalled['@id'] = obj.__marshalRefId;
            }

            delete obj.__marshalRef;
            delete obj.__marshalled;
            delete obj.__marshalRefId;
        }
    }

    return ret;
};

Node.prototype.location = function() {
    throw new Error(this.nodeName + ' does not implement required location()');
};

Node.prototype.toJson = function() {
    return JSON.stringify(this, function(key, value) {
        if (key[0] == '_') {
            return null;
        }

        return value;
    });
};

function TypeRef(tok) {
    Node.call(this);

    this.token = tok;
    this.decl = null;

    this.qualifiers = [];

    if (tok !== null) {
        this.isPrimitive = (tok.id != Tn.T_IDENTIFIER);
    } else {
        this.isPrimitive = false;
    }
}

TypeRef.prototype = Node.create('TypeRef', TypeRef);
exports.TypeRef = TypeRef;

TypeRef.wrapDecl = function(decl) {
    if (TypeRef.prototype.isPrototypeOf(decl)) {
        return decl;
    }

    var ret = new TypeRef(null);
    ret.decl = decl;

    if (!decl.incomplete) {
        ret.complete();
    }

    return ret;
};

TypeRef.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.qualifiers);
};

TypeRef.prototype.hasQualifier = function(qid) {
    for (var i = 0; i < this.qualifiers.length; i++) {
        var q = this.qualifiers[i];

        if (q.id == qid) {
            return true;
        }
    }

    return false;
};

TypeRef.prototype.isConst = function() {
    return this.hasQualifier(Tn.T_CONST);
};

TypeRef.prototype.isAttribute = function() {
    return this.hasQualifier(Tn.T_ATTRIBUTE);
};

TypeRef.prototype.isVarying = function() {
    return this.hasQualifier(Tn.T_VARYING);
};

TypeRef.prototype.isUniform = function() {
    return this.hasQualifier(Tn.T_UNIFORM);
};

function StructDecl(stok) {
    Node.call(this);

    this.token = stok;
    this.name = null;

    this.leftBrace = null;
    this.rightBrace = null;

    this.fields = [];
}

StructDecl.prototype = Node.create('StructDecl', StructDecl);
exports.StructDecl = StructDecl;

StructDecl.prototype.location = function() {
    return glsl.source.Range.spans(this.token,
                                   this.name,
                                   this.fields,
                                   this.leftBrace,
                                   this.rightBrace);
};

function FieldDecl(type) {
    Node.call(this);

    this.type = type;
    this.names = [];
    this.semi = null;
}

FieldDecl.prototype = Node.create('FieldDecl', FieldDecl);
exports.FieldDecl = FieldDecl;

FieldDecl.prototype.location = function() {
    return glsl.source.Range.spans(this.type, this.names, this.semi);
};


function PrecisionStmt(token) {
    Node.call(this);

    this.token = token;
    this.qualifier = null;
    this.type = null;

    this.semi = null;
}

PrecisionStmt.prototype = Node.create('PrecisionStmt', PrecisionStmt);
exports.PrecisionStmt = PrecisionStmt;

PrecisionStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token,
                                   this.qualifier,
                                   this.type,
                                   this.semi);
};


function InvariantDecl(token) {
    Node.call(this);

    this.token = token;
    this.names = [];

    this.semi = null;
}

InvariantDecl.prototype = Node.create('InvariantDecl', InvariantDecl);
exports.InvariantDecl = InvariantDecl;

InvariantDecl.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.names, this.semi);
};


function VariableDecl(type) {
    Node.call(this);

    this.type = type;
    this.names = [];

    this.semi = null;
}

VariableDecl.prototype = Node.create('VariableDecl', VariableDecl);
exports.VariableDecl = VariableDecl;

VariableDecl.prototype.location = function() {
    return glsl.source.Range.spans(this.type, this.names, this.semi);
};


function TypeDecl(type) {
    Node.call(this);

    this.type = type;
    this.semi = null;
}

TypeDecl.prototype = Node.create('TypeDecl', TypeDecl);
exports.TypeDecl = TypeDecl;

TypeDecl.prototype.location = function() {
    return glsl.source.Range.spans(this.type, this.semi);
};


function ParamDecl() {
    Node.call(this);

    this.type = null;
    this.name = null;
    this.qualifier = null;

    this.isArray = false;
    this.arraySize = null;
    this.leftBracket = null;
    this.rightBracket = null;
}

ParamDecl.prototype = Node.create('ParamDecl', ParamDecl);
exports.ParamDecl = ParamDecl;

ParamDecl.prototype.location = function() {
    return glsl.source.Range.spans(this.type,
                                   this.name,
                                   this.qualifier,
                                   this.arraySize,
                                   this.leftBracket,
                                   this.rightBracket);
};


function Named(name, decl) {
    Node.call(this);

    this.name = name;
    this.decl = decl;
    this.type = null;

    this.initialAssign = null;
    this.initialValue = null;

    this.isArray = false;
    this.arraySize = null;
    this.leftBracket = null;
    this.rightBracket = null;
}

Named.prototype = Node.create('Named', Named);
exports.Named = Named;

Named.prototype.location = function() {
    return glsl.source.Range.spans(this.name,
                                   this.initialAssign,
                                   this.initialValue,
                                   this.arraySize,
                                   this.leftBracket,
                                   this.rightBracket);
};


function FunctionHeader(type, name) {
    Node.call(this);

    this.type = type;
    this.name = name;
    this.parameters = [];
    this.leftParen = null;
    this.rightParen = null;
}

FunctionHeader.prototype = Node.create('FunctionHeader', FunctionHeader);
exports.FunctionHeader = FunctionHeader;

FunctionHeader.prototype.location = function() {
    return glsl.source.Range.spans(this.type,
                                   this.name,
                                   this.parameters,
                                   this.leftParen,
                                   this.rightParen);
};

FunctionHeader.signatureFromNames = function(name, argnames) {
    var ret = name + '(';

    for (var i = 0; i < argnames.length; i++) {
        var item = argnames[i];

        if (i !== 0) {
            ret += ',';
        }

        ret += item;
    }

    return ret + ')';
};

FunctionHeader.prototype.signature = function() {
    var argnames = [];

    for (var i = 0; i < this.parameters.length; i++) {
        var param = this.parameters[i];

        if (param.type.token.id == Tn.T_VOID) {
            continue;
        }

        argnames.push(param.type.token.text);
    }

    return FunctionHeader.signatureFromNames(this.name.text, argnames);
};

function FunctionProto(header) {
    Node.call(this);

    this.header = header;
    this.isBuiltin = false;
    this.semi = null;
}

FunctionProto.prototype = Node.create('FunctionProto', FunctionProto);
exports.FunctionProto = FunctionProto;

FunctionProto.prototype.location = function() {
    return glsl.source.Range.spans(this.header.location(), this.semi);
};

function FunctionDef(header) {
    Node.call(this);

    this.header = header;
    this.body = null;
}

FunctionDef.prototype = Node.create('FunctionDef', FunctionDef);
exports.FunctionDef = FunctionDef;

FunctionDef.prototype.location = function() {
    return glsl.source.Range.spans(this.header, this.body);
};

function Block() {
    Node.call(this);

    this.rightBrace = null;
    this.leftBrace = null;
    this.body = [];
    this.newScope = true;
}

Block.prototype = Node.create('Block', Block);
exports.Block = Block;

Block.prototype.location = function() {
    return glsl.source.Range.spans(this.rightBrace, this.body, this.leftBrace);
};

function EmptyStmt(semi) {
    Node.call(this);

    this.semi = semi;
}

EmptyStmt.prototype = Node.create('EmptyStmt', EmptyStmt);
exports.EmptyStmt = EmptyStmt;

EmptyStmt.prototype.location = function() {
    return this.semi.location.copy();
};

function ExpressionStmt(expr) {
    Node.call(this);

    this.expression = expr;
    this.semi = null;
}

ExpressionStmt.prototype = Node.create('ExpressionStmt', ExpressionStmt);
exports.ExpressionStmt = ExpressionStmt;

ExpressionStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.expression, this.semi);
};

function ExpressionListStmt() {
    Node.call(this);

    this.expressions = [];
    this.semi = null;
}

ExpressionListStmt.prototype = Node.create('ExpressionListStmt', ExpressionListStmt);
exports.ExpressionListStmt = ExpressionListStmt;

ExpressionListStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.expressions, this.semi);
};


function SelectionStmt(tok) {
    Node.call(this);

    this.token = tok;
    this.leftParen = null;
    this.condition = null;
    this.rightParen = null;
    this.body = null;
    this.els = null;
}

SelectionStmt.prototype = Node.create('SelectionStmt', SelectionStmt);
exports.SelectionStmt = SelectionStmt;

SelectionStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token,
                                   this.leftParen,
                                   this.condition,
                                   this.rightParen,
                                   this.body,
                                   this.els);
};


function SelectionElseStmt(tok) {
    Node.call(this);

    this.token = tok;
    this.body = null;
}

SelectionElseStmt.prototype = Node.create('SelectionElseStmt', SelectionElseStmt);
exports.SelectionElseStmt = SelectionElseStmt;

SelectionElseStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.body);
};


function WhileStmt(tok) {
    Node.call(this);

    this.token = tok;

    this.leftParen = null;
    this.condition = null;
    this.rightParen = null;
    this.body = null;
}

WhileStmt.prototype = Node.create('WhileStmt', WhileStmt);
exports.WhileStmt = WhileStmt;

WhileStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token,
                                   this.leftParen,
                                   this.condition,
                                   this.rightParen,
                                   this.body);
};


function DoStmt(dtok) {
    Node.call(this);

    this.doToken = dtok;
    this.whileToken = null;

    this.leftParen = null;
    this.condition = null;
    this.rightParen = null;
    this.body = null;
}

DoStmt.prototype = Node.create('DoStmt', DoStmt);
exports.DoStmt = DoStmt;

DoStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.doToken,
                                   this.whileToken,
                                   this.leftParen,
                                   this.condition,
                                   this.rightParen,
                                   this.body);
};


function ForStmt(tok) {
    Node.call(this);

    this.token = tok;

    this.leftParen = null;
    this.init = null;
    this.rest = null;
    this.rightParen = null;
    this.body = null;
}

ForStmt.prototype = Node.create('ForStmt', ForStmt);
exports.ForStmt = ForStmt;

ForStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token,
                                   this.leftParen,
                                   this.init,
                                   this.rest,
                                   this.rightParen,
                                   this.body);
};


function ForRestStmt(cond) {
    Node.call(this);

    this.condition = cond;
    this.semi = null;
    this.expression = null;
}

ForRestStmt.prototype = Node.create('ForRestStmt', ForRestStmt);
exports.ForRestStmt = ForRestStmt;

ForRestStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.condition, this.semi, this.expression);
};


function ContinueStmt(tok) {
    Node.call(this);

    this.token = tok;
    this.semi = null;
}

ContinueStmt.prototype = Node.create('ContinueStmt', ContinueStmt);
exports.ContinueStmt = ContinueStmt;

ContinueStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.semi);
};


function BreakStmt(tok) {
    Node.call(this);

    this.token = tok;
    this.semi = null;
}

BreakStmt.prototype = Node.create('BreakStmt', BreakStmt);
exports.BreakStmt = BreakStmt;

BreakStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.semi);
};


function ReturnStmt(tok) {
    Node.call(this);

    this.token = tok;
    this.expression = null;
    this.semi = null;
}

ReturnStmt.prototype = Node.create('ReturnStmt', ReturnStmt);
exports.ReturnStmt = ReturnStmt;

ReturnStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.expression, this.semi);
};


function DiscardStmt(tok) {
    Node.call(this);

    this.token = tok;
    this.semi = null;
}

DiscardStmt.prototype = Node.create('DiscardStmt', DiscardStmt);
exports.DiscardStmt = DiscardStmt;

DiscardStmt.prototype.location = function() {
    return glsl.source.Range.spans(this.token, this.semi);
};


function AssignmentExpr(lexpr) {
    Node.call(this);

    this.lhs = lexpr;
    this.op = null;
    this.rhs = null;
}

AssignmentExpr.prototype = Node.create('AssignmentExpr', AssignmentExpr);
exports.AssignmentExpr = AssignmentExpr;

AssignmentExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.lhs, this.op, this.rhs);
};

function TernaryExpr(condition) {
    Node.call(this);

    this.condition = condition;
    this.questionToken = null;
    this.trueExpression = null;
    this.colonToken = null;
    this.falseExpression = null;
}

TernaryExpr.prototype = Node.create('TernaryExpr', TernaryExpr);
exports.TernaryExpr = TernaryExpr;

TernaryExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.condition,
                                   this.questionToken,
                                   this.trueExpression,
                                   this.colonToken,
                                   this.falseExpression);
};

function BinOpExpr(lhs, op, rhs) {
    Node.call(this);

    this.lhs = lhs;
    this.op = op;
    this.rhs = rhs;
}

BinOpExpr.prototype = Node.create('BinOpExpr', BinOpExpr);
exports.BinOpExpr = BinOpExpr;

BinOpExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.lhs, this.op, this.rhs);
};


function UnaryOpExpr(op, rhs) {
    Node.call(this);

    this.op = op;
    this.expression = rhs;
}

UnaryOpExpr.prototype = Node.create('UnaryOpExpr', UnaryOpExpr);
exports.UnaryOpExpr = UnaryOpExpr;

UnaryOpExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.op, this.expression);
};


function UnaryPostfixOpExpr(op, rhs) {
    Node.call(this);

    this.op = op;
    this.expression = rhs;
}

UnaryPostfixOpExpr.prototype = Node.create('UnaryPostfixOpExpr', UnaryPostfixOpExpr);
exports.UnaryPostfixOpExpr = UnaryPostfixOpExpr;

UnaryPostfixOpExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.op, this.expression);
};


function ConstantExpr(token) {
    Node.call(this);

    this.token = token;
}

ConstantExpr.prototype = Node.create('ConstantExpr', ConstantExpr);
exports.ConstantExpr = ConstantExpr;

ConstantExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.token);
};


function GroupExpr() {
    Node.call(this);

    this.leftParen = null;
    this.expression = null;
    this.rightParen = null;
}

GroupExpr.prototype = Node.create('GroupExpr', GroupExpr);
exports.GroupExpr = GroupExpr;

GroupExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.leftParen, this.expression, this.rightParen);
};


function VariableExpr(name) {
    Node.call(this);

    this.name = name;
}

VariableExpr.prototype = Node.create('VariableExpr', VariableExpr);
exports.VariableExpr = VariableExpr;

VariableExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.name);
};


function FunctionCallExpr(name) {
    Node.call(this);

    this.name = name;
    this.leftParen = null;
    this.rightParen = null;
    this.arguments = [];
}

FunctionCallExpr.prototype = Node.create('FunctionCallExpr', FunctionCallExpr);
exports.FunctionCallExpr = FunctionCallExpr;

FunctionCallExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.name, this.leftParen, this.rightParen, this.arguments);
};


function FieldSelectionExpr(expr, op) {
    Node.call(this);

    this.expression = expr;
    this.op = op;

    this.selector = null;
}

FieldSelectionExpr.prototype = Node.create('FieldSelectionExpr', FieldSelectionExpr);
exports.FieldSelectionExpr = FieldSelectionExpr;

FieldSelectionExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.expression, this.op, this.selector);
};


function IndexExpr(expr) {
    Node.call(this);

    this.expression = expr;

    this.rightBracket = null;
    this.index = null;
    this.leftBracket = null;
}

IndexExpr.prototype = Node.create('IndexExpr', IndexExpr);
exports.IndexExpr = IndexExpr;

IndexExpr.prototype.location = function() {
    return glsl.source.Range.spans(this.expression, this.rightBracket, this.index, this.leftBracket);
};


function NoMatch(tok) {
    Node.call(this);

    this.token = tok;
}

NoMatch.prototype = Node.create('NoMatch', NoMatch);
exports.NoMatch = NoMatch;

NoMatch.prototype.location = function() {
    return glsl.source.Range.spans(this.token);
};


function Parser(source, type, options) {
    Node.call(this);

    if (typeof options === 'undefined') {
        options = {};
    }

    if (typeof options.preprocessor === 'undefined') {
        options.preprocessor = {};
    }

    this._preprocessor = new glsl.preprocessor.Preprocessor(source, type, options.preprocessor);
    this._t = new Tn(this._preprocessor);

    this._errors = [];

    this.type = type;
    this.body = [];

    this.comments = [];

    this._parseTu();
    this.complete();
}

Parser.prototype = Node.create('Parser', Parser);

Parser.prototype.marshal = function(ctx) {
    var ret = Node.prototype.marshal.call(this, ctx);

    if (this._errors.length !== 0) {
        ret.errors = this._marshalArray(this._errors, ctx);
    }

    return ret;
};

Parser.prototype._requireOneOfError = function(ids, tok) {
    var loc;
    var got;

    if (tok.id == Tn.T_EOF) {
        loc = this._t.location().toRange();
        got = 'nothing';
    } else {
        loc = tok.location;
        got = this._t.tokenName(tok.id);
    }

    var choices = [];

    for (var i = 0; i < ids.length; i++) {
        choices.push(this._t.tokenName(ids[i]));
    }

    if (choices.length > 1) {
        choices = choices.slice(0, choices.length - 1).join(', ') + ' or ' + choices[choices.length - 1];

        this._error(loc, 'expected one of ' + choices + ', but got ' + got);
    } else {
        this._error(loc, 'expected ' + choices[0] + ', but got ' + got);
    }

    this._t.unconsume(tok);
    return null;
};

Parser.prototype._requireOneOf = function(ids) {
    var tok = this._t.next();

    for (var i = 0; i < ids.length; i++) {
        if (tok.id == ids[i]) {
            return tok;
        }
    }

    return this._requireOneOfError(ids, tok);
};

Parser.prototype._matchOneOf = function(matchers, tok) {
    var retf = function(m, tok) {
        return m.call(this, tok, ret);
    };

    for (var i = 0; i < matchers.length; i++) {
        var m = matchers[i];

        var ret = this._match(m, tok);

        if (ret) {
            return retf.bind(this, m);
        }
    }

    return false;
};

function matchOneOf(f, oneof) {
    for (var i = 0; i < oneof.length; i++) {
        var m = oneof[i];

        if (typeof m == 'undefined') {
            throw new Error(['undefined rule for', f]);
        }

        if (typeof m.expected == 'undefined') {
            throw new Error(['undefined .expected for ', f, m]);
        }
    }

    f.match = function(tok) {
        return this._matchOneOf(oneof, tok);
    };

    f.expected = function() {
        var ret = [];

        for (var i = 0; i < oneof.length; i++) {
            ret = ret.concat(oneof[i].expected.call(this));
        }

        return ret;
    };
}

Parser.prototype._parseBinopExpression = function(tok, m, expr, opid, rule) {
    var ret;

    if (rule == this._parseUnaryExpression && typeof expr != 'undefined') {
        ret = expr;
    } else {
        ret = rule.call(this, tok, m, expr);
    }

    if (ret.incomplete) {
        return ret;
    }

    tok = this._t.peek();

    while (opid(tok.id)) {
        var op = tok;

        // consume peeked token
        this._t.next();

        var rhs = this._parseRule(rule, this._t.next());

        ret = new BinOpExpr(ret, op, rhs);

        if (rhs.incomplete) {
            return ret;
        }

        ret.complete();
        tok = this._t.peek();
    }

    return ret;
};

Parser.prototype._parseFunctionCall = function(tok) {
    var cl = new FunctionCallExpr(tok);

    cl.leftParen = this._requireOneOf([Tn.T_LEFT_PAREN]);

    if (cl.leftParen === null) {
        return cl;
    }

    var n = this._t.peek();

    if (this._match(this._parseAssignmentExpression, n)) {
        while (true) {
            var ret = this._parseRule(this._parseAssignmentExpression, this._t.next());

            cl.arguments.push(ret);

            if (ret.incomplete) {
                return cl;
            }

            n = this._t.peek();

            if (n.id != Tn.T_COMMA) {
                break;
            }

            // consume comma
            this._t.next();
        }
    } else if (n.id == Tn.T_VOID) {
        // consume peeked token
        cl.arguments = [this._t.next()];
    }

    cl.rightParen = this._requireOneOf([Tn.T_RIGHT_PAREN]);

    if (cl.rightParen === null) {
        return cl;
    }

    return cl.complete();
};

Parser.prototype._parseFunctionIdentifier = function(tok) {
    return (new Named(tok, null)).complete();
};

Parser.prototype._isPrimitiveType = function(id) {
    switch (id) {
    case Tn.T_FLOAT:
    case Tn.T_INT:
    case Tn.T_BOOL:
    case Tn.T_VEC2:
    case Tn.T_VEC3:
    case Tn.T_VEC4:
    case Tn.T_BVEC2:
    case Tn.T_BVEC3:
    case Tn.T_BVEC4:
    case Tn.T_IVEC2:
    case Tn.T_IVEC3:
    case Tn.T_IVEC4:
    case Tn.T_MAT2:
    case Tn.T_MAT3:
    case Tn.T_MAT4:
    case Tn.T_SAMPLER2D:
    case Tn.T_SAMPLERCUBE:
        return true;
    }

    return false;
};

Parser.prototype._parseFunctionIdentifier.match = function(tok) {
    return this._isPrimitiveType(tok.id) || tok.id == Tn.T_IDENTIFIER;
};

Parser.prototype._parsePrimaryExpression = function(tok) {
    if (this._parseFunctionIdentifier.match.call(this, tok)) {
        var n = this._t.peek();

        if (n.id == Tn.T_LEFT_PAREN) {
            return this._parseFunctionCall(tok);
        }

        return (new VariableExpr(tok)).complete();
    }

    switch (tok.id) {
    case Tn.T_INTCONSTANT:
    case Tn.T_FLOATCONSTANT:
    case Tn.T_BOOLCONSTANT:
        return (new ConstantExpr(tok)).complete();
    case Tn.T_LEFT_PAREN:
        var grp = new GroupExpr();

        grp.leftParen = tok;
        grp.expression = this._parseRule(this._parseExpression, this._t.next());

        if (grp.expression.incomplete) {
            return grp;
        }

        grp.rightParen = this._requireOneOf([Tn.T_RIGHT_PAREN]);

        if (grp.rightParen === null) {
            return grp;
        }

        return grp.complete();
    }

    return new NoMatch(tok);
};

Parser.prototype._parsePrimaryExpression.match = function(tok) {
    switch (tok.id) {
    case Tn.T_INTCONSTANT:
    case Tn.T_FLOATCONSTANT:
    case Tn.T_BOOLCONSTANT:
    case Tn.T_LEFT_PAREN:
        return true;
    }

    return this._match(this._parseFunctionIdentifier, tok);
};

Parser.prototype._parsePrimaryExpression.expected = function() {
    return ['identifier', 'integer', 'float', 'bool', 'grouped expression'];
};

Parser.prototype._parsePostfixExpression = function(tok, m) {
    var expr = this._parsePrimaryExpression(tok, m);

    if (expr.incomplete) {
        return expr;
    }

    tok = this._t.peek();

    while (tok.id != Tn.T_EOF) {
        switch (tok.id) {
        case Tn.T_LEFT_BRACKET:
            // consume peeked token
            this._t.next();

            expr = new IndexExpr(expr);
            expr.leftBracket = tok;

            expr.index = this._parseRule(this._parseExpression, this._t.next());

            if (expr.index.incomplete) {
                break;
            }

            expr.rightBracket = this._requireOneOf([Tn.T_RIGHT_BRACKET]);

            if (expr.rightBracket === null) {
                break;
            }

            expr.complete();
            break;
        case Tn.T_DOT:
            // consume peeked token
            this._t.next();

            expr = new FieldSelectionExpr(expr, tok);

            expr.selector = this._requireOneOf([Tn.T_IDENTIFIER]);

            if (expr.selector === null) {
                break;
            }

            expr.complete();
            break;
        case Tn.T_INC_OP:
        case Tn.T_DEC_OP:
            // consume peeked token
            this._t.next();

            expr = (new UnaryPostfixOpExpr(tok, expr)).complete();
            break;
        default:
            tok = null;
            break;
        }

        if (tok === null) {
            break;
        }

        tok = this._t.peek();
    }

    return expr;
};

Parser.prototype._parsePostfixExpression.match = Parser.prototype._parsePrimaryExpression.match;

Parser.prototype._parsePostfixExpression.expected = Parser.prototype._parsePrimaryExpression.expected;

Parser.prototype._parseUnaryExpression = function(tok, m) {
    switch (tok.id) {
    case Tn.T_INC_OP:
    case Tn.T_DEC_OP:
    case Tn.T_PLUS:
    case Tn.T_DASH:
    case Tn.T_BANG:
    case Tn.T_TILDE:
        var expr = this._parseRule(this._parseUnaryExpression, this._t.next());
        var ret = new UnaryOpExpr(tok, expr);

        if (!expr.incomplete) {
            ret.complete();
        }

        return ret;
    }

    return this._parsePostfixExpression(tok, m);
};

Parser.prototype._parseUnaryExpression.match = function(tok) {
    switch (tok.id) {
    case Tn.T_INC_OP:
    case Tn.T_DEC_OP:
    case Tn.T_PLUS:
    case Tn.T_DASH:
    case Tn.T_BANG:
    case Tn.T_TILDE:
        return true;
    }

    return this._match(this._parsePostfixExpression, tok);
};

Parser.prototype._parseUnaryExpression.expected = function() {
    return ['unary operator'].concat(this._parsePostfixExpression.expected.call(this));
};

Parser.prototype._parseMultiplicativeExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_STAR ||
                                                               id == Tn.T_SLASH ||
                                                               id == Tn.T_PERCENT; },
                                        this._parseUnaryExpression);
};

Parser.prototype._parseMultiplicativeExpression.match = Parser.prototype._parseUnaryExpression.match;

Parser.prototype._parseMultiplicativeExpression.expected = Parser.prototype._parseUnaryExpression.expected;


Parser.prototype._parseAdditiveExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_PLUS ||
                                                               id == Tn.T_DASH; },
                                        this._parseMultiplicativeExpression);
};

Parser.prototype._parseAdditiveExpression.match = Parser.prototype._parseMultiplicativeExpression.match;

Parser.prototype._parseAdditiveExpression.expected = Parser.prototype._parseMultiplicativeExpression.expected;


Parser.prototype._parseShiftExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_LEFT_OP ||
                                                               id == Tn.T_RIGHT_OP; },
                                        this._parseAdditiveExpression);
};

Parser.prototype._parseShiftExpression.match = Parser.prototype._parseAdditiveExpression.match;

Parser.prototype._parseShiftExpression.expected = Parser.prototype._parseAdditiveExpression.expected;


Parser.prototype._parseRelationalExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_LEFT_ANGLE ||
                                                               id == Tn.T_RIGHT_ANGLE ||
                                                               id == Tn.T_LE_OP ||
                                                               id == Tn.T_GE_OP; },
                                        this._parseShiftExpression);
};

Parser.prototype._parseRelationalExpression.match = Parser.prototype._parseShiftExpression.match;

Parser.prototype._parseRelationalExpression.expected = Parser.prototype._parseShiftExpression.expected;


Parser.prototype._parseEqualityExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_EQ_OP || id == Tn.T_NE_OP; },
                                        this._parseRelationalExpression);
};

Parser.prototype._parseEqualityExpression.match = Parser.prototype._parseRelationalExpression.match;

Parser.prototype._parseEqualityExpression.expected = Parser.prototype._parseRelationalExpression.expected;

Parser.prototype._parseAndExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_AMPERSAND; },
                                        this._parseEqualityExpression);
};


Parser.prototype._parseAndExpression.match = Parser.prototype._parseEqualityExpression.match;

Parser.prototype._parseAndExpression.expected = Parser.prototype._parseEqualityExpression.expected;


Parser.prototype._parseExclusiveOrExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function(id) { return id == Tn.T_CARET; },
                                        this._parseAndExpression);
};

Parser.prototype._parseExclusiveOrExpression.match = Parser.prototype._parseAndExpression.match;

Parser.prototype._parseExclusiveOrExpression.expected = Parser.prototype._parseAndExpression.expected;


Parser.prototype._parseInclusiveOrExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function(id) { return id == Tn.T_VERTICAL_BAR; },
                                        this._parseExclusiveOrExpression);
};

Parser.prototype._parseInclusiveOrExpression.match = Parser.prototype._parseExclusiveOrExpression.match;

Parser.prototype._parseInclusiveOrExpression.expected = Parser.prototype._parseExclusiveOrExpression.expected;

Parser.prototype._parseLogicalAndExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_AND_OP; },
                                        this._parseInclusiveOrExpression);
};

Parser.prototype._parseLogicalAndExpression.match = Parser.prototype._parseInclusiveOrExpression.match;

Parser.prototype._parseLogicalAndExpression.expected = Parser.prototype._parseInclusiveOrExpression.expected;

Parser.prototype._parseLogicalXorExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_XOR_OP; },
                                        this._parseLogicalAndExpression);
};

Parser.prototype._parseLogicalXorExpression.match = Parser.prototype._parseLogicalAndExpression.match;

Parser.prototype._parseLogicalXorExpression.expected = Parser.prototype._parseLogicalAndExpression.expected;

Parser.prototype._parseLogicalOrExpression = function(tok, m, expr) {
    return this._parseBinopExpression(tok,
                                        m,
                                        expr,
                                        function (id) { return id == Tn.T_OR_OP; },
                                        this._parseLogicalXorExpression);
};

Parser.prototype._parseLogicalOrExpression.match = Parser.prototype._parseLogicalXorExpression.match;

Parser.prototype._parseLogicalOrExpression.expected = Parser.prototype._parseLogicalXorExpression.expected;

Parser.prototype._parseUnaryConditionalExpressionRest = function(expr) {
    if (expr.incomplete) {
        return expr;
    }

    var n = this._t.peek();

    if (n.id == Tn.T_QUESTION) {
        var ret = new TernaryExpr(expr);
        ret.questionToken = this._t.next();

        ret.trueExpression = this._parseRule(this._parseExpression, this._t.next());

        if (ret.trueExpression.incomplete) {
            return ret;
        }

        ret.colonToken = this._requireOneOf([Tn.T_COLON]);

        if (ret.colonToken === null) {
            return ret;
        }

        ret.falseExpression = this._parseRule(this._parseAssignmentExpression, this._t.next());

        if (ret.falseExpression.incomplete) {
            return ret;
        }

        return ret.complete();
    }

    return expr;
};

Parser.prototype._parseUnaryConditionalExpression = function(expr) {
    var tok, m;

    var expr = this._parseLogicalOrExpression(tok, m, expr);
    return this._parseUnaryConditionalExpressionRest(expr);
};

Parser.prototype._parseConditionalExpression = function(tok, m) {
    var expr = this._parseLogicalOrExpression(tok, m);
    return this._parseUnaryConditionalExpressionRest(expr);
};

Parser.prototype._parseConditionalExpression.match = Parser.prototype._parseLogicalOrExpression.match;

Parser.prototype._parseConditionalExpression.expected = Parser.prototype._parseLogicalOrExpression.expected;

Parser.prototype._parseAssignmentOperator = function(tok) {
    return {token: tok, incomplete: false};
};

Parser.prototype._parseAssignmentOperator.match = function(tok) {
    switch (tok.id) {
    case Tn.T_EQUAL:
    case Tn.T_MUL_ASSIGN:
    case Tn.T_DIV_ASSIGN:
    case Tn.T_MOD_ASSIGN:
    case Tn.T_ADD_ASSIGN:
    case Tn.T_SUB_ASSIGN:
    case Tn.T_LEFT_ASSIGN:
    case Tn.T_RIGHT_ASSIGN:
    case Tn.T_AND_ASSIGN:
    case Tn.T_XOR_ASSIGN:
    case Tn.T_OR_ASSIGN:
        return true;
    }

    return false;
};

Parser.prototype._parseAssignmentOperator.expected = function() {
    return ['assignment operator'];
};

Parser.prototype._parseUnaryAssignmentExpression = function(expr) {
    var ret = new AssignmentExpr(expr);
    var op = this._parseRule(this._parseAssignmentOperator, this._t.next());

    if (op.incomplete) {
        return ret;
    }

    ret.op = op.token;

    ret.rhs = this._parseRule(this._parseAssignmentExpression, this._t.next());

    if (!ret.rhs.incomplete) {
        ret.complete();
    }

    return ret;
};

Parser.prototype._parseUnaryAssignmentExpression.match = Parser.prototype._parseUnaryExpression.match;

Parser.prototype._parseUnaryAssignmentExpression.expected = Parser.prototype._parseUnaryExpression.expected;

Parser.prototype._parseAssignmentExpression = function(tok, m) {
    var expr = this._parseUnaryExpression(tok, m);

    if (expr.incomplete) {
        return expr;
    }

    var n = this._t.peek();
    var m = this._match(this._parseAssignmentOperator, n);

    if (m) {
        return this._parseUnaryAssignmentExpression(expr);
    } else {
        return this._parseUnaryConditionalExpression(expr);
    }
};

Parser.prototype._parseAssignmentExpression.match = Parser.prototype._parseUnaryExpression.match;

Parser.prototype._parseAssignmentExpression.expected = Parser.prototype._parseUnaryExpression.expected;

Parser.prototype._parseExpression = function(tok, m) {
    var expr = this._parseAssignmentExpression(tok, m);

    if (expr.incomplete) {
        return expr;
    }

    tok = this._t.peek();

    if (tok.id != Tn.T_COMMA) {
        return expr;
    }

    var ret = new ExpressionListStmt();
    ret.expressions.push(expr);

    while (tok.id == Tn.T_COMMA) {
        // consume peeked comma
        this._t.next();

        tok = this._t.next();

        expr = this._parseAssignmentExpression(tok, m);
        ret.expressions.push(expr);

        if (expr.incomplete) {
            return expr;
        }

        tok = this._t.peek();
    }

    return ret.complete();
};

Parser.prototype._parseExpression.match = Parser.prototype._parseAssignmentExpression.match;
Parser.prototype._parseExpression.expected = Parser.prototype._parseAssignmentExpression.expected;

Parser.prototype._parseConstantExpression = Parser.prototype._parseConditionalExpression;
Parser.prototype._parseConstantExpression.match = Parser.prototype._parseConditionalExpression.match;
Parser.prototype._parseConstantExpression.expected = Parser.prototype._parseConditionalExpression.expected;

Parser.prototype._parseFieldDeclarationName = function(tok) {
    var name = tok;

    var ret = new Named(name, null);
    ret.complete();

    this._parseOptionalArraySpec(ret);

    return ret;
};

Parser.prototype._parseFieldDeclarationName.match = function(tok) {
    return tok.id == Tn.T_IDENTIFIER;
};

Parser.prototype._parseFieldDeclarationName.expected = function() {
    return ['field name'];
};

Parser.prototype._parseFieldDeclaration = function(tok, m) {
    var type = m(tok);
    var sdecl = new FieldDecl(type);

    if (type.incomplete) {
        return sdecl;
    }

    tok = this._t.next();
    var first = true;

    while (tok.id != Tn.T_EOF && tok.id != Tn.T_SEMICOLON) {
        if (!first) {
            if (tok.id != Tn.T_COMMA) {
                this._requireOneOfError([Tn.T_COMMA], tok);
                return sdecl;
            }

            tok = this._t.next();
        } else {
            first = false;
        }

        var fname = this._parseRule(this._parseFieldDeclarationName, tok);

        fname.decl = sdecl;
        fname.type = type;

        sdecl.names.push(fname);

        if (fname.incomplete) {
            return sdecl;
        }

        tok = this._t.next();
    }

    if (tok.id != Tn.T_SEMICOLON) {
        this._requireOneOfError([Tn.T_SEMICOLON], tok);
        return sdecl;
    }

    sdecl.semi = tok;
    return sdecl.complete();
};

Parser.prototype._parseStructSpecifier = function(tok) {
    var lb = this._t.next();

    var sdl = new StructDecl(tok);

    if (lb.id != Tn.T_IDENTIFIER && lb.id != Tn.T_LEFT_BRACE ) {
        this._requireOneOfError([Tn.T_IDENTIFIER, Tn.T_LEFT_BRACE], lb);
        return sdl;
    }

    var name = null;

    if (lb.id == Tn.T_IDENTIFIER) {
        name = lb;
        lb = this._t.next();
    }

    sdl.name = name;

    if (lb.id != Tn.T_LEFT_BRACE) {
        this._requireOneOfError([Tn.T_LEFT_BRACE], lb);
        return sdl;
    }

    sdl.leftBrace = lb;

    tok = this._t.next();

    while (tok.id != Tn.T_EOF && tok.id != Tn.T_RIGHT_BRACE) {
        var decl = this._parseRule(this._parseFieldDeclaration, tok);

        if (!NoMatch.prototype.isPrototypeOf(decl)) {
            sdl.fields.push(decl);
        }

        if (decl.incomplete) {
            return sdl;
        }

        tok = this._t.next();
    }

    if (tok.id != Tn.T_RIGHT_BRACE) {
        this._requireOneOfError([Tn.T_RIGHT_BRACE], tok);
        return sdl;
    }

    sdl.rightBrace = tok;
    return sdl.complete();
};

Parser.prototype._parseStructSpecifier.match = function(tok) {
    return tok.id == Tn.T_STRUCT;
};

Parser.prototype._parseTypeSpecifierNoPrecImpl = function(tok) {
    return (new TypeRef(tok)).complete();
};

Parser.prototype._parseTypeSpecifierNoPrec = function(tok, m) {
    return m(tok);
};

Parser.prototype._parseTypeSpecifierNoPrec.match = function(tok) {
    switch (tok.id) {
    case Tn.T_VOID:
    case Tn.T_FLOAT:
    case Tn.T_INT:
    case Tn.T_BOOL:
    case Tn.T_VEC2:
    case Tn.T_VEC3:
    case Tn.T_VEC4:
    case Tn.T_BVEC2:
    case Tn.T_BVEC3:
    case Tn.T_BVEC4:
    case Tn.T_IVEC2:
    case Tn.T_IVEC3:
    case Tn.T_IVEC4:
    case Tn.T_MAT2:
    case Tn.T_MAT3:
    case Tn.T_MAT4:
    case Tn.T_SAMPLER2D:
    case Tn.T_SAMPLERCUBE:
    case Tn.T_IDENTIFIER:
        return this._parseTypeSpecifierNoPrecImpl;
    }

    if (this._match(this._parseStructSpecifier, tok)) {
        return this._parseStructSpecifier.bind(this);
    }
};

Parser.prototype._parseTypeSpecifierNoPrec.expected = function() {
    return ['builtin type', 'user type identifier'];
};

Parser.prototype._parseTypeSpecifier = function(tok, m) {
    return m(tok);
};

Parser.prototype._parsePrecisionQualifier = function(tok) {
    return tok;
};

Parser.prototype._parsePrecisionQualifier.match = function(tok) {
    switch (tok.id) {
    case Tn.T_HIGH_PRECISION:
    case Tn.T_MEDIUM_PRECISION:
    case Tn.T_LOW_PRECISION:
        return true;
    }

    return false;
};

Parser.prototype._parsePrecisionQualifier.expected = function() {
    return ['highp', 'mediump', 'lowp'];
};

Parser.prototype._parseTypePrecisionQualifier = function(tok) {
    var type = this._parseRule(this._parseTypeSpecifierNoPrec, this._t.next());

    type = TypeRef.wrapDecl(type);

    type.qualifiers.unshift(tok);
    return type;
};

Parser.prototype._parseTypePrecisionQualifier.match = Parser.prototype._parsePrecisionQualifier.match;

Parser.prototype._parseTypePrecisionQualifier.expected = Parser.prototype._parsePrecisionQualifier.expected;

matchOneOf(Parser.prototype._parseTypeSpecifier, [
    Parser.prototype._parseTypeSpecifierNoPrec,
    Parser.prototype._parseTypePrecisionQualifier
]);

Parser.prototype._parseFieldDeclaration.match = Parser.prototype._parseTypeSpecifier.match;
Parser.prototype._parseFieldDeclaration.expected = Parser.prototype._parseTypeSpecifier.expected;

Parser.prototype._parseTypeQualifier = function(tok) {
    var node;

    if (tok.id == Tn.T_INVARIANT) {
        var varying = this._requireOneOf([Tn.T_VARYING]);

        if (varying === null) {
            // Should have been followed by varying (invariant IDENT is handled elsewhere).
            // Create empty, incomplete TypeRef.
            node = new TypeRef(null);
        } else {
            node = this._parseRule(this._parseTypeSpecifier, this._t.next());
        }

        node.qualifiers.unshift(varying);
    } else {
        node = this._parseRule(this._parseTypeSpecifier, this._t.next());
        node = TypeRef.wrapDecl(node);
    }

    if (node) {
        node.qualifiers.unshift(tok);
    }

    return node;
};

Parser.prototype._parseTypeQualifier.match = function(tok) {
    switch (tok.id) {
    case Tn.T_CONST:
    case Tn.T_ATTRIBUTE:
    case Tn.T_VARYING:
    case Tn.T_INVARIANT:
    case Tn.T_UNIFORM:
        return true;
    }
};

Parser.prototype._parseTypeQualifier.expected = function() {
    return ['const', 'attribute', 'varying', 'invariant', 'uniform'];
};

Parser.prototype._parseFullySpecifiedType = function(tok, m) {
    return m(tok);
};

matchOneOf(Parser.prototype._parseFullySpecifiedType, [
    Parser.prototype._parseTypeSpecifier,
    Parser.prototype._parseTypeQualifier
]);

Parser.prototype._parseOptionalArraySpec = function(ret) {
   var tok = this._t.peek();

    if (tok.id == Tn.T_LEFT_BRACKET) {
        ret.isArray = true;
        ret.leftBracket = tok;

        // consume peeked token
        this._t.next();

        ret.arraySize = this._parseRule(this._parseConstantExpression, this._t.next());

        if (ret.arraySize.incomplete) {
            ret.incomplete = true;
            return true;
        }

        ret.rightBracket = this._requireOneOf([Tn.T_RIGHT_BRACKET]);

        if (ret.rightBracket === null) {
            ret.incomplete = true;
            return true;
        }

        return true;
    } else {
        return false;
    }
};

Parser.prototype._parseParameterDeclarator = function(tok, m) {
    var type = this._parseTypeSpecifier(tok, m);

    var pdecl = new ParamDecl();
    pdecl.type = type;

    if (type.incomplete) {
        return pdecl;
    }

    tok = this._t.peek();

    if (tok.id == Tn.T_IDENTIFIER) {
        pdecl.name = this._t.next();
    }

    pdecl.complete();
    this._parseOptionalArraySpec(pdecl);

    return pdecl;
};

Parser.prototype._parseParameterDeclarator.match = Parser.prototype._parseTypeSpecifier.match;
Parser.prototype._parseParameterDeclarator.expected = Parser.prototype._parseTypeSpecifier.expected;

Parser.prototype._parseParameterQualifier = function(tok) {
    var ret = this._parseRule(this._parseParameterDeclarator, this._t.next());
    ret.qualifier = tok;

    return ret;
};

Parser.prototype._parseParameterQualifier.match = function(tok) {
    switch (tok.id) {
    case Tn.T_IN:
    case Tn.T_OUT:
    case Tn.T_INOUT:
        return true;
    }

    return false;
};

Parser.prototype._parseParameterQualifier.expected = function() {
    return ['in', 'out', 'inout'];
};

Parser.prototype._parseParameterTypeQualifier = function(tok, m) {
    var q = tok;

    tok = this._t.next();

    m = this._match(this._parseParameterQualifier, tok);

    var decl;

    if (m) {
        decl = this._parseParameterQualifier(tok, m);
    } else {
        decl = this._parseRule(this._parseParameterDeclarator, tok);
    }

    decl.qualifier = q;
    return decl;
};

Parser.prototype._parseParameterTypeQualifier.match = function (tok) {
    return tok.id == Tn.T_CONST;
};

Parser.prototype._parseParameterTypeQualifier.expected = function() {
    return ["const"];
};

Parser.prototype._parseParameterDeclaration = function(tok, m) {
    return m(tok);
};

matchOneOf(Parser.prototype._parseParameterDeclaration, [
    Parser.prototype._parseParameterTypeQualifier,
    Parser.prototype._parseParameterQualifier,
    Parser.prototype._parseParameterDeclarator
]);

Parser.prototype._parseFunctionHeader = function(type, name) {
    var func = new FunctionHeader(type, name);
    func.leftParen = this._requireOneOf([Tn.T_LEFT_PAREN]);

    if (func.leftParen === null) {
        return false;
    }

    var tok = this._t.next();
    var first = true;

    while (tok.id != Tn.T_EOF && tok.id != Tn.T_RIGHT_PAREN) {
        if (!first) {
            if (tok.id != Tn.T_COMMA) {
                this._requireOneOfError([Tn.T_COMMA], tok);
                return func;
            }

            tok = this._t.next();
        } else {
            first = false;
        }

        var m = this._parseRule(this._parseParameterDeclaration, tok);
        func.parameters.push(m);

        if (m.incomplete) {
            return func;
        }

        tok = this._t.next();
    }

    if (tok.id != Tn.T_RIGHT_PAREN) {
        this._requireOneOfError([Tn.T_RIGHT_PAREN], tok);
        return func;
    }

    func.rightParen = tok;
    return func.complete();
};

Parser.prototype._syncStatement = function(tok) {
    if (this._isPrimitiveType(tok.id)) {
        return SYNC_OK;
    }

    switch (tok.id) {
    case Tn.T_SEMICOLON:
        return SYNC_OK_CONSUME;
    case Tn.T_PRECISION:
    case Tn.T_ATTRIBUTE:
    case Tn.T_CONST:
    case Tn.T_UNIFORM:
    case Tn.T_VARYING:
    case Tn.T_STRUCT:
    case Tn.T_HIGH_PRECISION:
    case Tn.T_MEDIUM_PRECISION:
    case Tn.T_LOW_PRECISION:
    case Tn.T_PRECISION:
    case Tn.T_RIGHT_BRACE:
    case Tn.T_FOR:
    case Tn.T_DO:
    case Tn.T_WHILE:
    case Tn.T_IF:
    case Tn.T_RETURN:
    case Tn.T_DISCARD:
    case Tn.T_CONTINUE:
    case Tn.T_BREAK:
        return SYNC_OK;
    }

    return SYNC_FAIL;
};

Parser.prototype._parseFunctionDefinition = function(header, lb) {
    var func = new FunctionDef(header);

    if (header.incomplete) {
        return func;
    }

    func.body = new Block();
    func.body.leftBrace = lb;

    var tok = this._t.next();

    while (tok.id != Tn.T_EOF && tok.id != Tn.T_RIGHT_BRACE) {
        var ret = this._parseRule(this._parseStatementNoNewScope, tok);
        func.body.body.push(ret);

        if (ret.incomplete) {
            this._sync(this._syncStatement);
        }

        tok = this._t.next();
    }

    if (tok.id != Tn.T_RIGHT_BRACE) {
        this._requireOneOfError([Tn.T_RIGHT_BRACE], tok);
        return func;
    }

    func.body.rightBrace = tok;
    func.body.complete();

    return func.complete();
};

Parser.prototype._parseFunctionPrototypeOrDefinition = function(type, ident) {
    var ret = this._parseFunctionHeader(type, ident);

    if (ret.incomplete) {
        // return most likely incomplete function definition
        return new FunctionDef(ret);
    }

    var n = this._requireOneOf([Tn.T_SEMICOLON, Tn.T_LEFT_BRACE]);

    if (n === null) {
        // return most likely incomplete function definition
        return new FunctionDef(ret);
    }

    if (n.id == Tn.T_SEMICOLON) {
        var proto = new FunctionProto(ret);

        proto.semi = n;
        return proto.complete();
    } else {
        return this._parseFunctionDefinition(ret, n);
    }
};

Parser.prototype._parseStatementWithScope = function(tok, m) {
    return m(tok);
};

Parser.prototype._parseSelectionRestStatement = function(tok, m) {
    var stmt = this._parseStatementWithScope(tok, m);

    var ret = {body: stmt, els: null, incomplete: true};

    if (stmt.incomplete) {
        return ret;
    }

    var n = this._t.peek();

    if (n.id == Tn.T_ELSE) {
        var selelse = new SelectionElseStmt(n);
        ret.els = selelse;

        // consume peeked token
        this._t.next();

        selelse.body = this._parseRule(this._parseStatementWithScope, this._t.next());

        if (!selelse.body.incomplete) {
            selelse.complete();
            ret.incomplete = false;
        }
    } else {
        ret.incomplete = false;
    }

    return ret;
};

Parser.prototype._parseSelectionStatement = function(tok) {
    var sel = new SelectionStmt(tok);

    sel.leftParen = this._requireOneOf([Tn.T_LEFT_PAREN]);

    if (sel.leftParen === null) {
        return sel;
    }

    tok = this._t.next();

    sel.condition = this._parseRule(this._parseExpression, tok);

    if (sel.condition.incomplete) {
        return sel;
    }

    sel.rightParen = this._requireOneOf([Tn.T_RIGHT_PAREN]);

    if (sel.rightParen === null) {
        return sel;
    }

    tok = this._t.next();

    var ret = this._parseRule(this._parseSelectionRestStatement, tok);

    if (!NoMatch.prototype.isPrototypeOf(ret)) {
        sel.body = ret.body;
        sel.els = ret.els;
    }

    if (!ret.incomplete) {
        sel.complete();
    }

    return sel;
};

Parser.prototype._parseSelectionStatement.match = function(tok) {
    return tok.id == Tn.T_IF;
};

Parser.prototype._parseSelectionStatement.expected = function() {
    return ["if"];
};

Parser.prototype._parseConditionVarInit = function(tok, m) {
    var type = this._parseFullySpecifiedType(tok, m);

    type = TypeRef.wrapDecl(type);
    var ret = new VariableDecl(type);

    if (type.incomplete) {
        return ret;
    }

    var ident = this._requireOneOf([Tn.T_IDENTIFIER]);

    if (ident === null) {
        return ret;
    }

    var equal = this._requireOneOf([Tn.T_EQUAL]);

    if (equal === null) {
        return ret;
    }

    var named = new Named(ident, ret);
    named.type = type;
    ret.names.push(named);

    named.initialAssign = equal;

    var init = this._parseRule(this._parseInitializer, this._t.next());
    named.initialValue = init;

    if (!init.incomplete) {
        named.complete();
        ret.complete();
    }

    return ret;
};

Parser.prototype._parseConditionVarInit.match = Parser.prototype._parseFullySpecifiedType.match;
Parser.prototype._parseConditionVarInit.expected = Parser.prototype._parseFullySpecifiedType.expected;

Parser.prototype._parseCondition = function(tok, m) {
    if (tok.id == Tn.T_IDENTIFIER) {
        var n = this._t.peek();

        if (n.id == Tn.T_IDENTIFIER) {
            return this._parseConditionVarInit(tok, this._match(this._parseConditionVarInit, tok));
        } else {
            // go for the expression
            return this._parseRule(this._parseExpression, tok);
        }
    }

    // Go for whatever matched
    return m(tok);
};

matchOneOf(Parser.prototype._parseCondition, [
    Parser.prototype._parseConditionVarInit,
    Parser.prototype._parseExpression
]);

Parser.prototype._parseCondition.expected = function() {
    return ["condition expression"];
};

Parser.prototype._parseWhileStatement = function(tok) {
    var ret = new WhileStmt(tok);

    ret.leftParen = this._requireOneOf([Tn.T_LEFT_PAREN]);

    if (ret.leftParen === null) {
        return ret;
    }

    tok = this._t.next();

    ret.condition = this._parseRule(this._parseCondition, tok);

    if (ret.condition.incomplete) {
        return ret;
    }

    ret.rightParen = this._requireOneOf([Tn.T_RIGHT_PAREN]);

    if (ret.rightParen === null) {
        return ret;
    }

    ret.body = this._parseRule(this._parseStatementNoNewScope, this._t.next());

    if (!ret.body.incomplete) {
        ret.complete();
    }

    return ret;
};

Parser.prototype._parseWhileStatement.match = function(tok) {
    return tok.id == Tn.T_WHILE;
};

Parser.prototype._parseWhileStatement.expected = function() {
    return ["while"];
};

Parser.prototype._parseDoStatement = function(tok) {
    var ret = new DoStmt(tok);

    var stmt = this._parseRule(this._parseStatementWithScope, this._t.next());
    ret.body = stmt;

    if (stmt.incomplete) {
        return ret;
    }

    ret.whileToken = this._requireOneOf([Tn.T_WHILE]);

    if (ret.whileToken === null) {
        return ret;
    }

    ret.leftParen = this._requireOneOf([Tn.T_LEFT_PAREN]);

    if (ret.leftParen === null) {
        return ret;
    }

    tok = this._t.next();

    ret.condition = this._parseRule(this._parseExpression, tok);

    if (ret.condition.incomplete) {
        return ret;
    }

    ret.rightParen = this._requireOneOf([Tn.T_RIGHT_PAREN]);

    if (ret.rightParen === null) {
        return ret;
    }

    ret.semi = this._requireOneOf([Tn.T_SEMICOLON]);

    if (ret.semi === null) {
        return ret;
    }

    return ret.complete();
};

Parser.prototype._parseDoStatement.match = function(tok) {
    return tok.id == Tn.T_DO;
};

Parser.prototype._parseDoStatement.expected = function() {
    return ["do"];
};

Parser.prototype._parseDeclarationOrExpressionStatement = function(tok, m) {
    // Check for double identifier, should be a declaration
    if (tok.id == Tn.T_IDENTIFIER) {
        var n = this._t.peek();

        if (n.id == Tn.T_IDENTIFIER) {
            return this._parseDeclaration(tok, this._match(this._parseDeclaration, tok));
        } else {
            // go for the expression
            return this._parseExpressionStatement(tok, this._match(this._parseExpressionStatement, tok));
        }
    }

    // Check to see if we start with a constructor
    if (this._match(this._parseFunctionIdentifier, tok)) {
        var n = this._t.peek();

        if (n.id == Tn.T_LEFT_PAREN) {
            return this._parseRule(this._parseExpressionStatement, tok);
        }
    }

    var m = this._match(this._parseDeclaration, tok);

    if (m) {
        return this._parseDeclaration(tok, m);
    } else {
        return this._parseRule(this._parseExpressionStatement, tok);
    }
};

Parser.prototype._parseDeclarationOrExpressionStatement.match = function(tok) {
    // Either a declaration or an expression here, but we need lookahead
    var m = this._match(this._parseDeclaration, tok);

    if (!m) {
        m = this._match(this._parseExpressionStatement, tok);
    }

    return m;
};

Parser.prototype._parseDeclarationOrExpressionStatement.expected = function() {
    return ['declaration', 'expression'];
};

Parser.prototype._parseForInitStatement = function(tok, m) {
    return this._parseDeclarationOrExpressionStatement(tok, m);
};

Parser.prototype._parseForInitStatement.match = Parser.prototype._parseDeclarationOrExpressionStatement.match;

Parser.prototype._parseConditionopt = function(tok, m) {
    m = this._match(this._parseCondition, tok);

    if (!m) {
        return null;
    }

    return this._parseCondition(tok, m);
};

Parser.prototype._parseConditionopt.match = function() {
    return true;
};

Parser.prototype._parseForRestStatement = function(tok, m) {
    var copt = this._parseRule(this._parseConditionopt, tok);
    var ret = new ForRestStmt(copt);

    if (copt !== null && copt.incomplete) {
        return ret;
    }

    ret.semi = this._requireOneOf([Tn.T_SEMICOLON]);

    if (ret.semi === null) {
        return ret;
    }

    var n = this._t.peek();
    var m = this._match(this._parseExpression, n);

    if (m) {
        ret.expression = this._parseExpression(this._t.next(), m);

        if (ret.expression.incomplete) {
            return ret;
        }
    }

    return ret.complete();
};

Parser.prototype._parseForRestStatement.match = Parser.prototype._parseConditionopt.match;

Parser.prototype._parseForStatement = function(tok) {
    var ret = new ForStmt(tok);

    ret.leftParen = this._requireOneOf([Tn.T_LEFT_PAREN]);

    if (ret.leftParen === null) {
        return ret;
    }

    tok = this._t.next();

    ret.init = this._parseRule(this._parseForInitStatement, tok);

    if (ret.init.incomplete) {
        return ret;
    }

    tok = this._t.next();

    ret.rest = this._parseRule(this._parseForRestStatement, tok);

    if (ret.rest.incomplete) {
        return ret;
    }

    ret.rightParen = this._requireOneOf([Tn.T_RIGHT_PAREN]);

    if (ret.rightParen === null) {
        return ret;
    }

    ret.body = this._parseRule(this._parseStatementNoNewScope, this._t.next());

    if (ret.body.incomplete) {
        return ret;
    }

    return ret.complete();
};

Parser.prototype._parseForStatement.match = function(tok) {
    return tok.id == Tn.T_FOR;
};

Parser.prototype._parseForStatement.expected = function() {
    return ["for"];
};

Parser.prototype._parseIterationStatement = function(tok, m) {
    return m(tok);
};

matchOneOf(Parser.prototype._parseIterationStatement, [
    Parser.prototype._parseWhileStatement,
    Parser.prototype._parseDoStatement,
    Parser.prototype._parseForStatement
]);

Parser.prototype._parseJumpStatement = function(tok) {
    var ret = null;

    switch (tok.id) {
    case Tn.T_CONTINUE:
        ret = new ContinueStmt(tok);
        break;
    case Tn.T_BREAK:
        ret = new BreakStmt(tok);
        break;
    case Tn.T_RETURN:
        ret = new ReturnStmt(tok);

        var n = this._t.peek();

        if (n !== null && n.id != Tn.T_SEMICOLON) {
            ret.expression = this._parseRule(this._parseExpression, this._t.next());

            if (ret.expression.incomplete) {
                return ret;
            }
        }

        break;
    case Tn.T_DISCARD:
        ret = new DiscardStmt(tok);
        ret.semi = this._requireOneOf([Tn.T_SEMICOLON]);

        if (this.type !== glsl.source.FRAGMENT) {
            this._error(tok.location, 'invalid use of discard outside of fragment shader');
            return ret;
        }

        return ret.complete();
    }

    ret.semi = this._requireOneOf([Tn.T_SEMICOLON]);

    if (ret.semi === null) {
        return ret;
    }

    return ret.complete();
};

Parser.prototype._parseJumpStatement.match = function(tok) {
    switch (tok.id) {
    case Tn.T_CONTINUE:
    case Tn.T_BREAK:
    case Tn.T_RETURN:
    case Tn.T_DISCARD:
        return true;
    }

    return false;
};

Parser.prototype._parseJumpStatement.expected = function() {
    return ['continue', 'break', 'return', 'discard'];
};

Parser.prototype._parseSimpleStatement = function(tok, m) {
    return m(tok);
};

matchOneOf(Parser.prototype._parseSimpleStatement, [
    Parser.prototype._parseDeclarationOrExpressionStatement,
    Parser.prototype._parseSelectionStatement,
    Parser.prototype._parseIterationStatement,
    Parser.prototype._parseJumpStatement
]);

Parser.prototype._parseCompoundStatement = function(tok, newscope) {
    var block = new Block();

    block.newScope = newscope;
    block.leftBrace = tok;

    tok = this._t.next();

    while (tok.id != Tn.T_EOF && tok.id != Tn.T_RIGHT_BRACE) {
        var ret = this._parseRule(this._parseStatementNoNewScope, tok);
        block.body.push(ret);

        if (ret.incomplete) {
            return ret;
        }

        tok = this._t.next();
    }

    if (tok.id != Tn.T_RIGHT_BRACE) {
        this._requireOneOfError([Tn.T_RIGHT_BRACE], tok);
        return block;
    }

    block.rightBrace = tok;
    return block.complete();
};


Parser.prototype._parseCompoundStatementWithScope = function(tok) {
    return this._parseCompoundStatement(tok, true);
};

Parser.prototype._parseCompoundStatementWithScope.match = function(tok) {
    return tok.id == Tn.T_LEFT_BRACE;
};

Parser.prototype._parseCompoundStatementWithScope.expected = function() {
    return ['opening curly brace {'];
};

Parser.prototype._parseCompoundStatementNoNewScope = function(tok) {
    return this._parseCompoundStatement(tok, false);
};

Parser.prototype._parseCompoundStatementNoNewScope.match = function(tok) {
    return tok.id == Tn.T_LEFT_BRACE;
};

Parser.prototype._parseCompoundStatementNoNewScope.expected = function() {
    return ["opening scope brace {"];
};

Parser.prototype._parseStatementNoNewScope = function(tok, m) {
    return m(tok);
};

matchOneOf(Parser.prototype._parseStatementNoNewScope, [
    Parser.prototype._parseCompoundStatementWithScope,
    Parser.prototype._parseSimpleStatement
]);

matchOneOf(Parser.prototype._parseStatementWithScope, [
    Parser.prototype._parseCompoundStatementNoNewScope,
    Parser.prototype._parseSimpleStatement
]);

Parser.prototype._parseSelectionRestStatement.match = Parser.prototype._parseStatementWithScope.match;

Parser.prototype._parseSelectionRestStatement.expected = Parser.prototype._parseStatementWithScope.expected;

Parser.prototype._parseDeclarationPrecision = function(tok) {
    var ret = new PrecisionStmt(tok);

    ret.qualifier = this._parseRule(this._parsePrecisionQualifier, this._t.next());

    if (ret.qualifier.incomplete) {
        return ret;
    }

    ret.type = this._parseRule(this._parseTypeSpecifierNoPrec, this._t.next());

    if (ret.type.incomplete) {
        return ret;
    }

    ret.semi = this._requireOneOf([Tn.T_SEMICOLON]);

    if (ret.semi === null) {
        return ret;
    }

    return ret.complete();
};

Parser.prototype._parseInitializer = Parser.prototype._parseAssignmentExpression;
Parser.prototype._parseInitializer.match = Parser.prototype._parseAssignmentExpression.match;
Parser.prototype._parseInitializer.expected = Parser.prototype._parseAssignmentExpression.expected;

Parser.prototype._parseSingleDeclaration = function(type, ident) {
    type = TypeRef.wrapDecl(type);
    var decl = new VariableDecl(type);

    if (type.incomplete) {
        return decl;
    }

    var named = new Named(ident, decl);
    named.type = type;
    decl.names.push(named.complete());

    var n = this._t.peek();

    if (n.id == Tn.T_EOF) {
        return decl.complete();
    }

    if (n.id == Tn.T_EQUAL) {
        // consume peeked token
        this._t.next();

        named.initialAssign = n;
        named.initialValue = this._parseRule(this._parseInitializer, this._t.next());

        if (named.initialValue.incomplete) {
            named.incomplete = true;
            return decl;
        }
    } else {
        this._parseOptionalArraySpec(named);

        if (named.incomplete) {
            return decl;
        }
    }

    return decl.complete();
};

Parser.prototype._parseInitDeclaratorList = function(decl, opts) {
    if (decl.incomplete) {
        return decl;
    }

    decl.incomplete = true;

    var tok = this._t.peek();

    while (tok.id == Tn.T_COMMA) {
        // consume comma
        this._t.next();

        var ident = this._requireOneOf([Tn.T_IDENTIFIER]);

        if (ident === null) {
            return decl;
        }

        if (!opts.array && !opts.equal) {
            decl.names.push(ident);
        } else {

            var name = new Named(ident, decl);
            name.type = decl.type;

            decl.names.push(name);

            var isarray = false;

            tok = this._t.peek();

            if (opts.array) {
                name.complete();

                if (this._parseOptionalArraySpec(name)) {
                    isarray = true;
                }

                if (name.incomplete) {
                    return decl;
                }
            }

            if (!isarray && opts.equal && tok.id == Tn.T_EQUAL) {
                // consume peeked token
                this._t.next();

                name.initialValue = this._parseRule(this._parseInitializer, this._t.next());
                name.initialAssign = tok;

                if (name.initialValue.incomplete) {
                    return decl;
                }
            }

            name.complete();
        }

        tok = this._t.peek();
    }

    decl.semi = this._requireOneOf([Tn.T_SEMICOLON]);

    if (decl.semi === null) {
        return decl;
    }

    return decl.complete();
};

Parser.prototype._parseDeclaration = function(tok, m) {
    var decl = null;

    var opts = {equal: true, array: true};

    if (tok.id == Tn.T_PRECISION) {
        return this._parseDeclarationPrecision(tok);
    } else if (tok.id == Tn.T_INVARIANT) {
        var n = this._t.peek();

        if (n.id == Tn.T_IDENTIFIER) {
            decl = new InvariantDecl(tok);

            decl.names.push(this._t.next());

            opts.equal = false;
            opts.array = false;
        }
    }

    if (decl === null) {
        // First parse the fully specified type
        var type = m(tok);

        // Then, check for an identifier and open left paren to see if this
        // is a function prototype or declaration
        var ident = this._t.peek();

        if (ident.id == Tn.T_IDENTIFIER) {
            // consume peeked token
            this._t.next();

            var n = this._t.peek();

            if (n.id == Tn.T_LEFT_PAREN) {
                return this._parseFunctionPrototypeOrDefinition(type, ident);
            } else {
                decl = this._parseSingleDeclaration(type, ident);
            }
        } else {
            decl = new TypeDecl(type);

            if (!type.incomplete) {
                decl.complete();
            }
        }
    } else {
        decl.complete();
    }

    // Finish the declarator list
    return this._parseInitDeclaratorList(decl, opts);
};

Parser.prototype._parseDeclaration.match = function(tok) {
    if (tok.id == Tn.T_PRECISION) {
        return true;
    }

    return this._match(this._parseFullySpecifiedType, tok);
};

Parser.prototype._parseDeclaration.expected = function() {
    return ['function prototype', 'function definition', 'struct declaration', 'variable declaration'];
};

Parser.prototype._parseExpressionStatement = function(tok, m) {
    if (tok.id == Tn.T_SEMICOLON) {
        return (new EmptyStmt(tok)).complete();
    } else {
        var ret = this._parseExpression(tok, m);
        var stmt = new ExpressionStmt(ret);

        if (ret.incomplete) {
            return stmt;
        }

        stmt.semi = this._requireOneOf([Tn.T_SEMICOLON]);

        if (stmt.semi === null) {
            return stmt;
        }

        return stmt.complete();
    }
};

Parser.prototype._parseExpressionStatement.match = function(tok) {
    if (tok.id == Tn.T_SEMICOLON) {
        return true;
    }

    return this._match(this._parseExpression, tok);
};

Parser.prototype._parseExternalDeclaration = function(tok, m) {
    return m(tok);
};

Parser.prototype._syncDeclaration = function(tok) {
    if (this._isPrimitiveType(tok.id)) {
        return SYNC_OK;
    }

    switch (tok.id) {
    case Tn.T_SEMICOLON:
        return SYNC_OK_CONSUME;
    case Tn.T_PRECISION:
    case Tn.T_ATTRIBUTE:
    case Tn.T_CONST:
    case Tn.T_UNIFORM:
    case Tn.T_VARYING:
    case Tn.T_STRUCT:
    case Tn.T_VOID:
    case Tn.T_INVARIANT:
    case Tn.T_HIGH_PRECISION:
    case Tn.T_MEDIUM_PRECISION:
    case Tn.T_LOW_PRECISION:
    case Tn.T_PRECISION:
        return SYNC_OK;
    }

    return SYNC_FAIL;
};

Parser.prototype._sync = function(syncer) {
    var tok = this._t.peek();

    while (tok.id != Tn.T_EOF) {
        var s = syncer.call(this, tok);

        if (s == SYNC_OK) {
            return;
        } else if (s == SYNC_OK_CONSUME) {
            this._t.next();
            return;
        }

        this._t.next();
        tok = this._t.peek();
    }
};

matchOneOf(Parser.prototype._parseExternalDeclaration, [
    Parser.prototype._parseDeclaration
]);

Parser.prototype._parseTu = function() {
    while (!this._t.eof()) {
        var tok = this._t.next();

        if (tok.id == Tn.T_EOF) {
            this.comments = tok.comments;
            break;
        }

        var node = this._parseRule(this._parseExternalDeclaration, tok);
        this.body.push(node);

        if (node.incomplete) {
            this._sync(this._syncDeclaration);
        }
    }
};

Parser.prototype._error = function(loc, message) {
    this._errors.push(new Error(loc, message));
};

Parser.prototype._match = function(rule, tok) {
    return rule.match.call(this, tok);
};

Parser.prototype._parseRule = function(rule, tok) {
    if (typeof tok == 'undefined') {
        return false;
    }

    var m = this._match(rule, tok);

    if (!m) {
        var ex = rule.expected.call(this);

        if (ex.length > 1) {
            ex = '`' + ex.slice(0, ex.length - 1).join('\', `') + '\' or `' + ex[ex.length - 1] + '\'';
        } else {
            ex = '`' + ex[0] + '\'';
        }

        this._error(tok.location, 'expected ' + ex + ' but got `' + this._t.tokenName(tok.id) + '\'');
        this._t.unconsume(tok);

        return new NoMatch(tok);
    }

    return rule.call(this, tok, m);
};

Parser.prototype.errors = function() {
    return this._preprocessor.errors().concat(this._errors);
};

exports.Parser = Parser;

// vi:ts=4:et

},{"./preprocessor":14,"./source":15,"./tokenizer":17}],11:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

var glsl = {
    source: require('./source'),
    ast: require('./ast'),
    tokenizer: require('./tokenizer'),
};

var Tn = glsl.tokenizer.Tokenizer;
var dtn = new Tn(null);

function TypeClass(name) {
    glsl.ast.Node.call(this);
    this.incomplete = false;

    this.name = name;

    this.isPrimitive = false;
    this.isArray = false;
    this.isComposite = false;
    this.isUser = false;

    this.decl = null;
}

TypeClass.prototype = glsl.ast.Node.create('TypeClass', TypeClass);
exports.TypeClass = TypeClass;


function CompositeType(name) {
    TypeClass.call(this, name);

    this.fieldMap = {};
    this.fields = [];
    this.isComposite = true;
    this.hasArrayField = false;
    this.hasSamplerField = false;

    this.zero = {};
}

CompositeType.prototype = glsl.ast.Node.create('builtins.CompositeType', CompositeType, TypeClass);
exports.CompositeType = CompositeType;

CompositeType.prototype.declareField = function(name, type) {
    var field = {
        name: name,
        type: type,
        decl: null
    };

    if (type.isArray || (type.isComposite && type.hasArrayField)) {
        this.hasArrayField = true;
    }

    if (type.isSampler || (type.isComposite && type.hasSamplerField)) {
        this.hasSamplerField = true;
    }

    this.fields.push(field);
    this.fieldMap[name] = field;

    this.zero[name] = type.zero;
    return field;
};


function UserType(name, decl) {
    CompositeType.call(this, name);

    this.decl = decl;
    this.isUser = true;
}

UserType.prototype = glsl.ast.Node.create('builtins.UserType', UserType, CompositeType);
exports.UserType = UserType;


function ArrayType(elementType, length) {
    TypeClass.call(this, elementType.name + '[' + length + ']');

    this.elementType = elementType;
    this.length = length;

    this.zero = [];

    for (var i = 0; i < length; i++) {
        this.zero.push(elementType.zero);
    }

    this.isArray = true;
}

ArrayType.prototype = glsl.ast.Node.create('builtins.ArrayType', ArrayType, TypeClass);
exports.ArrayType = ArrayType;


function PrimitiveType(id, zero) {
    TypeClass.call(this, dtn.tokenName(id));

    this.id = id;
    this.zero = zero;

    this.isScalar = PrimitiveType._isScalar(id);
    this.isVec = PrimitiveType._isVec(id);
    this.isMat = PrimitiveType._isMat(id);
    this.isSampler = PrimitiveType._isSampler(id);

    this.elementType = PrimitiveType._elementType(id);
    this.isInt = (this.elementType == Tn.T_INT);
    this.isFloat = (this.elementType == Tn.T_FLOAT);
    this.isBool = (this.elementType == Tn.T_BOOL);

    this.isPrimitive = true;

    this.length = PrimitiveType._length(id);
}

PrimitiveType.prototype = glsl.ast.Node.create('builtins.PrimitiveType', PrimitiveType, TypeClass);
exports.PrimitiveType = PrimitiveType;

PrimitiveType.prototype.marshalCanRef = function() {
    return false;
};

PrimitiveType.prototype.marshal = function() {
    return '$' + this.name;
};

PrimitiveType._isVec = function(tok) {
    switch (tok) {
    case Tn.T_VEC2:
    case Tn.T_VEC3:
    case Tn.T_VEC4:
    case Tn.T_BVEC2:
    case Tn.T_BVEC3:
    case Tn.T_BVEC4:
    case Tn.T_IVEC2:
    case Tn.T_IVEC3:
    case Tn.T_IVEC4:
        return true;
    }

    return false;
};

PrimitiveType._isSampler = function(tok) {
    switch (tok) {
    case Tn.T_SAMPLER2D:
    case Tn.T_SAMPLERCUBE:
        return true;
    }

    return false;
};

PrimitiveType._isMat = function(tok) {
    switch (tok) {
    case Tn.T_MAT2:
    case Tn.T_MAT3:
    case Tn.T_MAT4:
        return true;
    }

    return false;
};

PrimitiveType._isScalar = function(tok) {
    switch (tok) {
    case Tn.T_FLOAT:
    case Tn.T_INT:
    case Tn.T_BOOL:
        return true;
    }

    return false;
};

PrimitiveType._elementType = function(tok) {
    switch (tok) {
    case Tn.T_FLOAT:
    case Tn.T_VEC2:
    case Tn.T_VEC3:
    case Tn.T_VEC4:
    case Tn.T_MAT2:
    case Tn.T_MAT3:
    case Tn.T_MAT4:
        return Tn.T_FLOAT;
    case Tn.T_INT:
    case Tn.T_IVEC2:
    case Tn.T_IVEC3:
    case Tn.T_IVEC4:
        return Tn.T_INT;
    case Tn.T_BOOL:
    case Tn.T_BVEC2:
    case Tn.T_BVEC3:
    case Tn.T_BVEC4:
        return Tn.T_BOOL;

    }

    return null;
};

PrimitiveType._length = function(tok) {
    switch (tok) {
    case Tn.T_FLOAT:
    case Tn.T_INT:
    case Tn.T_BOOL:
        return 1;
    case Tn.T_VEC2:
    case Tn.T_IVEC2:
    case Tn.T_BVEC2:
    case Tn.T_MAT2:
        return 2;
    case Tn.T_VEC3:
    case Tn.T_IVEC3:
    case Tn.T_BVEC3:
    case Tn.T_MAT3:
        return 3;
    case Tn.T_VEC4:
    case Tn.T_IVEC4:
    case Tn.T_BVEC4:
    case Tn.T_MAT4:
        return 4;
    }

    return 0;
};

function Operator(op) {
    this.op = op;
    this.ret = null;
    this.lhs = null;
    this.rhs = null;
}

Operator.prototype._evaluateElem = function(a, b) {
    switch (this.op) {
    case Tn.T_PLUS:
        return a + b;
    case Tn.T_DASH:
        return a - b;
    case Tn.T_STAR:
        return a * b;
    case Tn.T_SLASH:
        return a / b;
    case Tn.T_LEFT_ANGLE:
        return a < b;
    case Tn.T_RIGHT_ANGLE:
        return a > b;
    case Tn.T_LE_OP:
        return a <= b;
    case Tn.T_GE_OP:
        return a >= b;
    case Tn.T_EQ_OP:
        return a == b;
    case Tn.T_NE_OP:
        return a != b;
    case Tn.T_AND_OP:
        return a && b;
    case Tn.T_OR_OP:
        return a || b;
    case Tn.T_XOR_OP:
        return (a && !b) || (b && !a);
    }
};

Operator.prototype.evaluate = function(a, b) {
    if (this.op == Tn.T_STAR) {
        if (this.lhs.isVec && this.rhs.isMat) {
            var ret = [];

            for (var i = 0; i < this.lhs.length; i++) {
                var s = 0;

                for (var j = 0; j < this.lhs.length; j++) {
                    s += a[j] * b[i][j];
                }

                ret.push(s);
            }

            return ret;
        } else if (this.lhs.isMat && this.rhs.isVec) {
            var ret = [];

            for (var i = 0; i < this.lhs.length; i++) {
                var s = 0;

                for (var j = 0; j < this.lhs.length; j++) {
                    s += a[j][i] * b[j];
                }

                ret.push(s);
            }

            return ret;
        }
    }

    if (this.lhs.isVec || this.rhs.isVec) {
        var ret = [];
        var l = (this.lhs.isVec ? this.lhs.length : this.rhs.length);

        for (var i = 0; i < l; i++) {
            ret.push(this._evaluateElem(this.lhs.isVec ? a[i] : a, this.rhs.isVec ? b[i] : b));
        }

        return ret;
    } else if (this.lhs.isMat || this.rhs.isMat) {
        var ret = [];
        var l = (this.lhs.isMat ? this.lhs.length : this.rhs.length);

        for (var i = 0; i < l; i++) {
            for (var j = 0; j < l; j++) {
                ret.push(this._evaluateElem(this.lhs.isMat ? a[i][j] : a, this.rhs.isMat ? b[i][j] : b));
            }
        }

        return ret;
    } else {
        return this._evaluateElem(a, b);
    }
};

function UnaryOperator(op) {
    this.op = op;
    this.ret = null;
    this.expr = null;
}

UnaryOperator.prototype.evaluate = function(a) {
    switch (this.op) {
    case Tn.T_BANG:
        return !a;
    case Tn.T_DASH:
        return -a;
    case Tn.T_INC_OP:
        return a + 1;
    case Tn.T_DEC_OP:
        return a - 1;
    }
};

function Builtins(type, options) {
    this.type = type;

    if (typeof options === 'undefined') {
        options = {};
    }

    this._options = options;

    this.types = [];
    this.typeMap = {};

    this.variables = [];
    this.variableMap = {};

    this.functions = [];
    this.functionMap = {};

    this.operators = [];
    this.operatorMap = {};

    this.precisions = [];
    this.precisionMap = {};

    this._defineTypes();
    this._defineConstants();
    this._defineVariables();
    this._defineFunctions();
    this._defineOperators();
    this._definePrecisions();
}

exports.Builtins = Builtins;

Builtins.createForContext = function(ctx, type) {
    return new Builtins(type, Builtins.optionsFromContext(ctx));
};

Builtins.optionsFromContext = function(ctx) {
    var constants = {};

    if (ctx !== null) {
        var c = {
            'gl_MaxVertexAttribs': 'MAX_VERTEX_ATTRIBS',
            'gl_MaxVertexUniformVectors': 'MAX_VERTEX_UNIFORM_VECTORS',
            'gl_MaxVaryingVectors': 'MAX_VARYING_VECTORS',
            'gl_MaxVertexTextureImageUnits': 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
            'gl_MaxCombinedTextureImageUnits': 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
            'gl_MaxTextureImageUnits': 'MAX_TEXTURE_IMAGE_UNITS',
            'gl_MaxFragmentUniformVectors': 'MAX_FRAGMENT_UNIFORM_VECTORS',
            'gl_MaxDrawBuffers': 1
        };

        for (var name in c) {
            var cval = c[name];

            if (typeof cval !== 'string') {
                constants[name] = cval;
            } else if (typeof ctx[cval] !== 'undefined') {
                constants[name] = ctx.getParameter(ctx[cval]);
            }
        }

        var drawbuffersExt = ctx.getExtension('WEBGL_draw_buffers');

        if (drawbuffersExt !== null) {
            constants.gl_MaxDrawBuffers = ctx.getParameter(drawbuffersExt.MAX_DRAW_BUFFERS_WEBGL);
        } else {
            constants.gl_MaxDrawBuffers = 1;
        }
    }

    var ret = {
        constants: constants
    };

    var exts = ctx.getSupportedExtensions();

    if (exts.indexOf('OES_standard_derivatives') !== -1) {
        ret.derivatives = true;
    }

    return ret;
};

Builtins.prototype._defineTypes = function() {
    var btypetoks = [
        [Tn.T_VOID, 0],
        [Tn.T_FLOAT, 0.0],
        [Tn.T_INT, 0],
        [Tn.T_BOOL, false],

        [Tn.T_VEC2, [0.0, 0.0]],
        [Tn.T_VEC3, [0.0, 0.0, 0.0]],
        [Tn.T_VEC4, [0.0, 0.0, 0.0, 0.0]],

        [Tn.T_BVEC2, [false, false]],
        [Tn.T_BVEC3, [false, false, false]],
        [Tn.T_BVEC4, [false, false, false, false]],

        [Tn.T_IVEC2, [0, 0]],
        [Tn.T_IVEC3, [0, 0, 0]],
        [Tn.T_IVEC4, [0, 0, 0, 0]],

        [Tn.T_MAT2, [[0, 0], [0, 0]]],
        [Tn.T_MAT3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]],
        [Tn.T_MAT4, [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]],

        [Tn.T_SAMPLER2D, 0],
        [Tn.T_SAMPLERCUBE, 0]
    ];

    for (var i = 0; i < btypetoks.length; i++) {
        var tokid = btypetoks[i][0];
        var zero = btypetoks[i][1];

        var name = dtn.tokenName(tokid);

        var bloc = new glsl.source.BuiltinRange();
        var tok = dtn.createToken(tokid, name, bloc);

        var decl = new glsl.ast.TypeDecl((new glsl.ast.TypeRef(tok)).complete());
        decl.semi = dtn.createToken(Tn.T_SEMICOLON, ';', bloc);
        decl.incomplete = false;

        decl.type.t = {
            type: new PrimitiveType(tokid, zero)
        };

        this.types.push(decl);
        this.typeMap[tokid] = decl;

        name = name[0].toUpperCase() + name.slice(1);

        this[name] = decl.type.t.type;
    }
};

Builtins.prototype._declareVariable = function(qualifiers, typeid, name, arsize, defintval) {
    var type = this.typeMap[typeid];
    var bloc = new glsl.source.BuiltinRange();

    var tp = new glsl.ast.TypeRef(dtn.createToken(typeid, dtn.tokenName(typeid), bloc));
    tp.complete();

    for (var i = 0; i < qualifiers.length; i++) {
        var q = qualifiers[i];

        tp.qualifiers.push(dtn.createToken(q, dtn.tokenName(q), bloc));
    }

    tp.t = {
        type: type.type.t.type
    };

    var decl = new glsl.ast.VariableDecl(tp);

    var n = new glsl.ast.Named(dtn.createToken(Tn.T_IDENTIFIER, name, bloc), decl);

    n.type = tp;

    n.t = {
        type: n.type.t.type,
        users: []
    };

    var Int = this.typeMap[Tn.T_INT].type.t.type;

    if (typeof arsize !== 'undefined' && arsize !== null) {
        n.isArray = true;
        n.leftBracket = dtn.createToken(Tn.T_LEFT_BRACKET, dtn.tokenName(Tn.T_LEFT_BRACKET), bloc);
        n.rightBracket = dtn.createToken(Tn.T_RIGHT_BRACKET, dtn.tokenName(Tn.T_RIGHT_BRACKET), bloc);

        if (typeof arsize === 'string') {
            var expr = new glsl.ast.VariableExpr(dtn.createToken(Tn.T_IDENTIFIER, arsize, bloc));
            expr.complete();

            var c = this.variableMap[arsize];

            expr.t = {
                decl: c,
                type: c.names[0].t.type,
                isConstExpression: true,
                constValue: c.names[0].t.constValue
            };

            n.arraySize = expr;
        } else {
            var tok = dtn.createToken(Tn.T_INTCONSTANT, "" + arsize, bloc);
            tok.value = arsize;

            n.arraySize = new glsl.ast.ConstantExpr(tok);
            n.arraySize.complete();

            n.arraySize.t = {
                type: Int,
                isConstExpression: true,
                constValue: arsize
            };
        }
    }

    if (typeof defintval !== 'undefined' && defintval !== null) {
        if (typeof this._options.constants !== 'undefined' && name in this._options.constants) {
            defintval = this._options.constants[name];
        }

        n.initialAssign = dtn.createToken(Tn.T_EQUAL, dtn.tokenName(Tn.T_EQUAL), bloc);

        var tok = dtn.createToken(Tn.T_INTCONSTANT, "" + defintval, bloc);
        tok.value = defintval;

        n.initialValue = new glsl.ast.ConstantExpr(tok);
        n.initialValue.complete();
        n.initialValue.t = {
            type: Int,
            isConstExpression: true,
            constValue: defintval
        };

        n.t.isConstExpression = true;
        n.t.constValue = defintval;
    }

    n.complete();

    decl.names.push(n);
    decl.complete();

    decl.t = {
        type: tp.t.type
    };

    this.variables.push(decl);
    this.variableMap[name] = decl;
};

Builtins.prototype._defineConstants = function() {
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxVertexAttribs', null, 8);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxVertexUniformVectors', null, 128);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxVaryingVectors', null, 8);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxVertexTextureImageUnits', null, 0);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxCombinedTextureImageUnits', null, 8);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxTextureImageUnits', null, 8);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxFragmentUniformVectors', null, 16);
    this._declareVariable([Tn.T_CONST, Tn.T_MEDIUMP], Tn.T_INT, 'gl_MaxDrawBuffers', null, 1);
};

Builtins.prototype._defineVariables = function() {
    switch (this.type) {
    case glsl.source.VERTEX:
        this._declareVariable([Tn.T_HIGHP], Tn.T_VEC4, 'gl_Position');
        this._declareVariable([Tn.T_MEDIUMP], Tn.T_FLOAT, 'gl_PointSize');
        break;
    case glsl.source.FRAGMENT:
        this._declareVariable([Tn.T_MEDIUMP], Tn.T_VEC4, 'gl_FragCoord');
        this._declareVariable([], Tn.T_BOOL, 'gl_FrontFacing');
        this._declareVariable([Tn.T_MEDIUMP], Tn.T_VEC4, 'gl_FragColor');
        this._declareVariable([Tn.T_MEDIUMP], Tn.T_VEC4, 'gl_FragData', 'gl_MaxDrawBuffers');
        this._declareVariable([Tn.T_MEDIUMP], Tn.T_VEC2, 'gl_PointCoord');
        break;
    }
};

Builtins.prototype._declarePrecision = function(precision, typeid) {
    var bloc = new glsl.source.BuiltinRange();
    var type = this.typeMap[typeid];

    var prec = new glsl.ast.PrecisionStmt(dtn.createToken(Tn.T_PRECISION, dtn.tokenName(Tn.T_PRECISION), bloc));

    prec.qualifier = dtn.createToken(precision, dtn.tokenName(precision), bloc);

    var tp = new glsl.ast.TypeRef(dtn.createToken(typeid, dtn.tokenName(typeid), bloc));
    tp.complete();

    tp.t = {
        type: type.type.t.type
    };

    prec.type = tp;
    prec.semi = dtn.createToken(Tn.T_SEMICOLON, ';', bloc);

    this.precisions.push(prec);
    this.precisionMap[type.name] = prec;
};

Builtins.prototype._definePrecisions = function() {
    switch (this.type) {
    case glsl.source.VERTEX:
        this._declarePrecision(Tn.T_HIGHP, Tn.T_FLOAT);
        this._declarePrecision(Tn.T_HIGHP, Tn.T_INT);
        this._declarePrecision(Tn.T_LOWP, Tn.T_SAMPLER2D);
        this._declarePrecision(Tn.T_LOWP, Tn.T_SAMPLERCUBE);
        break;
    case glsl.source.FRAGMENT:
        this._declarePrecision(Tn.T_MEDIUMP, Tn.T_INT);
        this._declarePrecision(Tn.T_LOWP, Tn.T_SAMPLER2D);
        this._declarePrecision(Tn.T_LOWP, Tn.T_SAMPLERCUBE);
        break;
    }
};

Builtins.prototype._elemEvaluator = function() {
    var l = 0;

    for (var i = 0; i < arguments.length; i++) {
        if (Array.prototype.isPrototypeOf(arguments[i])) {
            l = arguments[i].length;
            break;
        }
    }

    if (l === 0) {
        return this.apply(this, arguments);
    } else {
        var ret = [];

        for (var i = 0; i < l; i++) {
            var args = [];

            for (var j = 0; j < arguments.length; j++) {
                var arg = arguments[j];

                if (Array.prototype.isPrototypeOf(arg)) {
                    args.push(arg[i]);
                } else {
                    args.push(arg);
                }
            }

            ret.push(this.apply(this, args));
        }

        return ret;
    }
};

Builtins.prototype._funcEvaluator = function() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
        if (!Array.prototype.isPrototypeOf(arguments[i])) {
            args.push([arguments[i]]);
        } else {
            args.push(arguments[i]);
        }
    }

    return this.apply(this, args);
};

Builtins.prototype._defineBuiltinFunction = function(rettype, name, params, elemfunc, func) {
    if (!glsl.ast.TypeDecl.prototype.isPrototypeOf(rettype)) {
        rettype = this.typeMap[rettype];
    }

    var sp = params.slice();

    for (var i = 0; i < sp.length; i += 2) {
        var p = sp[i];

        if (!glsl.ast.TypeDecl.prototype.isPrototypeOf(p)) {
            sp[i] = this.typeMap[p];
        }
    }

    var bloc = new glsl.source.BuiltinRange();

    var type = new glsl.ast.TypeRef(dtn.createToken(rettype.type.token.id, dtn.tokenName(rettype.type.token.id), bloc));
    type.incomplete = false;

    type.t = {
        type: rettype.type.t.type
    };

    var name = dtn.createToken(Tn.T_IDENTIFIER, name, bloc);

    var header = new glsl.ast.FunctionHeader(type, name);
    header.leftParen = dtn.createToken(Tn.T_LEFT_PAREN, '(', bloc);
    header.rightParen = dtn.createToken(Tn.T_RIGHT_PAREN, ')', bloc);

    header.incomplete = false;

    for (var i = 0; i < sp.length; i += 2) {
        var p = sp[i];

        var decl = (new glsl.ast.ParamDecl()).complete();

        decl.type = p.type;
        decl.name = dtn.createToken(Tn.T_IDENTIFIER, sp[i + 1], bloc);

        header.parameters.push(decl);
    }

    var sig = header.signature();

    if (sig in this.functionMap) {
        return;
    }

    var f = new glsl.ast.FunctionProto(header);

    f.isBuiltin = true;
    f.semi = dtn.createToken(Tn.T_SEMICOLON, ';', bloc);
    f.incomplete = false;

    if (elemfunc) {
        f.evaluate = this._elemEvaluator.bind(elemfunc);
    } else if (func) {
        f.evaluate = this._funcEvaluator.bind(func);
    } else {
        f.evaluate = null;
    }

    this.functions.push(f);
    this.functionMap[sig] = f;

    return f;
};

Builtins.prototype._defineBuiltinFunctionGen = function(gentypes, rettype, name, params, elemfunc, func) {
    if (rettype !== null) {
        rettype = this.typeMap[rettype];
    }

    for (var i = 0; i < gentypes.length; i++) {
        var g = this.typeMap[gentypes[i]];
        var sp = params.slice();

        for (var j = 0; j < sp.length; j += 2) {
            var item = sp[j];

            if (item === null) {
                sp[j] = g;
            } else {
                sp[j] = this.typeMap[item];
            }
        }

        this._defineBuiltinFunction(rettype !== null ? rettype : g,
                                      name,
                                      sp,
                                      elemfunc,
                                      func);
    }
};

Builtins.prototype._defineBuiltinGentypeFunction = function(rettype, name, params, elemfunc, func) {
    var gentypes = [Tn.T_FLOAT, Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4];

    this._defineBuiltinFunctionGen(gentypes, rettype, name, params, elemfunc, func);
};

Builtins.prototype._defineBuiltinMatFunction = function(rettype, name, params, elemfunc, func) {
    var gentypes = [Tn.T_MAT2, Tn.T_MAT3, Tn.T_MAT4];

    this._defineBuiltinFunctionGen(gentypes, rettype, name, params, elemfunc, func);
};

Builtins.prototype._defineBuiltinRelvecFunction = function(rettype, name, params, elemfunc, func) {
    var vmap = {
        'bvec': [Tn.T_BVEC2, Tn.T_BVEC3, Tn.T_BVEC4],
        'vec':  [Tn.T_VEC2,  Tn.T_VEC3,  Tn.T_VEC4],
        'ivec': [Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4]
    };

    for (var i = 0; i < 3; i++) {
        var ret = rettype;

        if (rettype in vmap) {
            ret = vmap[rettype][i];
        }

        var sp = params.slice();

        for (var j = 0; j < sp.length; j += 2) {
            var p = sp[j];

            if (p in vmap) {
                sp[j] = vmap[p][i];
            }
        }

        this._defineBuiltinFunction(ret, name, sp, elemfunc, func);
    }
};

Builtins.prototype._findType = function(t, def) {
    if (t === null) {
        t = def;
    }

    return this.typeMap[t].type.t.type;
};

Builtins.prototype._defineBuiltinBinOperatorGen = function(rettype, optypes, lhs, rhs, gens) {
    for (var i = 0; i < optypes.length; i++) {
        var op = optypes[i];

        for (var j = 0; j < gens.length; j++) {
            var g = gens[j];

            var o = new Operator(op);
            o.ret = this._findType(rettype, g);
            o.lhs = this._findType(lhs, g);
            o.rhs = this._findType(rhs, g);

            var sig = dtn.tokenName(op) + '(' + o.lhs.name + ',' + o.rhs.name + ')';

            this.operators.push(o);
            this.operatorMap[sig] = o;
        }
    }
};

Builtins.prototype._defineBuiltinUnaryOperatorGen = function(rettype, optypes, expr, gens) {
    for (var i = 0; i < optypes.length; i++) {
        var op = optypes[i];

        for (var j = 0; j < gens.length; j++) {
            var g = gens[j];

            var o = new UnaryOperator(op);
            o.ret = this._findType(rettype, g);
            o.expr = this._findType(expr, g);

            var sig = dtn.tokenName(op) + '(' + o.expr.name + ')';

            this.operators.push(o);
            this.operatorMap[sig] = o;
        }
    }
};

var Emulate = {
    radians: function (degrees) {
        return degrees / 180.0 * Math.PI;
    },

    degrees: function (radians) {
        return radians / Math.PI * 180.0;
    },

    exp2: function (x) {
        return Math.pow(2, x);
    },

    log2: function (x) {
        return Math.log(x) / Math.log(2);
    },

    inversesqrt: function (x) {
        return 1 / Math.sqrt(x);
    },

    sign: function (x) {
        return x < 0 ? -1 : (x > 0 ? 1 : 0);
    },

    fract: function (x) {
        return x - Math.floor(x);
    },

    mod: function (x, y) {
        return x - y * Math.floor(x / y);
    },

    clamp: function (x, minVal, maxVal) {
        return Math.min(Math.max(x, minVal), maxVal);
    },

    mix: function (x, y, a) {
        return x * (1 - a) + y * a;
    },

    smoothstep: function (edge0, edge1, x) {
        if (x < edge0) {
            return 0;
        } else if (x > edge1) {
            return 1;
        } else {
            var n = (x - edge0) / (edge1 - edge0);
            return n * n * (3 - 2 * n);
        }
    },

    step: function (edge, x) {
        return x < edge ? 0 : 1;
    },

    length: function(x) {
        var s = 0;

        for (var i = 0; i < x.length; i++) {
            s += x[i] * x[i];
        }

        return Math.sqrt(s);
    },

    distance: function(p0, p1) {
        var s = 0;

        for (var i = 0; i < p0.length; i++) {
            var d = p0[i] - p1[i];
            s += d * d;
        }

        return Math.sqrt(s);
    },

    dot: function(x, y) {
        var s = 0;

        for (var i = 0; i < x.length; i++) {
            s += x[i] * y[i];
        }

        return s;
    },

    cross: function(x, y) {
        return [
            x[1] * y[2] - y[1] * x[2],
            x[2] * y[0] - y[2] * x[0],
            x[0] * y[1] - y[0] * x[1]
        ];
    },

    normalize: function(x) {
        var s = [];
        var l = Emulate.length(x);

        for (var i = 0; i < x.length; i++) {
            s.push(x[i] / l);
        }

        return s;
    },

    faceforward: function(N, I, Nref) {
        var s = [];

        var isit = Emulate.dot(Nref, I);

        for (var i = 0; i < N.length; i++) {
            s.push(isit ? N[i] : -N[i]);
        }

        return s;
    },

    reflect: function(I, N) {
        var d = Emulate.dot(N, I);
        var s = [];

        for (var i = 0; i < I.length; i++) {
            s.push(I[i] - 2 * d * N[i]);
        }

        return s;
    },

    refract: function(I, N, eta) {
        eta = eta[0];

        var d = Emulate.dot(N, I);
        var k = 1 - eta * eta * (1 - d * d);
        var s = [];
        var sk = 0;

        if (k >= 0) {
            sk = eta * d + Math.sqrt(k);
        }

        for (var i = 0; i < I.length; i++) {
            if (k < 0) {
                s.push(0);
            } else {
                s.push(eta * I[i] - sk * N[i]);
            }
        }

        return s;
    },

    matrixCompMult: function(x, y) {
        return x * y;
    },

    lessThan: function(x, y) {
        return x < y;
    },

    lessThanEqual: function(x, y) {
        return x <= y;
    },

    greaterThan: function(x, y) {
        return x > y;
    },

    greaterThanEqual: function(x, y) {
        return x < y;
    },

    equal: function(x, y) {
        return x == y;
    },

    notEqual: function(x, y) {
        return x != y;
    },

    any: function(x) {
        for (var i = 0; i < x.length; i++) {
            if (x[i]) {
                return true;
            }
        }

        return false;
    },

    all: function(x) {
        for (var i = 0; i < x.length; i++) {
            if (!x[i]) {
                return false;
            }
        }

        return true;
    },

    not: function(x) {
        return !x;
    },
};

Builtins.prototype._defineFunctions = function() {
    this._defineBuiltinFunction(Tn.T_VOID, 'main', []);

    // Angle and Trigonometry functions
    this._defineBuiltinGentypeFunction(null, 'radians', [null, 'degrees'], Emulate.radians);
    this._defineBuiltinGentypeFunction(null, 'degrees', [null, 'radians'], Emulate.degrees);

    this._defineBuiltinGentypeFunction(null, 'sin', [null, 'angle'], Math.sin);
    this._defineBuiltinGentypeFunction(null, 'cos', [null, 'angle'], Math.cos);
    this._defineBuiltinGentypeFunction(null, 'tan', [null, 'angle'], Math.tan);

    this._defineBuiltinGentypeFunction(null, 'asin', [null, 'x'], Math.asin);
    this._defineBuiltinGentypeFunction(null, 'acos', [null, 'x'], Math.acos);
    this._defineBuiltinGentypeFunction(null, 'atan', [null, 'y', null, 'x'], Math.atan2);
    this._defineBuiltinGentypeFunction(null, 'atan', [null, 'y_over_x'], Math.atan);

    // Exponential Functions
    this._defineBuiltinGentypeFunction(null, 'pow', [null, 'x', null, 'y'], Math.pow);
    this._defineBuiltinGentypeFunction(null, 'exp', [null, 'x'], Math.exp);
    this._defineBuiltinGentypeFunction(null, 'log', [null, 'x'], Math.log);
    this._defineBuiltinGentypeFunction(null, 'exp2', [null, 'x'], Emulate.exp2);
    this._defineBuiltinGentypeFunction(null, 'log2', [null, 'x'], Emulate.log2);
    this._defineBuiltinGentypeFunction(null, 'sqrt', [null, 'x'], Math.sqrt);
    this._defineBuiltinGentypeFunction(null, 'inversesqrt', [null, 'x'], Emulate.inversesqrt);

    // Common Functions
    this._defineBuiltinGentypeFunction(null, 'abs', [null, 'x'], Math.abs);
    this._defineBuiltinGentypeFunction(null, 'sign', [null, 'x'], Emulate.sign);
    this._defineBuiltinGentypeFunction(null, 'floor', [null, 'x'], Math.floor);
    this._defineBuiltinGentypeFunction(null, 'ceil', [null, 'x'], Math.ceil);
    this._defineBuiltinGentypeFunction(null, 'fract', [null, 'x'], Emulate.fract);
    this._defineBuiltinGentypeFunction(null, 'mod', [null, 'x', null, 'y'], Emulate.mod);
    this._defineBuiltinGentypeFunction(null, 'min', [null, 'x', null, 'y'], Math.min);
    this._defineBuiltinGentypeFunction(null, 'min', [null, 'x', Tn.T_FLOAT, 'y'], Math.min);
    this._defineBuiltinGentypeFunction(null, 'max', [null, 'x', null, 'y'], Math.max);
    this._defineBuiltinGentypeFunction(null, 'max', [null, 'x', Tn.T_FLOAT, 'y'], Math.max);
    this._defineBuiltinGentypeFunction(null, 'clamp', [null, 'x', null, 'minVal', null, 'maxVal'], Emulate.clamp);
    this._defineBuiltinGentypeFunction(null, 'clamp', [null, 'x', Tn.T_FLOAT, 'minVal', Tn.T_FLOAT, 'maxVal'], Emulate.clamp);
    this._defineBuiltinGentypeFunction(null, 'mix', [null, 'x', null, 'y', null, 'a'], Emulate.mix);
    this._defineBuiltinGentypeFunction(null, 'mix', [null, 'x', null, 'y', Tn.T_FLOAT, 'a'], Emulate.mix);
    this._defineBuiltinGentypeFunction(null, 'step', [null, 'edge', null, 'x'], Emulate.step);
    this._defineBuiltinGentypeFunction(null, 'step', [Tn.T_FLOAT, 'edge', null, 'x'], Emulate.step);
    this._defineBuiltinGentypeFunction(null, 'smoothstep', [null, 'edge0', null, 'edge1', null, 'x'], Emulate.smoothstep);
    this._defineBuiltinGentypeFunction(null, 'smoothstep', [Tn.T_FLOAT, 'edge0', Tn.T_FLOAT, 'edge1', null, 'x'], Emulate.smootstep);

    // Geometric Functions
    this._defineBuiltinGentypeFunction(Tn.T_FLOAT, 'length',
                                          [null, 'x'], null, Emulate.length);

    this._defineBuiltinGentypeFunction(Tn.T_FLOAT, 'distance',
                                          [null, 'p0', null, 'p1'], null, Emulate.distance);

    this._defineBuiltinGentypeFunction(Tn.T_FLOAT, 'dot',
                                          [null, 'x', null, 'y'], null, Emulate.dot);

    this._defineBuiltinFunction(Tn.T_VEC3, 'cross',
                                  [Tn.T_VEC3, 'x', Tn.T_VEC3, 'y'], null, Emulate.cross);

    this._defineBuiltinGentypeFunction(null, 'normalize',
                                          [null, 'x'], null, Emulate.normalize);

    this._defineBuiltinGentypeFunction(null, 'faceforward',
                                          [null, 'N', null, 'I', null, 'Nref'], null, Emulate.faceforward);

    this._defineBuiltinGentypeFunction(null, 'reflect',
                                          [null, 'I', null, 'N'], null, Emulate.reflect);

    this._defineBuiltinGentypeFunction(null, 'refract',
                                          [null, 'I', null, 'N', Tn.T_FLOAT, 'eta'], null, Emulate.refract);

    // Matrix Functions
    this._defineBuiltinMatFunction(null, 'matrixCompMult', [null, 'x', null, 'y'], Emulate.matrixCompMult);

    // Vector Relational Functions
    this._defineBuiltinRelvecFunction('bvec', 'lessThan',
                                         ['vec', 'x', 'vec', 'y'], Emulate.lessThan);

    this._defineBuiltinRelvecFunction('bvec', 'lessThan',
                                         ['ivec', 'x', 'ivec', 'y'], Emulate.lessThan);

    this._defineBuiltinRelvecFunction('bvec', 'lessThanEqual',
                                         ['vec', 'x', 'vec', 'y'], Emulate.lessThanEqual);

    this._defineBuiltinRelvecFunction('bvec', 'lessThanEqual',
                                         ['ivec', 'x', 'ivec', 'y'], Emulate.lessThanEqual);

    this._defineBuiltinRelvecFunction('bvec', 'greaterThan',
                                         ['vec', 'x', 'vec', 'y'], Emulate.greaterThan);
    this._defineBuiltinRelvecFunction('bvec', 'greaterThan',
                                         ['ivec', 'x', 'ivec', 'y'], Emulate.greaterThan);

    this._defineBuiltinRelvecFunction('bvec', 'greaterThanEqual',
                                         ['vec', 'x', 'vec', 'y'], Emulate.greaterThanEqual);

    this._defineBuiltinRelvecFunction('bvec', 'greaterThanEqual',
                                         ['ivec', 'x', 'ivec', 'y'], Emulate.greaterThanEqual);

    this._defineBuiltinRelvecFunction('bvec', 'equal',
                                         ['vec', 'x', 'vec', 'y'], Emulate.equal);

    this._defineBuiltinRelvecFunction('bvec', 'equal',
                                         ['ivec', 'x', 'ivec', 'y'], Emulate.equal);

    this._defineBuiltinRelvecFunction('bvec', 'notEqual',
                                         ['vec', 'x', 'vec', 'y'], Emulate.notEqual);

    this._defineBuiltinRelvecFunction('bvec', 'notEqual',
                                         ['ivec', 'x', 'ivec', 'y'], Emulate.notEqual);

    this._defineBuiltinRelvecFunction('bvec', 'notEqual',
                                         ['bvec', 'x', 'bvec', 'y'], Emulate.notEqual);

    this._defineBuiltinRelvecFunction(Tn.T_BOOL, 'any',
                                         ['bvec', 'x'], null, Emulate.any);

    this._defineBuiltinRelvecFunction(Tn.T_BOOL, 'all',
                                         ['bvec', 'x'], null, Emulate.all);

    this._defineBuiltinRelvecFunction('bvec', 'not',
                                         ['bvec', 'x'], Emulate.not);

    // Texture Lookup Functions
    this._defineBuiltinFunction(Tn.T_VEC4, 'texture2D',
                                  [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC2, 'coord']);

    this._defineBuiltinFunction(Tn.T_VEC4, 'texture2D',
                                  [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC2, 'coord', Tn.T_FLOAT, 'bias']);

    this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DProj',
                                  [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC3, 'coord']);

    this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DProj',
                                  [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC3, 'coord', Tn.T_FLOAT, 'bias']);

    this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DProj',
                                  [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC4, 'coord']);

    this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DProj',
                                  [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC4, 'coord', Tn.T_FLOAT, 'bias']);

    if (this.type == glsl.source.VERTEX) {
        this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DLod',
                                      [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC2, 'coord', Tn.T_FLOAT, 'lod']);

        this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DProjLod',
                                      [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC3, 'coord', Tn.T_FLOAT, 'lod']);

        this._defineBuiltinFunction(Tn.T_VEC4, 'texture2DProjLod',
                                      [Tn.T_SAMPLER2D, 'sampler', Tn.T_VEC4, 'coord', Tn.T_FLOAT, 'lod']);
    }

    this._defineBuiltinFunction(Tn.T_VEC4, 'textureCube',
                                  [Tn.T_SAMPLERCUBE, 'sampler', Tn.T_VEC3, 'coord']);

    this._defineBuiltinFunction(Tn.T_VEC4, 'textureCube',
                                  [Tn.T_SAMPLERCUBE, 'sampler', Tn.T_VEC3, 'coord', Tn.T_FLOAT, 'bias']);

    if (this.type === glsl.source.VERTEX) {
        this._defineBuiltinFunction(Tn.T_VEC4, 'textureCubeLod',
                                      [Tn.T_SAMPLERCUBE, 'sampler', Tn.T_VEC3, 'coord', Tn.T_FLOAT, 'lod']);
    }

    // Derivative functions
    if (this._options.derivatives && this.type === glsl.source.FRAGMENT) {
        this._defineBuiltinGentypeFunction(null, 'dFdx', [null, 'x']);
        this._defineBuiltinGentypeFunction(null, 'dFdy', [null, 'x']);
        this._defineBuiltinGentypeFunction(null, 'fwidth', [null, 'x']);
    }
};

Builtins.prototype._defineOperators = function() {
    // Operators
    this._defineBuiltinBinOperatorGen(null,
                                          [Tn.T_PLUS, Tn.T_DASH, Tn.T_STAR, Tn.T_SLASH],
                                          null, null,
                                          [Tn.T_INT, Tn.T_FLOAT,
                                           Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4,
                                           Tn.T_MAT2, Tn.T_MAT3, Tn.T_MAT4,
                                           Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4]);

    this._defineBuiltinBinOperatorGen(null,
                                          [Tn.T_PLUS, Tn.T_DASH, Tn.T_STAR, Tn.T_SLASH],
                                          Tn.T_FLOAT, null,
                                          [Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4,
                                           Tn.T_MAT2, Tn.T_MAT3, Tn.T_MAT3]);

    this._defineBuiltinBinOperatorGen(null,
                                          [Tn.T_PLUS, Tn.T_DASH, Tn.T_STAR, Tn.T_SLASH],
                                          null, Tn.T_FLOAT,
                                          [Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4,
                                           Tn.T_MAT2, Tn.T_MAT3, Tn.T_MAT3]);

    this._defineBuiltinBinOperatorGen(null,
                                          [Tn.T_PLUS, Tn.T_DASH, Tn.T_STAR, Tn.T_SLASH],
                                          Tn.T_INT, null,
                                          [Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4]);

    this._defineBuiltinBinOperatorGen(null,
                                          [Tn.T_PLUS, Tn.T_DASH, Tn.T_STAR, Tn.T_SLASH],
                                          null, Tn.T_INT,
                                          [Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4]);

    // Matrix/vector multiplication
    this._defineBuiltinBinOperatorGen(null, [Tn.T_STAR], Tn.T_MAT2, null, [Tn.T_VEC2]);
    this._defineBuiltinBinOperatorGen(null, [Tn.T_STAR], Tn.T_MAT3, null, [Tn.T_VEC3]);
    this._defineBuiltinBinOperatorGen(null, [Tn.T_STAR], Tn.T_MAT4, null, [Tn.T_VEC4]);

    this._defineBuiltinBinOperatorGen(null, [Tn.T_STAR], Tn.T_VEC2, null, [Tn.T_MAT2]);
    this._defineBuiltinBinOperatorGen(null, [Tn.T_STAR], Tn.T_VEC3, null, [Tn.T_MAT3]);
    this._defineBuiltinBinOperatorGen(null, [Tn.T_STAR], Tn.T_VEC4, null, [Tn.T_MAT4]);

    // Relational operators
    this._defineBuiltinBinOperatorGen(Tn.T_BOOL,
                                          [Tn.T_LEFT_ANGLE, Tn.T_RIGHT_ANGLE, Tn.T_LE_OP, Tn.T_GE_OP],
                                          null, null,
                                          [Tn.T_FLOAT, Tn.T_INT]);

    // Logical operators
    this._defineBuiltinBinOperatorGen(Tn.T_BOOL,
                                          [Tn.T_EQ_OP, Tn.T_NE_OP],
                                          null, null,
                                          [Tn.T_INT, Tn.T_FLOAT, Tn.T_BOOL,
                                           Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4,
                                           Tn.T_MAT2, Tn.T_MAT3, Tn.T_MAT4,
                                           Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4]);

    this._defineBuiltinBinOperatorGen(null,
                                          [Tn.T_AND_OP, Tn.T_OR_OP, Tn.T_XOR_OP],
                                          null, null,
                                          [Tn.T_BOOL]);

    // Unary operators
    this._defineBuiltinUnaryOperatorGen(null,
                                            [Tn.T_DASH, Tn.T_DEC_OP, Tn.T_INC_OP],
                                            null,
                                            [Tn.T_INT, Tn.T_FLOAT,
                                             Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4,
                                             Tn.T_MAT2, Tn.T_MAT3, Tn.T_MAT4,
                                             Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4]);

    this._defineBuiltinUnaryOperatorGen(null,
                                            [Tn.T_BANG],
                                            null,
                                            [Tn.T_BOOL]);
};

// vi:ts=4:et

},{"./ast":10,"./source":15,"./tokenizer":17}],12:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

module.exports = {
    source: require('./source'),
    tokenizer: require('./tokenizer'),
    preprocessor: require('./preprocessor'),
    ast: require('./ast'),
    builtins: require('./builtins'),
    sst: require('./sst'),
    linker: require('./linker')
}

// vi:ts=4:et

},{"./ast":10,"./builtins":11,"./linker":13,"./preprocessor":14,"./source":15,"./sst":16,"./tokenizer":17}],13:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

var glsl = {
    source: require('./source')
};

function Error(type, loc, message) {
    glsl.source.Error.call(this, loc, message);

    this.shaderType = type;
}

Error.prototype = Object.create(glsl.source.Error.prototype);
Error.prototype.constructor = Error;

exports.Error = Error;

function Linker(vertex, fragment) {
    this.vertex = vertex;
    this.fragment = fragment;

    this._errors = {
        vertex: [],
        fragment: []
    };
}

Linker.prototype._typesEqual = function(a, b) {
    if (a.isPrimitive !== b.isPrimitive ||
        a.isArray !== b.isArray ||
        a.isComposite !== b.isComposite) {

        return false;
    }

    if (a.isPrimitive) {
        return a.name === b.name;
    }

    if (a.isComposite) {
        var afields = {};
        var ret = {
            a: [],
            b: []
        };

        for (var i = 0; i < a.fields.length; i++) {
            afields[a.fields[i].name] = a.fields[i];
        }

        for (var i = 0; i < b.fields.length; i++) {
            var fb = b.fields[i];
            var fa = afields[fb.name];

            if (!fa) {
                ret.b.push({
                    location: fb.decl.location(),
                    message: 'field ' + fb.name +  ' in ' + b.name + ' missing in ' + a.name
                });
            } else {
                var d = this._typesEqual(fa.type, fb.type);

                if (d === false) {
                    var msg = 'type of field ' + fb.name + ' in vertex shader (' + fa.type.name + ') does not match type in fragment shader (' + fb.type.name + ')';

                    ret.a.push({
                        location: fa.decl.location(),
                        message: msg
                    });

                    ret.b.push({
                        location: fb.decl.location(),
                        message: msg
                    });
                } else if (d !== true) {
                    ret.a = ret.a.concat(d.a);
                    ret.b = ret.b.concat(d.b);
                }

                delete afields[fb.name];
            }
        }

        for (var k in afields) {
            var fa = afields[k];

            ret.a.push({
                location: fa.decl.location(),
                message: 'field ' + fa.name +  ' in ' + a.name + ' missing in ' + b.name
            });
        }

        if (ret.a.length !== 0 || ret.b.length !== 0) {
            return ret;
        }

        return true;
    }

    return false;
}

Linker.prototype._checkMatchingTypes = function(vv, fv, tpname) {
    var eq = this._typesEqual(vv.t.type, fv.t.type);

    if (eq === false) {
        var msg = 'type of ' + tpname + ' ' + fv.name.text + ' in vertex shader (' + vv.type.token.text + ') does not match type in fragment shader (' + fv.type.token.text + ')';

        this._vertexError(vv.location(), msg);
        this._fragmentError(fv.location(), msg);
    } else if (eq !== true) {
        for (var ei = 0; ei < eq.a.length; ei++) {
            var e = eq.a[ei];
            this._vertexError(e.location, e.message);
        }

        for (var ei = 0; ei < eq.b.length; ei++) {
            var e = eq.b[ei];
            this._fragmentError(e.location, e.message);
        }
    }
}

Linker.prototype._checkUniforms = function() {
    for (var i = 0; i < this.fragment.uniforms.length; i++) {
        var fv = this.fragment.uniforms[i];
        var vv = this.vertex.uniformMap[fv.name.text];

        if (vv) {
            this._checkMatchingTypes(vv, fv, 'uniform');
        }
    }
}

Linker.prototype._checkVaryings = function() {
    for (var i = 0; i < this.fragment.varyings.length; i++) {
        var fv = this.fragment.varyings[i];
        var vv = this.vertex.varyingMap[fv.name.text];

        if (vv) {
            this._checkMatchingTypes(vv, fv, 'varying');
        }

        // Check if all varyings used at least once by the fragment
        // shared, are declared in the vertex shader
        if (!vv && fv.t.users.length !== 0) {
            var msg = 'the varying variable ' + fv.name.text + ' (' + fv.type.token.text + ') is used in the fragment shader, but never declared in the vertex shader';

            for (var u = 0; u < fv.t.users.length; u++) {
                this._fragmentError(fv.t.users[u].location(), msg);
            }
        }
    }
}

Linker.prototype._fragmentError = function(loc, message) {
    this._error(glsl.source.FRAGMENT, loc, message);
};

Linker.prototype._vertexError = function(loc, message) {
    this._error(glsl.source.VERTEX, loc, message);
};

Linker.prototype._error = function(type, loc, message) {
    var e = new Error(type, loc, message);

    if (type === glsl.source.VERTEX) {
        this._errors.vertex.push(e);
    } else {
        this._errors.fragment.push(e);
    }
};

Linker.prototype.errors = function() {
    return this._errors;
}

Linker.prototype.link = function() {
    this._errors = {
        vertex: [],
        fragment: []
    };

    this._checkVaryings();
    this._checkUniforms();

    return this.errors();
}

exports.Linker = Linker;
exports.Error = Error;

// vi:ts=4:et

},{"./source":15}],14:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

var glsl = {
    tokenizer: require('./tokenizer'),
    source: require('./source')
};

function ExpressionTokenizer(source) {
    glsl.tokenizer.Base.prototype.init.call(this, source);
}

ExpressionTokenizer.keywords = {
    'defined': 'DEFINED'
};

ExpressionTokenizer.operators = {
    '<<': 'LEFT_OP',
    '>>': 'RIGHT_OP',
    '<=': 'LE_OP',
    '>=': 'GE_OP',
    '==': 'EQ_OP',
    '!=': 'NE_OP',
    '&&': 'AND_OP',
    '||': 'OR_OP',
    '^^': 'XOR_OP',

    '(': 'LEFT_PAREN',
    ')': 'RIGHT_PAREN',

    ',': 'COMMA',
    '!': 'BANG',
    '-': 'DASH',
    '~': 'TILDE',
    '+': 'PLUS',
    '*': 'STAR',
    '/': 'SLASH',
    '%': 'PERCENT',

    '<': 'LEFT_ANGLE',
    '>': 'RIGHT_ANGLE',
    '|': 'VERTICAL_BAR',
    '^': 'CARET',
    '&': 'AMPERSAND'
};

ExpressionTokenizer.prototype = new glsl.tokenizer.Base(ExpressionTokenizer, {ints: true});

function Tokenizer(source) {
    glsl.tokenizer.Base.prototype.init.call(this, source);
}

Tokenizer.keywords = {
    'define' : 'DEFINE',
    'undef': 'UNDEF',
    'if': 'IF',
    'ifdef': 'IFDEF',
    'ifndef': 'IFNDEF',
    'else': 'ELSE',
    'elif': 'ELIF',
    'endif': 'ENDIF',
    'error': 'ERROR',
    'pragma': 'PRAGMA',
    'extension': 'EXTENSION',
    'version': 'VERSION',
    'line': 'LINE'
};

Tokenizer.prototype = new glsl.tokenizer.Base(Tokenizer);

function Preprocessor(source, type, options) {
    this._source = '';
    this._type = type;

    this._defines = {
        '__VERSION__': '100',
        '__LINE__': '0',
        '__FILE__': '0',
        'GL_ES': '1'
    };

    if (typeof options === 'undefined') {
        options = {};
    }

    if (typeof options.defines !== 'undefined') {
        for (var k in options.defines) {
            this._defines[k] = options.defines[k];
        }
    }

    this._sourceMapping = [];
    this._sourceLocation = new glsl.source.Location(1, 1);

    var lines = source.split('\n');

    this._pstack = [{skip: false}];
    this._errors = [];
    this._tokens = [];
    this._extensions = [];

    var incomment = false;

    for (var i = 0; i < lines.length; i++)
    {
        var line = lines[i];
        var ptr = 0;

        if (incomment) {
            var opos = line.lastIndexOf('/*');
            var cpos = line.lastIndexOf('*/');

            if (cpos != -1 && cpos > opos) {
                incomment = false;
            }

            // Do not try to handle directives
            ptr = line.length;
        } else {
            while (ptr < line.length && (line[ptr] == ' ' || line[ptr] == '\t'))
            {
                ptr++;
            }
        }

        var p = this._pstack[this._pstack.length - 1];

        if (ptr < line.length && line[ptr] == '#') {
            var lsource = new glsl.source.Source(line.slice(ptr + 1));
            lsource.offset(new glsl.source.Location(i + 1, ptr + 2));

            var tokenizer = new Tokenizer(lsource);
            var tok = tokenizer.next();

            switch (tok.id) {
            case Tokenizer.T_ENDIF:
                this._endif(tok, tokenizer);
                break;
            case Tokenizer.T_ELSE:
                this._else(tok, tokenizer);
                break;
            case Tokenizer.T_ELIF:
                this._elif(tok, tokenizer);
                break;
            }

            if (tok.id == Tokenizer.T_ENDIF || tok.id == Tokenizer.T_ELSE || tok.id == Tokenizer.ELIF || p.skip) {
                continue;
            }

            switch (tok.id) {
            case Tokenizer.T_DEFINE:
                this._define(tok, tokenizer);
                break;
            case Tokenizer.T_UNDEF:
                this._undef(tok, tokenizer);
                break;
            case Tokenizer.T_IF:
                this._if(tok, tokenizer);
                break;
            case Tokenizer.T_IFDEF:
                this._ifdef(tok, tokenizer, false);
                break;
            case Tokenizer.T_IFNDEF:
                this._ifdef(tok, tokenizer, true);
                break;
            case Tokenizer.T_ERROR:
                this._error(tok.location, tokenizer.remainder().text);
                break;
            case Tokenizer.T_PRAGMA:
                break;
            case Tokenizer.T_EXTENSION:
                this._extensions.push(tokenizer.remainder().text.trim());
                break;
            case Tokenizer.T_VERSION:
                break;
            case Tokenizer.T_LINE:
                break;
            default:
                this._error(tok.location, 'expected preprocessor directive, but got ' + tokenizer.tokenName(tok.id) + ':' + tok.text);
                break;
            }
        } else if (!p.skip) {
            if (i != lines.length - 1) {
                line += '\n';
            }

            this._addSource(line, new glsl.source.Location(i + 1, 1));
        }

        var opos = line.lastIndexOf('/*');
        var cpos = line.lastIndexOf('*/');

        if (opos != -1 && opos > cpos) {
            incomment = true;
        }
    }

    this._sourceReader = new glsl.source.Source(this._source, this._type);
    this._sourceReader._sourceMap = this._sourceMap.bind(this);
}

Preprocessor.optionsFromContext = function(c) {
    var defines = {};

    var nmap = {
        'WEBGL_draw_buffers': 'GL_EXT_draw_buffers',
        'OES_standard_derivatives': 'GL_OES_standard_derivatives'
    };

    if (c !== null) {
        var exts = c.getSupportedExtensions();

        for (var i = 0; i < exts.length; i++) {
            var e = exts[i];

            defines[e] = '1';

            if (e in nmap) {
                defines[nmap[e]] = '1';
            }
        }
    }

    return {
        defines: defines
    };
};

Preprocessor.prototype.type = function() {
    return this._source.type();
};

Preprocessor.prototype.extensions = function() {
    return this._extensions.slice(0);
};

Preprocessor.prototype._sourceMap = function(range) {
    return new glsl.source.Range(this._sourceMapOne(range.start, false),
                                 this._sourceMapOne(range.end, true));
};

Preprocessor.prototype._sourceMapOne = function(loc, isend) {
    for (var i = 0; i < this._sourceMapping.length; i++) {
        var m = this._sourceMapping[i];

        if (m.current.start.compare(loc) > 0) {
            break;
        }

        if (isend && m.current.end.compare(loc) < 0) {
            continue;
        }

        if (!isend && m.current.end.compare(loc) <= 0) {
            continue;
        }

        if (m.macro) {
            return isend ? m.original.end.copy() : m.original.start.copy();
        }

        var mapped = m.original.start.copy();

        mapped.line += loc.line - m.current.start.line;

        if (loc.line == m.current.start.line) {
            mapped.column += loc.column - m.current.start.column;
        }

        return mapped;
    }

    return loc;
};

Preprocessor.prototype.eof = function() {
    return this._sourceReader.eof();
};

Preprocessor.prototype.skip = function(r) {
    this._sourceReader.skip(r);
};

Preprocessor.prototype.next = function(r) {
    return this._sourceReader.next(r);
};

Preprocessor.prototype.location = function() {
    return this._sourceReader.location();
};

Preprocessor.prototype.errors = function() {
    return this._errors;
};

Preprocessor.prototype._addSource = function(s, orig) {
    var expanded = this._expand(s, orig, this._sourceLocation);

    this._source += expanded.text;

    // Add source mapping
    for (var i = 0; i < expanded.mapping.length; i++) {
        this._sourceMapping.push(expanded.mapping[i]);

        if (i == expanded.mapping.length - 1) {
            this._sourceLocation = expanded.mapping[i].current.end.copy();
        }
    }
};

Preprocessor.prototype._expand = function(s, origloc, curloc) {
    // Expand any defines found in s
    var defre = [];

    var trackloc = (typeof origloc !== 'undefined');

    for (var d in this._defines) {
        defre.push(d);
    }

    defre = new RegExp('\\b' + glsl.tokenizer.regexChoices(defre) + '\\b', 'g');

    var smap = [];

    var ploc = origloc;
    var poff = 0;

    var pnewloc = curloc;

    var ret = s.replace(defre, (function(m, p1, offset) {
        var d = this._defines[m];

        if (trackloc) {
            var pt = s.slice(poff, offset);

            var nloc = ploc.advance(pt);
            var nnewloc = pnewloc.advance(pt);

            if (poff != offset) {
                smap.push({
                    current: new glsl.source.Range(pnewloc, nnewloc),
                    original: new glsl.source.Range(ploc, nloc),
                    macro: false
                });
            }

            ploc = nloc.advance(m);
            pnewloc = nnewloc.advance(d);

            poff = offset + m.length;

            smap.push({
                current: new glsl.source.Range(nnewloc, pnewloc),
                original: new glsl.source.Range(nloc, ploc),
                macro: true
            });
        }

        return d;
    }).bind(this));

    if (trackloc) {
        var pt = s.slice(poff);

        smap.push({
            current: new glsl.source.Range(pnewloc, pnewloc.advance(pt)),
            original: new glsl.source.Range(ploc, ploc.advance(pt)),
            macro: false
        });

        return {text: ret, mapping: smap};
    } else {
        return ret;
    }
};

Preprocessor.prototype._stripComments = function(s) {
    var cpos = s.indexOf('//');

    if (cpos != -1) {
        return s.slice(0, cpos);
    }

    return s;
};

Preprocessor.prototype._define = function(tok, tokenizer) {
    var def = tokenizer.next();

    if (def.id != Tokenizer.T_IDENTIFIER) {
        this._error(def.location, 'expected identifier, but got ' + tokenizer.tokenName(def.id) + ':' + def.text);
        return;
    }

    if (def.text.indexOf('__') === 0) {
        this._error(def.location, 'defines are not allowed to start with __');
        return;
    }

    if (def.text.indexOf('GL_') === 0) {
        this._error(def.location, 'defines are not allowed to start with GL_');
        return;
    }

    var rest = tokenizer.remainder();
    this._defines[def.text] = this._expand(this._stripComments(rest.text));
};

Preprocessor.prototype._undef = function(tok, tokenizer) {
    var def = tokenizer.next();

    if (def.id != Tokenizer.T_IDENTIFIER) {
        this._error(def.location, 'expected identifier, but got ' + tokenizer.tokenName(def.id) + ':' + def.text);
        return;
    }

    var next = tokenizer.next();

    if (next.id != Tokenizer.T_EOF) {
        this._error(next.location, 'unexpected input after defined, got ' + tokenizer.tokenName(next.id) + ':' + next.text);
    } else {
        delete this._defines[def.text];
    }
};

Preprocessor.prototype._makeExpressionTokenizer = function(tok, s) {
    var source = new glsl.source.Source(s);
    source.offset(tok.location.end);

    return new ExpressionTokenizer(source);
};

Preprocessor.prototype._if = function(tok, tokenizer) {
    var rest = tokenizer.remainder();

    var exprtok = this._makeExpressionTokenizer(tok, rest.text);
    var expr = this._parseExpression(exprtok, -1);

    if (expr === null) {
        return;
    }

    this._pstack.push({
        skip: !expr,
        condition: expr
    });
};

Preprocessor.prototype._ifdef = function(tok, tokenizer, negate) {
    var def = tokenizer.next();

    if (def.id != Tokenizer.T_IDENTIFIER) {
        this._error(def.location, 'expected identifier, but got ' + tokenizer.tokenName(def.id) + ':' + def.text);
        return;
    }

    var next = tokenizer.next();

    if (next.id != Tokenizer.T_EOF) {
        this._error(next.location, 'unexpected input after defined, got ' + tokenizer.tokenName(next.id) + ':' + next.text);
    } else {
        var skip = !(def.text in this._defines);

        if (negate) {
            skip = !skip;
        }

        this._pstack.push({
            skip: skip,
            condition: !skip
        });
    }
};

Preprocessor.prototype._else = function(tok) {
    if (this._pstack.length == 1) {
        this._error(tok.location, 'unexpected #else without opening #if, #ifdef, or #ifndef');
        return;
    }

    var p = this._pstack[this._pstack.length - 1];

    if (!p.condition) {
        p.skip = false;
        p.condition = true;
    } else {
        p.skip = true;
    }
};

Preprocessor.prototype._elif = function(tok, tokenizer) {
    if (this._pstack.length == 1) {
        this._error(tok.location, 'unexpected #elif without opening #if, #ifdef, or #ifndef');
        return;
    }

    var p = this._pstack[this._pstack.length - 1];

    if (p.condition) {
        p.skip = true;
        return;
    }

    var rest = tokenizer.remainder();
    var s = this._expand(this._stripComments(rest.text));
    var exprtok = this._makeExpressionTokenizer(tok, s);

    var expr = this._parseExpression(exprtok, -1);

    if (expr === null) {
        p.skip = true;
        return;
    }

    p.skip = !expr;
    p.condition = expr;
};

Preprocessor.prototype._endif = function(tok, tokenizer) {
    if (!tokenizer.eof()) {
        this._error(tok.location, 'unexpected input after #endif');
        return;
    }

    if (this._pstack.length == 1) {
        this._error(tok.location, 'unexpected #endif without opening #if, #ifdef, or #ifndef');
        return;
    }

    this._pstack.pop();
};

Preprocessor.prototype._parseExpressionPrimary = function(tokenizer) {
    var tok = tokenizer.next();

    switch (tok.id) {
    case ExpressionTokenizer.T_INTCONSTANT:
        return tok.value;
    case ExpressionTokenizer.T_IDENTIFIER:
        if (tok.text in this._defines) {
            return this._defines[tok.text];
        }

        return null;
    case ExpressionTokenizer.T_LEFT_PAREN:
        var ret = this._parseExpression(tokenizer);

        if (ret === null) {
            return null;
        }

        tok = tokenizer.next();

        if (tok.id != ExpressionTokenizer.T_RIGHT_PAREN) {
            // TODO: error
            return null;
        }

        return ret;
    case ExpressionTokenizer.T_DEFINED:
        var id = tokenizer.next();

        var expect = null;

        if (id.id == ExpressionTokenizer.T_LEFT_PAREN) {
            expect = ExpressionTokenizer.T_RIGHT_PAREN;
            id = tokenizer.next();
        }

        if (id.id != ExpressionTokenizer.T_IDENTIFIER) {
            // TODO: error
            return null;
        }

        if (expect) {
            var e = tokenizer.next();

            if (e.id != expect) {
                // TODO: error
                return null;
            }
        }

        return (id.text in this._defines);
    case ExpressionTokenizer.T_PLUS:
    case ExpressionTokenizer.T_DASH:
    case ExpressionTokenizer.T_TILDE:
    case ExpressionTokenizer.T_BANG:
        var ret = this._parseExpression(tokenizer, 2);

        if (ret === null) {
            return null;
        }

        switch (tok.id) {
            case ExpressionTokenizer.T_PLUS:
                return ret;
            case ExpressionTokenizer.T_DASH:
                return -ret;
            case ExpressionTokenizer.T_TILDE:
                return ~ret;
            case ExpressionTokenizer.T_BANG:
                return !ret;
        }

        break;
    }

    this._error(tok.location, 'expected expression, but got ' + ExpressionTokenizer.tokenName(tok.id) + ':' + tok.text);
    return null;
};

Preprocessor.prototype._parseExpressionBinop = function(tokenizer, p, lhs) {
    var tok = tokenizer.peek();

    var prec = 0;

    switch (tok.id) {
    case ExpressionTokenizer.T_STAR:
    case ExpressionTokenizer.T_SLASH:
    case ExpressionTokenizer.T_PERCENT:
        prec = 3;
        break;
    case ExpressionTokenizer.T_PLUS:
    case ExpressionTokenizer.T_DASH:
        prec = 4;
        break;
    case ExpressionTokenizer.T_LEFT_OP:
    case ExpressionTokenizer.T_RIGHT_OP:
        prec = 5;
        break;
    case ExpressionTokenizer.T_LEFT_ANGLE:
    case ExpressionTokenizer.T_RIGHT_ANGLE:
    case ExpressionTokenizer.T_LE_OP:
    case ExpressionTokenizer.T_GE_OP:
        prec = 6;
        break;
    case ExpressionTokenizer.T_EQ_OP:
    case ExpressionTokenizer.T_NE_OP:
        prec = 7;
        break;
    case ExpressionTokenizer.T_AMPERSAND:
        prec = 8;
        break;
    case ExpressionTokenizer.T_XOR_OP:
        prec = 9;
        break;
    case ExpressionTokenizer.T_VERTICAL_BAR:
        prec = 10;
        break;
    case ExpressionTokenizer.T_AND_OP:
        prec = 11;
        break;
    case ExpressionTokenizer.T_OR_OP:
        prec = 12;
        break;
    default:
        return null;
    }

    if (p !== -1 && prec >= p) {
        return null;
    }

    // Consume peeked token
    tokenizer.next();

    var rhs = this._parseExpression(tokenizer, prec);

    if (rhs === null) {
        return null;
    }

    switch (tok.id) {
    case ExpressionTokenizer.T_STAR:
        return lhs * rhs;
    case ExpressionTokenizer.T_SLASH:
        return lhs / rhs;
    case ExpressionTokenizer.T_PERCENT:
        return lhs % rhs;
    case ExpressionTokenizer.T_PLUS:
        return lhs + rhs;
    case ExpressionTokenizer.T_DASH:
        return lhs - rhs;
    case ExpressionTokenizer.T_LEFT_OP:
        return lhs << rhs;
    case ExpressionTokenizer.T_RIGHT_OP:
        return lhs >> rhs;
    case ExpressionTokenizer.T_LEFT_ANGLE:
        return lhs < rhs;
    case ExpressionTokenizer.T_RIGHT_ANGLE:
        return lhs > rhs;
    case ExpressionTokenizer.T_LE_OP:
        return lhs <= rhs;
    case ExpressionTokenizer.T_GE_OP:
        return lhs >= rhs;
    case ExpressionTokenizer.T_EQ_OP:
        return lhs == rhs;
    case ExpressionTokenizer.T_NE_OP:
        return lhs != rhs;
    case ExpressionTokenizer.T_AMPERSAND:
        return lhs & rhs;
    case ExpressionTokenizer.T_XOR_OP:
        return lhs ^ rhs;
    case ExpressionTokenizer.T_VERTICAL_BAR:
        return lhs | rhs;
    case ExpressionTokenizer.T_AND_OP:
        return lhs && rhs;
    case ExpressionTokenizer.T_OR_OP:
        return lhs || rhs;
    }

    return null;
};

Preprocessor.prototype._parseExpressionRhs = function(tokenizer, p, lhs) {
    return this._parseExpressionBinop(tokenizer, p, lhs);
};

Preprocessor.prototype._parseExpression = function(tokenizer, p) {
    var lhs = this._parseExpressionPrimary(tokenizer);

    if (lhs === null) {
        return null;
    }

    while (true) {
        var ret = this._parseExpressionRhs(tokenizer, p, lhs);

        if (ret === null) {
            return lhs;
        } else {
            lhs = ret;
        }
    }
};

Preprocessor.prototype._error = function(loc, text) {
    this._errors.push(new glsl.source.Error(loc, text));
};

Preprocessor.prototype.source = function() {
    return this._source;
};

exports.Preprocessor = Preprocessor;

// vi:ts=4:et

},{"./source":15,"./tokenizer":17}],15:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

var glsl = {
    tokenizer: require('./tokenizer')
};

function Location(line, column) {
    this.line = line;
    this.column = column;
}

Location.prototype.copy = function() {
    return new Location(this.line, this.column);
};

Location.prototype.toRange = function() {
    var rng = new Range(this, this);
    rng.end.column++;

    return rng;
};

Location.prototype.inspect = function() {
    return this.line + '.' + this.column;
};

Location.prototype.marshal = function() {
    return this.line + '.' + this.column;
};

Location.prototype.compare = function(loc) {
    if (this.line != loc.line) {
        return this.line < loc.line ? -1 : 1;
    }

    if (this.column != loc.column) {
        return this.column < loc.column ? -1 : 1;
    }

    return 0;
};

Location.prototype.advanceChars = function(n) {
    var ret = this.copy();
    ret.column += n;

    return ret;
};

Location.prototype.advance = function(s) {
    var li = -1;

    var ret = this.copy();

    for (var i = 0; i < s.length; i++) {
        if (s[i] == '\n') {
            li = i;
            ret.line++;
        }
    }

    if (li != -1) {
        ret.column = s.length - li;
    } else {
        ret.column += s.length;
    }

    return ret;
};

function BuiltinLocation() {
    Location.call(this, 0, 0);
}

BuiltinLocation.prototype = Object.create(Location.prototype);
BuiltinLocation.prototype.constructor = BuiltinLocation;

exports.BuiltinLocation = BuiltinLocation;

BuiltinLocation.prototype.inspect = function() {
    return '(builtin)';
};

BuiltinLocation.prototype.marshal = function() {
    return '(builtin)';
};

BuiltinLocation.prototype.copy = function() {
    return new BuiltinLocation();
};

function Range(start, end) {
    this.start = start.copy();
    this.end = end.copy();
}

Range.prototype.copy = function() {
    return new Range(this.start, this.end);
};

Range.prototype.inspect = function(depth) {
    return '(' + this.start.inspect(depth + 1) + '-' + this.end.inspect(depth + 1) + ')';
};

Range.prototype.marshal = function() {
    return '(' + this.start.marshal() + '-' + this.end.marshal() + ')';
};

Range.prototype.extend = function(loc) {
    var ret = this.copy();

    if (Location.prototype.isPrototypeOf(loc)) {
        loc = loc.toRange();
    }

    if (loc.start.compare(ret.start) < 0) {
        ret.start = loc.start.copy();
    }

    if (loc.end.compare(ret.end) > 0) {
        ret.end = loc.end.copy();
    }

    return ret;
};

Range.spans = function() {
    var locs = [];
    var args = Array.prototype.slice.call(arguments);

    while (args.length > 0) {
        var arg = args.pop();

        if (arg === null) {
            continue;
        }

        if (Range.prototype.isPrototypeOf(arg)) {
            locs.push(arg);
        } else if (Location.prototype.isPrototypeOf(arg)) {
            locs.push(arg.toRange());
        } else if (Array.prototype.isPrototypeOf(arg)) {
            args.concat(arg);
        } else if (typeof arg.location === 'function') {
            args.push(arg.location());
        } else if (typeof arg.location !== 'undefined') {
            args.push(arg.location);
        }
    }

    if (locs.length === 0) {
        return new Range(new Location(0, 0), new Location(0, 0));
    }

    var ret = locs[0].copy();

    for (var i = 1; i < locs.length; i++) {
        var loc = locs[i];

        if (loc.start.compare(ret.start) < 0) {
            ret.start = loc.start.copy();
        }

        if (loc.end.compare(ret.end) > 0) {
            ret.end = loc.end.copy();
        }
    }

    return ret;
};

function BuiltinRange() {
    Range.call(this, new BuiltinLocation(), new BuiltinLocation());
}

BuiltinRange.prototype = Object.create(Range.prototype);
BuiltinRange.prototype.constructor = BuiltinRange;

BuiltinRange.prototype.inspect = function() {
    return '(builtin)';
};

BuiltinRange.prototype.marshal = function() {
    return '(builtin)';
};

BuiltinRange.prototype.copy = function() {
    return new BuiltinRange();
};

exports.BuiltinRange = BuiltinRange;

function SourceError(loc, message) {
    this.location = loc.copy();
    this.message = message;

    this._stack = (new Error()).stack;
}

SourceError.prototype.formattedMessage = function() {
    var l = this.location.start.line;
    var c = this.location.start.column;

    var ret = l + '.' + c;

    if (this.location.end.line !== l || this.location.end.column !== c) {
        ret += '-' + this.location.end.line + '.' + this.location.end.column;
    }

    return ret + ': ' + this.message;
};

function Source(s, type) {
    this._source = s;
    this._remainder = this._source;
    this._location = new Location(1, 1);
    this._type = type;
}

Source.prototype.location = function() {
    return this._location;
};

Source.prototype.offset = function(loc) {
    this._location = loc.copy();
};

Source.prototype.eof = function() {
    return this._remainder.length === 0;
};

Source.prototype._sourceMap = function(loc) {
    return loc;
};

Source.prototype.skip = function(r) {
    this._next(r, false);
};

Source.prototype.source = function() {
    return this._source;
};

Source.prototype.next = function(r) {
    return this._next(r, true);
};

Source.prototype.type = function() {
    return this._type;
};

Source.prototype._next = function(r, tokenize) {
    var m = this._remainder.match(r);

    if (m && m.index === 0) {
        var l = m[0].length;

        var start = this._location.copy();

        this._remainder = this._remainder.slice(l);
        this._location = this._location.advance(m[0]);

        if (tokenize) {
            var rng = this._sourceMap(new Range(start, this._location));

            return new glsl.tokenizer.Token(0, m[0], rng);
        }
    }

    return null;
};

exports.Error = SourceError;
exports.Location = Location;
exports.Range = Range;
exports.Source = Source;

exports.VERTEX = 0;
exports.FRAGMENT = 1;

// vi:ts=4:et

},{"./tokenizer":17}],16:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

var glsl = {
    source: require('./source'),
    ast: require('./ast'),
    tokenizer: require('./tokenizer'),
    builtins: require('./builtins'),
};

var Tn = glsl.tokenizer.Tokenizer;

function Error(loc, message) {
    glsl.source.Error.call(this, loc, message);
}

Error.prototype = Object.create(glsl.source.Error.prototype);
Error.prototype.constructor = Error;

exports.Error = Error;

function Annotate(ast, opts) {
    (new Annotator(ast, opts)).annotate();
}

function Annotator(ast, opts) {
    this._ast = ast;

    if (typeof opts === 'undefined') {
        opts = {};
    }

    if (typeof opts.builtins !== 'undefined') {
        this._builtins = opts.builtins;
    } else {
        this._builtins = new glsl.builtins.Builtins(ast.type);
    }

    this._ast.functionProtos = [];
    this._ast.functionProtoMap = {};

    this._ast.functions = [];
    this._ast.functionMap = {};

    this._ast.uniforms = [];
    this._ast.uniformMap = {};

    this._ast.varyings = [];
    this._ast.varyingMap = {};

    this._scope = null;
    this._scopes = [];

    var bscope = this._pushScope({
        functionProtos: [],
        functionProtoMap: {}
    });

    bscope.marshal = function() {
        return '(builtin scope)';
    };

    // Push builtin types into the scope
    for (var i = 0; i < this._builtins.types.length; i++) {
        var btype = this._builtins.types[i];
        var t = btype.type.t.type;

        this._declareType(t);
    }

    // Push builtin functions into the scope
    for (var i = 0; i < this._builtins.functions.length; i++) {
        var f = this._builtins.functions[i];

        this._scope.functionProtoMap[f.header.signature()] = f;
        this._scope.functionProtos.push(f);
    }

    // Push builtin variables into the scope
    for (var i = 0; i < this._builtins.variables.length; i++) {
        var v = this._builtins.variables[i];
        this._declareVariable(v.names[0]);
    }

    // Push builtin precision into the scope
    for (var i = 0; i < this._builtins.precisions.length; i++) {
        var p = this._builtins.precisions[i];

        this._scope.precisions.push(p);
        this._scope.precisionMap[p.type.t.type.name] = p;
    }

    this._pushScope(ast);
    this._errors = [];
}

Annotator.prototype.annotate = function() {
    this._annotateNode(this._ast);
    this._ast._errors = this._ast._errors.concat(this._errors);
};

Annotator.prototype._isToplevelScope = function() {
    return this._scope == this._ast;
};

Annotator.prototype._pushScope = function(node) {
    if (!glsl.ast.StructDecl.prototype.isPrototypeOf(node)) {
        node.variables = [];
        node.variableMap = {};
    }

    node.types = [];
    node.typeMap = {};
    node.scopes = [];

    node.symbols = {};

    node.precisions = [];
    node.precisionMap = {};

    if (this._scope !== null) {
        this._scope.scopes.push(node);
    }

    node.parentScope = this._scope;

    this._scope = node;
    this._scopes.unshift(this._scope);

    return node;
};

Annotator.prototype._popScope = function() {
    var ret = this._scopes.shift();
    this._scope = this._scopes[0];

    return ret;
};

Annotator.prototype._annotateNode = function(node) {
    if (!node) {
        return;
    }

    var fn = '_annotate' + node.nodeName;

    if (typeof this[fn] !== 'function') {
        throw new global.Error('no annotator available for ' + node.nodeName);
    }

    node.t = {
        type: null
    };

    return this[fn](node);
};

Annotator.prototype._annotateParser = function(node) {
    for (var i = 0; i < node.body.length; i++) {
        this._annotateNode(node.body[i]);
    }
};

Annotator.prototype._lookup = function(name, mapname) {
    var scope = this._scope;

    while (scope !== null) {
        if (typeof scope[mapname] !== 'undefined' && name in scope[mapname]) {
            return scope[mapname][name];
        }

        scope = scope.parentScope;
    }

    return null;
};

Annotator.prototype._lookupType = function(name) {
    return this._lookup(name, 'typeMap');
};

Annotator.prototype._lookupSymbol = function(name) {
    return this._lookup(name, 'symbols');
};

Annotator.prototype._lookupFunction = function(name) {
    return this._lookup(name, 'functionMap');
};

Annotator.prototype._lookupFunctionProto = function(name) {
    return this._lookup(name, 'functionProtoMap');
};

Annotator.prototype._lookupFunctionOrProto = function(name) {
    var f = this._lookupFunction(name);

    if (f !== null) {
        return f;
    }

    return this._lookupFunctionProto(name);
};

Annotator.prototype._declareType = function(type) {
    this._scope.types.push(type);
    this._scope.typeMap[type.name] = type;
    this._scope.symbols[type.name] = type;
};

Annotator.prototype._declareVariable = function(node) {
    this._scope.variableMap[node.name.text] = node;
    this._scope.variables.push(node);

    if (node.type.isUniform() && this._isToplevelScope()) {
        this._scope.uniforms.push(node);
        this._scope.uniformMap[node.name.text] = node;
    } else if (node.type.isVarying()) {
        this._scope.varyings.push(node);
        this._scope.varyingMap[node.name.text] = node;
    }

    this._scope.symbols[node.name.text] = node;
};

Annotator.prototype._lookupOrDeclareType = function(type) {
    var tp = this._lookupType(type.name);

    if (tp === null) {
        this._declareType(type);
        return type;
    }

    return tp;
};

Annotator.prototype._annotateTypeRef = function(type) {
    if (type.incomplete) {
        return;
    }

    if (type.decl !== null) {
        this._annotateNode(type.decl);

        type.t.type = type.decl.t.type;
    } else {
        if (type.isPrimitive) {
            type.t.type = this._builtins.typeMap[type.token.id].type.t.type;
        } else {
            type.t.type = this._lookupType(type.token.text);
        }
    }

    if (type.t.type === null) {
        this._error(type.location(), 'unknown type ' + type.token.text);
    }
};

Annotator.prototype._annotateArray = function(node, elementType) {
    if (node.isArray) {
        if (this._resolveArraySize(node)) {
            node.t.type = this._lookupOrDeclareType(new glsl.builtins.ArrayType(elementType, node.arraySize.t.constValue));
        }
    }
};

Annotator.prototype._annotateNamed = function(node) {
    this._annotateNode(node.initialValue);

    if (!node.isArray) {
        node.t.type = node.type.t.type;
    } else {
        this._annotateArray(node, node.type.t.type);
    }

    if (node.t.type !== null) {
        if (node.type.isAttribute()) {
            if (node.t.type.isComposite) {
                this._error(node.location(), 'structures cannot be attributes');
            } else if (node.t.type.isArray) {
                this._error(node.location(), 'arrays cannot be attributes');
            }
        }

        if (node.type.isVarying()) {
            if (node.t.type.isComposite) {
                this._error(node.location(), 'structures cannot be varying');
            }
        }
    }

    if (node.type.isAttribute()) {
        if (this._ast.type != glsl.source.VERTEX) {
            this._error(node.location(), 'attributes can only be declared in vertex shaders');
        }

        if (!this._isToplevelScope()) {
            this._error(node.location(), 'attributes can only be declared globally');
        }

        if (node.initialValue !== null) {
            this._error(node.initialValue.location(), 'attributes cannot have an initial value');
        }
    }

    if (node.type.isUniform()) {
        if (!this._isToplevelScope() ) {
            this._error(node.location(), 'uniforms can only be declared globally');
        }

        if (node.initialValue !== null) {
            this._error(node.initialValue.location(), 'uniforms cannot have an initial value');
        }
    }

    if (node.type.isVarying()) {
        if (!this._isToplevelScope()) {
            this._error(node.location(), 'varyings can only be declared globally');
        }

        if (node.initialValue !== null) {
            this._error(node.initialValue.location(), 'varyings cannot have an initial value');
        }
    }

    if (node.type.isConst()) {
        if (node.isArray) {
            this._error(node.location(), 'arrays cannot be declared as const');
        } else if (node.t.type.isComposite && node.t.type.hasArrayField) {
            this._error(node.location(), 'cannot declare a struct containing an array as const');
        }

        if (node.initialValue !== null) {
            if (!node.initialValue.t.isConstExpression) {
                this._error(node.initialValue.location(), 'expected constant initial value expression');
            } else {
                node.t.isConstExpression = true;
                node.t.constValue = node.initialValue.t.constValue;
            }
        } else {
            this._error(node.location(), 'missing constant value initialization');

            node.t.isConstExpression = true;
            node.t.constValue = node.t.type.zero;
        }
    }
};

Annotator.prototype._annotateParamDecl = function(node) {
    this._annotateNode(node.type);

    node.t.users = [];

    if (!node.isArray) {
        node.t.type = node.type.t.type;
    } else {
        this._annotateArray(node, node.type.t.type);
    }
};

Annotator.prototype._annotateVariableDecl = function(node) {
    this._annotateNode(node.type);

    for (var i = 0; i < node.names.length; i++) {
        var name = node.names[i];

        this._annotateNode(name);
        name.t.users = [];

        // Check if variable with the same name is already declared in this
        // scope
        if (name.name !== null && name.name.text in this._scope.symbols) {
            var sym = this._scope.symbols[name.name.text];

            if (glsl.ast.Named.prototype.isPrototypeOf(sym) && glsl.ast.VariableDecl.prototype.isPrototypeOf(sym.decl)) {
                this._error(name.location(), 'the variable \'' + name.name.text + '\' has already been declared in this scope, previous declaration was at ' + sym.location().inspect());
                continue;
            } else {
                this._error(name.location(), 'a ' + this._errorSymbolTypeName(sym) + ' \'' + name.name.text + '\' has already been declared in this scope, previous declaration was at ' + sym.location().inspect());
            }
        }

        // Declare variable
        this._declareVariable(name);

        if (node.type !== null && node.type.t.type !== null &&
            name.initialValue !== null && name.initialValue.t.type !== null) {
            if (node.type.t.type !== name.initialValue.t.type) {
                this._error(name.location(), 'cannot assign value of type ' + name.initialValue.t.type.name + ' to variable of type ' + node.type.t.type.name);
            }
        }
    }
};

Annotator.prototype._annotateTypeDecl = function(node) {
    this._annotateNode(node.type);
};

Annotator.prototype._annotateStructDecl = function(node) {
    var type;

    if (glsl.ast.StructDecl.prototype.isPrototypeOf(this._scope)) {
        this._error(node.location(), 'nested struct declarations are not allowed');
    }

    if (node.name !== null) {
        var tp = this._lookupSymbol(node.name.text);

        if (tp !== null) {
            this._error(node.location(), 'a type named ' + node.name.text + ' has already been declared, previous declaration was at ' + tp.location().inspect());
            return;
        }

        type = new glsl.builtins.UserType(node.name.text, node);
        this._declareType(type);
    } else {
        // new anonymous user type
        type = new glsl.builtins.UserType(null, node);
    }

    node.t.type = type;
    this._pushScope(node);

    var fieldMap = {};

    for (var i = 0; i < node.fields.length; i++) {
        var field = node.fields[i];

        this._annotateNode(field.type);

        for (var j = 0; j < field.names.length; j++) {
            var name = field.names[j];

            this._annotateNode(name);

            if (name.type.t.type) {
                var f = node.t.type.declareField(name.name.text, name.type.t.type);
                f.decl = name;

                if (name.name.text in fieldMap) {
                    this._error(name.location(), 'a field named ' + name.name.text + ' already exists, previous declaration was at ' + fieldMap[name.name.text].location().inspect());
                }

                fieldMap[name.name.text] = field;
            }
        }
    }

    this._popScope(node);
};

Annotator.prototype._resolveArraySize = function(node) {
    if (!node.isArray) {
        return false;
    }

    this._annotateNode(node.arraySize);

    if (!node.arraySize.t.isConstExpression) {
        this._error(node.arraySize.location(), 'expected constant expression for array size');
        return false;
    } else if (node.arraySize.t.type != this._builtins.Int) {
        var n;

        if (node.arraySize.t.type == this._builtins.Float) {
            n = 'float';
        } else if (node.arraySize.t.type == this._builtins.Bool) {
            n = 'boolean';
        } else {
            n = 'user type';
        }

        this._error(node.arraySize.location(), 'expected constant integer expression for array size, but got ' + n);
        return false;
    } else if (node.arraySize.constValue <= 0) {
        this._error(node.arraySize.location(), 'array size must be larger or equal to 1, but got ' + node.arraySize.constValue);
    }

    return true;
};

Annotator.prototype._annotateFunctionHeader = function(node) {
    // return type
    this._annotateNode(node.type);

    if (node.type.t.type !== null && node.type.t.type.isArray) {
        this._error(node.type.location(), 'array return values are not allowed');
    }

    node.t.type = node.type.t.type;

    for (var i = 0; i < node.parameters.length; i++) {
        this._annotateNode(node.parameters[i]);
    }
};

Annotator.prototype._annotateFunctionProto = function(node) {
    if (!this._isToplevelScope()) {
        this._error(node.location(), 'nested function prototypes are not allowed');
        return;
    }

    var id = node.header.signature();
    var name = node.header.name;

    if (name.text === 'main') {
        this._error(name.location, 'cannot overload main');
    }

    var prev = this._lookupFunction(id);

    if (prev !== null) {
        this._error(name.location, 'the function prototype ' + name.text + ' appears after its definition at ' + prev.name.location);
        return;
    } else if (name.text in this._scope.symbols) {
        var sym = this._scope.symbols[name.text];

        this._error(name.location, 'a ' + this._errorSymbolTypeName(sym) + ' ' + name.text + ' has already been declared, previous declaration was at ' + sym.location());
        return;
    }

    this._annotateNode(node.header);

    node.t.type = node.header.t.type;

    this._scope.functionProtos.push(node);
    this._scope.functionProtoMap[id] = node;
};

Annotator.prototype._qualifiersToString = function(qualifiers) {
    var ret = '';

    for (var i = 0; i < qualifiers.length; i++) {
        var q = qualifiers[i];

        if (i !== 0) {
            ret += ' ';
        }

        ret += q.token.text;
    }

    return ret;
};

Annotator.prototype._matchingQualifiers = function(a, b) {
    if (a.length != b.length) {
        return false;
    }

    var cpa = a.slice();
    var cpb = b.slice();

    while (cpa.length > 0) {
        var i = cpb.indexOf(cpa.pop());

        if (i !== -1) {
            cpb.splice(i, 1);
        } else {
            return false;
        }
    }

    if (cpb.length !== 0) {
        return false;
    }

    return true;
};

Annotator.prototype._annotateFunctionDef = function(node) {
    if (!this._isToplevelScope()) {
        this._error(node.location(), 'nested function definitions are not allowed');
        return;
    }

    var id = node.header.signature();
    var name = node.header.name;

    var prev = this._lookupFunction(id);

    if (prev !== null) {
        this._error(name.location, 'the function ' + name.text + ' is already defined, previous definition was at ' + prev.name.location.inspect());
        return;
    } else if (name.text in this._scope.symbols) {
        var sym = this._scope.symbols[name.text];

        this._error(name.location, 'a ' + this._errorSymbolTypeName(sym) + ' ' + name.text + ' has already been declared, previous declaration was at ' + sym.location().inspect());
        return;
    }

    this._annotateNode(node.header);
    node.t.type = node.header.t.type;

    var proto = this._lookupFunctionProto(id);

    if (proto !== null) {
        if (proto.header.type.type != node.header.type.type) {
            this._error(node.header.type.location(), 'the return type ' + node.header.type.token.text + ' of the function definition of ' + name.text + ' does not correspond to the return type ' + proto.header.type.token.text + ' of its prototype declared at ' + proto.location());
        }

        if (node.header.parameters.length == proto.header.parameters.length) {
            for (var i = 0; i < node.header.parameters.length; i++) {
                var param1 = node.header.parameters[i];
                var param2 = proto.header.parameters[i];

                if (!this._matchingQualifiers(param1.type.qualifiers, param2.type.qualifiers)) {
                    this._error(param1.location(), 'the type qualifiers of parameter ' + param1.name.text + ' (' + this._qualifiersToString(param1.type.qualifiers) + ') of the function definition of ' + name.text + ' do not correspond to the parameter type qualifiers ' + this._qualifiersToString(param2.type.qualifiers) + ' of its prototype declared at ' + param2.location());
                }
            }
        }
    } else if (node.header.name.text === 'main') {
        this._error(node.header.name.location, 'invalid definition of main, expected void main()');
    }

    this._scope.functions.push(node);
    this._scope.functionMap[id] = node;

    this._pushScope(node);

    for (var i = 0; i < node.header.parameters.length; i++) {
        var param = node.header.parameters[i];

        if (i === 0 && param.type.token.id == Tn.T_VOID) {
            continue;
        }

        this._scope.variables.push(param);

        if (param.name !== null) {
            this._scope.variableMap[param.name.text] = param;

            this._scope.symbols[param.name.text] = param;
        }
    }

    this._annotateNode(node.body);

    this._popScope();
};

Annotator.prototype._annotateBlock = function(node) {
    if (node.newScope) {
        this._pushScope(node);
    }

    for (var i = 0; i < node.body.length; i++) {
        var item = node.body[i];

        this._annotateNode(item);
    }

    if (node.newScope) {
        this._popScope();
    }
};

Annotator.prototype._annotatePrecisionStmt = function(node) {
    this._annotateNode(node.type);

    if (node.type === null || node.type.t.type === null) {
        return;
    }

    var tp = node.type.t.type;

    var allowed = [
        this._builtins.Int,
        this._builtins.Float,
        this._builtins.Sampler2D,
        this._builtins.SamplerCube
    ];

    if (allowed.indexOf(tp) == -1) {
        this._error(node.location(), 'precision can only be set for int, float and sampler types');
    }

    this._scope.precisions.push(node);
    this._scope.precisionMap[tp.name] = node;
};

Annotator.prototype._errorSymbolTypeName = function(node) {
    if (glsl.ast.Named.prototype.isPrototypeOf(node)) {
        return this._errorSymbolTypeName(node.decl);
    }

    var map = [
        [glsl.ast.FunctionDef, 'function definition'],
        [glsl.ast.FunctionProto, 'function prototype'],
        [glsl.ast.StructDecl, 'struct'],
        [glsl.ast.VariableDecl, 'variable'],
    ];

    for (var i = 0; i < map.length; i++) {
        var item = map[i];

        if (item[0].prototype.isPrototypeOf(node)) {
            return item[1];
        }
    }

    return node.nodeName;
};

Annotator.prototype._annotateInvariantDecl = function(node) {
    for (var i = 0; i < node.names.length; i++) {
        var name = node.names[i];

        var symbol = this._lookupSymbol(name.text);

        if (symbol === null) {
            this._error(name.location, 'cannot make unknown variable ' + name.text + ' invariant');
        } else if (!glsl.ast.Named.prototype.isPrototypeOf(symbol) ||
                   !glsl.ast.VariableDecl.prototype.isPrototypeOf(symbol.decl)) {
            var n = this._errorSymbolTypeName(symbol);

            this._error(name.location, 'cannot make the ' + n + ' ' + name.text + ' invariant');
        }
    }
};

Annotator.prototype._annotateExpressionStmt = function(node) {
    this._annotateNode(node.expression);
};

Annotator.prototype._initExpr = function(node) {
    node.t.isConstExpression = false;
    node.t.constValue = null;
};

Annotator.prototype._annotateConstantExpr = function(node) {
    this._initExpr(node);

    node.t.isConstExpression = true;
    node.t.constValue = node.token.value;

    switch (node.token.id) {
    case Tn.T_INTCONSTANT:
        node.t.type = this._builtins.Int;
        break;
    case Tn.T_FLOATCONSTANT:
        node.t.type = this._builtins.Float;
        break;
    case Tn.T_BOOLCONSTANT:
        node.t.type = this._builtins.Bool;
        break;
    }
};

Annotator.prototype._annotateFunctionCallExpr = function(node) {
    this._initExpr(node);

    var argnames = [];

    node.t.decl = null;
    node.t.isConstructor = false;

    var isok = true;

    for (var i = 0; i < node.arguments.length; i++) {
        var arg = node.arguments[i];

        this._annotateNode(arg);

        if (arg.t.type === null) {
            isok = false;
            continue;
        }

        if (i === 0 && arg.t.type == this._builtins.Void) {
            continue;
        }

        argnames.push(arg.t.type.name);
    }

    if (!isok) {
        return;
    }

    var tp = this._lookupType(node.name.text);

    if (tp !== null) {
        node.t.type = tp;
        node.t.isConstructor = true;

        if (tp.isPrimitive) {
            if (tp.isScalar) {
                if (node.arguments.length != 1) {
                    this._error(node.location(), 'constructor of type ' + tp.name + ' requires exactly 1 argument, ' + node.arguments.length + ' given');
                } else {
                    var nt = node.arguments[0].t;

                    if (!nt.type.isPrimitive) {
                        this._error(node.location, 'constructor of type ' + tp.name + ' cannot be called with type ' + nt.type.name);
                    } else if (nt.isConstExpression) {
                        node.t.isConstExpression = true;

                        if (nt.type.isScalar) {
                            node.t.constValue = nt.constValue;
                        } else {
                            node.t.constValue = nt.constValue[0];
                        }
                    }
                }
            } else if (tp.isVec || tp.isMat) {
                if (node.arguments.length == 1) {
                    var arg0 = node.arguments[0].t;

                    if (arg0.type.isScalar && arg0.isConstExpression) {
                        node.t.isConstExpression = true;
                        node.t.constValue = [];

                        for (var i = 0; i < tp.length; i++) {
                            if (tp.isVec) {
                                node.t.constValue.push(arg0.constValue);
                            } else {
                                var col = [];

                                for (var j = 0; j < tp.length; j++) {
                                    if (j == i) {
                                        col.push(arg0.constValue);
                                    } else {
                                        col.push(0);
                                    }
                                }

                                node.t.constValue.push(col);
                            }
                        }
                    } else if (!arg0.type.isScalar) {
                        if (arg0.type.isVec != tp.isVec || arg0.type.isMat != tp.isMat) {
                            this._error(node.location(), 'cannot call constructor of type ' + tp.name + ' with argument of type ' + arg0.type.name);
                        } else if (arg0.isConstExpression) {
                            node.t.isConstExpression = true;
                            node.t.constValue = [];

                            for (var i = 0; i < tp.length; i++) {
                                if (tp.isVec) {
                                    if (i >= arg0.type.length) {
                                        node.t.constValue.push(0);
                                    } else {
                                        node.t.constValue.push(arg0.constValue[i]);
                                    }
                                } else {
                                    var col = [];

                                    for (var j = 0; j < tp.length; j++) {
                                        if (i >= arg0.type.length || j >= arg0.type.length) {
                                            col.push(i == j ? 1 : 0);
                                        } else {
                                            col.push(arg0.constValue[i][j]);
                                        }
                                    }

                                    node.t.constValue.push(col);
                                }
                            }
                        }
                    }
                } else if (node.arguments.length > 1) {
                    var val = [];
                    var mval = [];

                    var numel = 0;
                    var numex;

                    if (tp.isMat) {
                        numex = tp.length * tp.length;
                    } else {
                        numex = tp.length;
                    }

                    node.t.isConstExpression = true;

                    for (var i = 0; i < node.arguments.length; i++) {
                        var arg = node.arguments[i];

                        if (tp.isMat && arg.t.type.isMat) {
                            this._error(arg.location(), 'cannot construct matrix with intermixed matrix argument');
                            return;
                        }

                        if (!arg.t.type.isPrimitive) {
                            this._error(arg.location(), 'cannot use value of type ' + arg.t.type.name + ' to construct value of type ' + tp.name);
                            return;
                        }

                        if (numel + arg.t.type.length > numex) {
                            this._error(arg.location(), 'too many values to construct value of type ' + tp.name);
                            return;
                        }

                        numel += arg.t.type.length;

                        if (arg.t.isConstExpression) {
                            var v = arg.t.constValue;

                            if (arg.t.type.isScalar) {
                                v = [v];
                            }

                            for (var j = 0; j < v.length; j++) {
                                if (val.length == tp.length && tp.isMat) {
                                    mval.push(val);
                                    val = [];
                                }

                                val.push(v[j]);
                            }
                        } else {
                            node.t.isConstExpression = false;

                        }
                    }

                    if (tp.isMat) {
                        mval.push(val);
                    }

                    if (numel != numex) {
                        this._error(node.location(), 'not enough values to fully construct type ' + tp.name + ' (got ' + numel + ', but expected ' + numex + ' values)');
                        return;
                    }

                    if (node.t.isConstExpression) {
                        if (tp.isMat) {
                            node.t.constValue = mval;
                        } else {
                            node.t.constValue = val;
                        }
                    }
                } else {
                    var numex = 1;

                    if (tp.isMat) {
                        numex = tp.length * tp.length;
                    } else if (tp.isVec) {
                        numex = tp.length;
                    }

                    this._error(node.location(), 'not enough values to fully construct type ' + tp.name + ' (got 0, but expected ' + numex + ')');

                    node.t.isConstExpression = true;
                    node.t.constValue = node.t.type.zero;
                }
            }
        } else {
            // structures
            if (node.arguments.length != tp.fields.length) {
                this._error(node.location(), 'expected ' + tp.fields.length + ' arguments, but got ' + node.arguments.length);
                return;
            }

            node.t.isConstExpression = true;
            var val = {};

            for (var i = 0; i < node.arguments.length; i++) {
                var arg = node.arguments[i];
                var field = tp.fields[i];

                if (arg.t.type != field.type) {
                    this._error(arg.location(), 'cannot initialize ' + tp.name + '.' + field.name + ' with type ' + field.type.name + ' from argument of type ' + arg.t.type.name);
                    continue;
                } else if (arg.t.isConstExpression) {
                    val[field.name] = arg.t.constValue;
                    node.t.isConstExpression = true;
                }
            }

            if (node.t.isConstExpression) {
                node.t.constValue = val;
            }
        }

        return;
    }

    var sig = glsl.ast.FunctionHeader.signatureFromNames(node.name.text, argnames);
    var f = this._lookupFunctionOrProto(sig);

    if (f === null) {
        this._error(node.location(), 'could not find function matching signature ' + sig);
        return;
    }

    if (glsl.ast.FunctionProto.prototype.isPrototypeOf(f) && f.isBuiltin && f.evaluate !== null) {
        var cargs = [];

        for (var i = 0; i < node.arguments.length; i++) {
            var arg = node.arguments[i];

            if (arg.t.isConstExpression) {
                cargs.push(arg.t.constValue);
            } else {
                cargs = null;
                break;
            }
        }

        if (cargs !== null) {
            node.t.isConstExpression = true;
            node.t.constValue = f.evaluate.apply(this, cargs);
        }
    }

    node.t.type = f.header.type.t.type;
    node.t.decl = f;
};

Annotator.prototype._annotateVariableExpr = function(node) {
    this._initExpr(node);

    var sym = this._lookupSymbol(node.name.text);

    node.t.decl = null;

    if (sym === null) {
        this._error(node.location(), 'undefined variable ' + node.name.text);
    } else if ((glsl.ast.Named.prototype.isPrototypeOf(sym) && glsl.ast.VariableDecl.prototype.isPrototypeOf(sym.decl)) ||
               glsl.ast.ParamDecl.prototype.isPrototypeOf(sym)) {
        node.t.decl = sym;
        node.t.type = sym.t.type;

        sym.t.users.push(node);

        if (glsl.ast.Named.prototype.isPrototypeOf(sym) && sym.t.isConstExpression) {
            node.t.isConstExpression = true;
            node.t.constValue = sym.t.constValue;
        }
    } else {
        this._error(node.location(), 'expected a variable for ' + node.name.text + ' but got a ' + this._errorSymbolTypeName(sym));
    }
};

Annotator.prototype._validateLvalue = function(node) {
    if (node.t.type === null) {
        return false;
    }

    switch (Object.getPrototypeOf(node)) {
    case glsl.ast.GroupExpr.prototype:
        return this._validateLvalue(node.expression);
    case glsl.ast.VariableExpr.prototype:
        if (node.t.decl.type.isUniform()) {
            this._error(node.location(), 'cannot assign to uniform value');
            return false;
        } else if (node.t.decl.type.isConst()) {
            this._error(node.location(), 'cannot assign to const value');
        }

        return true;
    case glsl.ast.FieldSelectionExpr.prototype:
        if (!this._validateLvalue(node.expression)) {
            return false;
        }

        if (node.expression.t.type.isVec) {
            // check for repeated values in the swizzle
            var chars = node.selector.text.split('');
            chars.sort();
            var found = null;

            for (var i = 0; i < chars.length - 1; i++) {
                if (chars[i] == chars[i + 1]) {
                    found = chars[i];
                    break;
                }
            }

            if (found !== null) {
                var first = node.selector.text.indexOf(found);
                var second = node.selector.text.indexOf(found, first + 1);

                this._error(node.selector.location().advanceChars(second), 'cannot assign to repeated swizzle');
                return false;
            }
        }

        return true;
    case glsl.ast.IndexExpr.prototype:
        if (!this._validateLvalue(node.expression)) {
            return false;
        }

        return true;
    default:
        this._error(node.location(), 'cannot assign to expression');
        return false;
    }
};

Annotator.prototype._annotateAssignmentExpr = function(node) {
    this._initExpr(node);

    this._annotateNode(node.lhs);
    this._annotateNode(node.rhs);

    node.t.type = node.lhs.t.type;

    if (node.lhs.t.type !== null && node.rhs.t.type !== null) {
        var binop = null;

        switch (node.op.id) {
        case Tn.T_MUL_ASSIGN:
            binop = Tn.T_STAR;
            break;
        case Tn.T_DIV_ASSIGN:
            binop = Tn.T_SLASH;
            break;
        case Tn.T_ADD_ASSIGN:
            binop = Tn.T_PLUS;
            break;
        case Tn.T_SUB_ASSIGN:
            binop = Tn.T_DASH;
            break;
        }

        var rettype = node.rhs.t.type;

        if (binop !== null) {
            var sig = Tn.tokenName(binop) + '(' + node.lhs.t.type.name + ',' + node.rhs.t.type.name + ')';

            if (!(sig in this._builtins.operatorMap)) {
                this._error(node.location(), 'cannot use the operator \'' + Tn.tokenName(binop) + '\' on types ' + node.lhs.t.type.name + ' and ' + node.rhs.t.type.name);
            } else {
                var oper = this._builtins.operatorMap[sig];
                rettype = oper.ret;
            }
        }

        if (node.lhs.t.type != rettype) {
            this._error(node.lhs.location().extend(node.op.location), 'cannot assign expression of type ' + node.rhs.t.type.name + ' to a value of type ' + node.lhs.t.type.name);
        }
    }

    if (glsl.ast.VariableExpr.prototype.isPrototypeOf(node.lhs) && node.lhs.t.type !== null && node.lhs.t.type.isArray) {
        this._error(node.lhs.location(), 'cannot assign to array');
    }

    this._validateLvalue(node.lhs);
};

Annotator.prototype._annotateBinOpExpr = function(node) {
    this._initExpr(node);

    this._annotateNode(node.lhs);
    this._annotateNode(node.rhs);

    // Make some guess if lhs or rhs could not be type checked
    if (node.lhs.t.type === null) {
        node.t.type = node.rhs.t.type;
    } else if (node.rhs.t.type === null) {
        node.t.type = node.lhs.t.type;
    } else if (node.lhs.t.type !== null && node.rhs.t.type !== null) {
        if (node.op.id == Tn.T_EQ_OP || node.op.id == Tn.T_NE_OP) {
            if (node.lhs.t.type == node.rhs.t.type) {
                if (node.lhs.t.type.isComposite && node.lhs.t.type.hasArrayField) {
                    this._error(node.op.location, 'cannot compare structures with array fields');
                } else if (node.lhs.t.type.isComposite && node.lhs.t.type.hasSamplerField) {
                    this._error(node.op.location, 'cannot compare structures with sampler fields');
                } else if (node.lhs.t.type.isArray) {
                    this._error(node.op.location, 'cannot compare arrays');
                } else if (node.lhs.t.type.isSampler) {
                    this._error(node.op.location, 'cannot compare samplers');
                }

                node.t.type = this._builtins.Bool;
                return;
            }
        }

        var sig = node.op.text + '(' + node.lhs.t.type.name + ',' + node.rhs.t.type.name + ')';

        if (sig in this._builtins.operatorMap) {
            var op = this._builtins.operatorMap[sig];
            node.t.type = op.ret;

            if (node.lhs.t.isConstExpression && node.rhs.t.isConstExpression) {
                node.t.isConstExpression = true;
                node.t.constValue = op.evaluate(node.lhs.t.constValue, node.rhs.t.constValue);
            }
        } else {
            this._error(node.location(), 'cannot use the \'' + node.op.text + '\' operator on types ' + node.lhs.t.type.name + ' and ' + node.rhs.t.type.name);
        }
    }
};

Annotator.prototype._annotateUnaryOpExpr = function(node) {
    this._initExpr(node);

    this._annotateNode(node.expression);

    if (node.expression.t.type === null) {
        return;
    }

    var sig = node.op.text + '(' + node.expression.t.type.name + ')';

    if (sig in this._builtins.operatorMap) {
        var op = this._builtins.operatorMap[sig];
        node.t.type = op.ret;

        if (node.expression.t.isConstExpression) {
            node.t.isConstExpression = true;

            if (glsl.ast.UnaryPostfixOpExpr.prototype.isPrototypeOf(node)) {
                node.t.constValue = node.expression.t.constValue;
            } else {
                node.t.constValue = op.evaluate(node.expression.t.constValue);
            }
        }
    } else {
        this._error(node.location(), 'cannot use the \'' + node.op.text + '\' operator on type ' + node.expression.t.type.name);
    }
};

Annotator.prototype._annotateUnaryPostfixOpExpr = function(node) {
    this._annotateUnaryOpExpr(node);
};

Annotator.prototype._annotateTernaryExpr = function(node) {
    this._initExpr(node);

    this._annotateNode(node.condition);
    this._annotateNode(node.trueExpression);
    this._annotateNode(node.falseExpression);

    if (node.condition.t.type !== null && node.condition.t.type != this._builtins.Bool) {
        this._error(node.condition.location(), 'the condition of a ternary conditional expression must be of type bool, not ' + node.condition.t.type.name);
    }

    if ((node.trueExpression === null || node.trueExpression.t.type === null) &&
        (node.falseExpression === null || node.falseExpression.t.type === null)) {
        return;
    }

    if (node.trueExpression === null || node.trueExpression.t.type === null) {
        node.t.type = node.falseExpression.t.type;
    } else if (node.falseExpression === null || node.falseExpression.t.type === null) {
        node.t.type = node.trueExpression.t.type;
    } else if (node.trueExpression.t.type != node.falseExpression.t.type) {
        this._error(node.trueExpression.location().extend(node.falseExpression.location()),
                    'the true expression and false expression must be of the same type, but got ' + node.trueExpression.t.type.name + ' and ' + node.falseExpression.t.type.name);
        node.t.type = node.trueExpression.t.type;
    } else {
        node.t.type = node.trueExpression.t.type;
    }

    if (node.condition.t.isConstExpression) {
        if (node.condition.t.constValue) {
            if (node.trueExpression.t.isConstExpression) {
                node.t.isConstExpression = true;
                node.t.constValue = node.trueExpression.t.constValue;
            }
        } else {
            if (node.falseExpression.t.isConstExpression) {
                node.t.isConstExpression = true;
                node.t.constValue = node.falseExpression.t.constValue;
            }
        }
    }
};

Annotator.prototype._annotateIndexExpr = function(node) {
    this._initExpr(node);

    this._annotateNode(node.expression);
    this._annotateNode(node.index);

    var et = node.expression.t.type;

    if (et !== null) {
        if ((!et.isArray && !et.isPrimitive) || et.length <= 1) {
            this._error(node.expression.location(), 'only vectors, matrices and arrays can be indexed, not ' + et.name);
        } else if (node.index.t.type !== null && node.index.t.type.isConstExpression && node.index.t.type.constValue >= et.length) {
            this._error(node.index.location(), 'index out of bounds, trying to index element ' + node.index.t.type.constValue + ' in a value of length ' + et.length);
        } else if (et.isPrimitive) {
            if (et.isMat) {
                var m = {2: this._builtins.Vec2, 3: this._builtins.Vec3, 4: this._builtins.Vec4};
                node.t.type = m[et.length];
            } else if (et.isFloat) {
                node.t.type = this._builtins.Float;
            } else if (et.isInt) {
                node.t.type = this._builtins.Int;
            } else if (et.isBool) {
                node.t.type = this._builtins.Bool;
            }
        } else if (et.isArray) {
            node.t.type = et.elementType;
        }
    }

    if (node.index.t.type !== null) {
        if (node.index.t.type != this._builtins.Int) {
            this._error(node.index.location(), 'expected integer index expression, but got expression of type ' + node.index.t.type.name);
        } else if (node.expression.t.isConstExpression) {
            node.t.constValue = node.expression.t.constValue[node.index.t.constValue];
            node.t.isConstExpression = true;
        }
    }
};

Annotator.prototype._annotateFieldSelectionExpr = function(node) {
    this._initExpr(node);
    this._annotateNode(node.expression);

    var et = node.expression.t.type;

    if (et === null) {
        return;
    }

    if (node.selector === null) {
        return;
    }

    var s = node.selector.text;

    if (et.isPrimitive) {
        if (et.isVec) {
            var components = {
                'x': 0, 'y': 0, 'z': 0, 'w': 0,
                'r': 1, 'g': 1, 'b': 1, 'a': 1,
                's': 2, 't': 2, 'p': 2, 'q': 2
            };

            var cgroups = [
                'xyzw',
                'rgba',
                'stpq'
            ];

            if (s.length > 4) {
                this._error(node.selector.location, 'component selection on vectors is limited to a maximum of 4 elements, got ' + s.length);
                return;
            }

            var tps = [];

            if (et.isFloat) {
                tps = [Tn.T_FLOAT, Tn.T_VEC2, Tn.T_VEC3, Tn.T_VEC4];
            } else if (et.isInt) {
                tps = [Tn.T_INT, Tn.T_IVEC2, Tn.T_IVEC3, Tn.T_IVEC4];
            } else if (et.isBool) {
                tps = [Tn.T_BOOL, Tn.T_BVEC2, Tn.T_BVEC3, Tn.T_BVEC4];
            }

            node.t.type = this._builtins.typeMap[tps[s.length - 1]].type.t.type;

            if (node.expression.t.isConstExpression) {
                node.t.isConstExpression = true;

                if (node.t.type.isVec) {
                    node.t.constValue = [];

                    for (var i = 0; i < node.t.type.length; i++) {
                        node.t.constValue.push(0);
                    }
                } else {
                    node.t.constValue = 0;
                }
            }

            var ci = 0;

            for (var i = 0; i < s.length; i++) {
                var c = s[i];

                if (!(c in components)) {
                    this._error(node.selector.location.start.advanceChars(i).toRange(),
                                'invalid component selector \'' + c + '\', expected one of \'xyzw\' \'rgba\' or \'stpq\'');
                    return;
                }

                if (i !== 0 && ci != components[c]) {
                    this._error(node.selector.location.start.advanceChars(i).toRange(),
                                'cannot mix components of different groups, expected one of \'' + cgroups[ci] + '\'');
                    return;
                }

                ci = components[c];

                var j = cgroups[ci].indexOf(c);

                if (j >= et.length) {
                    this._error(node.selector.location.start.advanceChars(i).toRange(),
                                'selector out of bounds, expression has only ' + et.length + ' components, but tried to select component ' + (ci + 1));
                    return;
                }

                if (node.expression.t.isConstExpression) {
                    if (node.t.type.isVec) {
                        node.t.constValue[i] = node.expression.t.constValue[j];
                    } else {
                        node.t.constValue = node.expression.t.constValue[j];
                    }
                }
            }
        } else {
            this._error(node.expression.location().extend(node.op.location), 'selector \'' + s + '\' does not apply to an expression of type ' + et.name);
        }
    } else if (et.isComposite) {
        // Select on field in user defined type
        if (s in et.fieldMap) {
            var f = et.fieldMap[s];

            if (node.expression.t.isConstExpression && s in node.expression.t.constValue) {
                node.t.isConstExpression = true;
                node.t.constValue = node.expression.t.constValue[s];
            }

            node.t.type = f.type;
        } else {
            this._error(node.selector.location, 'the field \'' + s + '\' does not exist in the struct type ' + et.name);
        }
    } else {
        this._error(node.selector.location, 'cannot apply selector \'' + s + '\' to expression of type ' + et.name);
    }
};

Annotator.prototype._copyType = function(dest, src) {
    dest.t.type = src.t.type;
    dest.t.isConstExpression = src.t.isConstExpression;
    dest.t.constValue = src.t.constValue;
};
Annotator.prototype._annotateGroupExpr = function(node) {
    this._initExpr(node);
    this._annotateNode(node.expression);

    this._copyType(node, node.expression);
};

Annotator.prototype._annotateExpressionListStmt = function(node) {
    for (var i = 0; i < node.expressions.length; i++) {
        this._annotateNode(node.expressions[i]);
    }

    this._copyType(node, node.expressions[node.expressions.length - 1]);
};

Annotator.prototype._annotateDoStmt = function(node) {
    this._annotateNode(node.condition);

    if (node.condition.t.type !== null && node.condition.t.type !== this._builtins.Bool) {
        this._error(node.condition.location(), 'condition must of of type bool, got type ' + node.condition.t.type.name);
    }

    this._annotateNode(node.body);
};

Annotator.prototype._annotateWhileStmt = function(node) {
    this._pushScope(node);
    this._annotateNode(node.condition);

    if (node.condition.t.type !== null && node.condition.t.type !== this._builtins.Bool) {
        this._error(node.condition.location(), 'condition must of of type bool, got type ' + node.condition.t.type.name);
    }

    this._annotateNode(node.body);
    this._popScope();
};

Annotator.prototype._annotateForRestStmt = function(node) {
    this._annotateNode(node.condition);

    if (node.condition.t.type !== null && node.condition.t.type !== this._builtins.Bool) {
        this._error(node.condition.location(), 'condition must of of type bool, got type ' + node.condition.t.type.name);
    }

    this._annotateNode(node.expression);
};

Annotator.prototype._annotateForStmt = function(node) {
    this._pushScope(node);

    this._annotateNode(node.init);
    this._annotateNode(node.rest);
    this._annotateNode(node.body);

    this._popScope();
};

Annotator.prototype._annotateSelectionStmt = function(node) {
    this._annotateNode(node.condition);

    if (node.condition !== null &&
        node.condition.t.type !== null &&
        node.condition.t.type !== this._builtins.Bool) {
        this._error(node.condition.location(), 'condition must of of type bool, got type ' + node.condition.t.type.name);
    }

    this._pushScope(node.body);
    this._annotateNode(node.body);
    this._popScope();

    if (node.els) {
        this._pushScope(node.els);
        this._annotateNode(node.els);
        this._popScope(node.els);
    }
};

Annotator.prototype._annotateSelectionElseStmt = function(node) {
    this._annotateNode(node.body);
};

Annotator.prototype._annotateBreakStmt = function() {
};

Annotator.prototype._annotateContinueStmt = function() {
};

Annotator.prototype._annotateDiscardStmt = function() {
};

Annotator.prototype._annotateReturnStmt = function(node) {
    this._annotateNode(node.expression);

    var scope = this._scope;

    while (scope !== null && !glsl.ast.FunctionDef.prototype.isPrototypeOf(scope)) {
        scope = scope.parentScope;
    }

    if (scope !== null) {
        if (scope.t.type === this._builtins.Void && node.expression !== null) {
            this._error(node.expression.location(), 'returning value in a function with type void');
        } else if (scope.t.type !== this._builtins.Void && node.expression !== null && node.expression.t.type !== null && node.expression.t.type != scope.t.type) {
            this._error(node.expression.location(), 'expected return value of type ' + scope.t.type.name + ' but got value of type ' + node.expression.t.type.name);
        }
    }
};

Annotator.prototype._annotateNoMatch = function() {
};

Annotator.prototype._annotateEmptyStmt = function() {
};

Annotator.prototype._error = function(loc, message) {
    this._errors.push(new Error(loc, message));
};

exports.Annotate = Annotate;

// vi:ts=4:et

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ast":10,"./builtins":11,"./source":15,"./tokenizer":17}],17:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

function Token(id, text, loc, comments) {
    this.id = id;
    this.text = text;
    this.location = loc;

    this._tokenizer = null;

    if (typeof comments === 'undefined') {
        this.comments = [];
    } else {
        this.comments = comments;
    }
}

Token.prototype.marshal = function () {
    var ret = this._tokenizer.tokenIdName(this.id) + ':' + this.text + '@' + this.location.marshal();

    if (this.comments.length > 0) {
        var c = [ret];

        for (var i = 0; i < this.comments.length; i++) {
            c.push(this.comments[i].marshal());
        }

        return c;
    } else {
        return ret;
    }
};

Token.prototype.forAssert = function () {
    var ret = new Token(this.id, this.text, this.location);
    ret._tokenizer = this._tokenizer;

    for (var k in this) {
        var val = this[k];

        if (this.hasOwnProperty(k) && !ret.hasOwnProperty(k) && typeof val != 'function') {
            ret[k] = val;
        }
    }

    return ret;
};

exports.Token = Token;

function BaseTokenizer(b, options) {
    this._options = this._mergeOptions({
        floats: false,
        ints: false,
        bools: false,
        comments: false,
        skipComments: true,
        whitespaceClass: /^[ \t\n]+/,
        identifierClass: /^[A-Za-z_][A-Za-z0-9_]*/,
        floatClass: /((\d+\.\d*|\.\d+)([eE][+-]?\d+)?|\d+[eE][+-]?\d+)/,
        lineCommentClass: /^\/\/.*/,
        multilineCommentClass: /^\/\*(.|\n)*?\*\//,
        boolClass: /^(true|false)\b/,
        hexadecimalClass: /^0[xX][0-9a-fA-F]+/,
        octalClass: /^0[0-7]*/,
        decimalClass: /^[1-9][0-9]*/
    }, options);

    if (typeof b.keywords != 'undefined') {
        this._keywords = b.keywords;
    } else {
        this._keywords = {};
    }

    if (typeof b.operators != 'undefined') {
        this._operators = b.operators;
    } else {
        this._operators = {};
    }

    this._tokenIdMap = {};
    this._tokenNameMap = {};
    this._lastTokenId = 0;

    this._defineToken(b, 'identifier', 'IDENTIFIER');
    this._defineToken(b, 'unsupported', 'UNSUPPORTED');
    this._defineToken(b, 'eof', 'EOF');

    this._defineTokens(b, this._keywords);
    this._defineTokens(b, this._operators);

    if (this._options.floats) {
        this._defineToken(b, 'floating point number', 'FLOATCONSTANT');
    }

    if (this._options.ints) {
        this._defineToken(b, 'integer number', 'INTCONSTANT');
    }

    if (this._options.bools) {
        this._defineToken(b, 'boolean value', 'BOOLCONSTANT');
    }

    if (this._options.comments) {
        this._defineToken(b, 'comment', 'COMMENT');
    }

    this._extractOperators();

    b.tokenName = this.tokenName.bind(this);
    b.tokenIdName = this.tokenIdName.bind(this);
}

BaseTokenizer.prototype._mergeOptions = function(defs, options) {
    if (typeof options == 'undefined') {
        return defs;
    }

    for (var k in options) {
        defs[k] = options[k];
    }

    return defs;
};

BaseTokenizer.prototype.init = function(source) {
    this._source = source;
    this._cached = [];

    this._matchers = [];

    if (this._options.comments) {
        this._matchers.push({
            regex: this._options.lineCommentClass,
            finishToken: (function(tok) {
                tok.id = this._token('COMMENT');
                tok.multi = false;
                tok.value = tok.text.slice(2);

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ', multi:' + this.multi + ' = ' + this.value;
                };
            }).bind(this)
        });

        this._matchers.push({
            regex: this._options.multilineCommentClass,
            finishToken: (function(tok) {
                tok.id = this._token('COMMENT');
                tok.multi = true;
                tok.value = tok.text.slice(2, tok.text.length - 2);

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ', multi:' + this.multi + ' = ' + this.value;
                };
            }).bind(this)
        });
    }

    this._matchers.push({
        regex: this._roperators,
        finishToken: (function(tok) {
            tok.id = this._token(this._operators[tok.text]);
        }).bind(this)
    });

    if (this._options.bools) {
        // bools
        this._matchers.push({
            regex: this._options.boolClass,
            finishToken: (function(tok) {
                tok.id = this._token('BOOLCONSTANT');
                tok.value = (tok.text == 'true');

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ' = ' + this.value;
                };
            }).bind(this)
        });
    }

    this._matchers.push({
        regex: this._options.identifierClass,
        finishToken: (function(tok) {
            if (tok.text in this._keywords) {
                tok.id = this._token(this._keywords[tok.text]);
            } else {
                tok.id = this.T_IDENTIFIER;
            }
        }).bind(this)
    });

    if (this._options.floats) {
        // floating point number
        this._matchers.push({
            regex: this._options.floatClass,
            finishToken: (function(tok) {
                tok.id = this._token('FLOATCONSTANT');
                tok.value = parseFloat(tok.text);

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ' = ' + this.value;
                };
            }).bind(this)
        });
    }

    if (this._options.ints) {
        // literal hexadecimal integer
        this._matchers.push({
            regex: this._options.hexadecimalClass,
            finishToken: (function(tok) {
                tok.id = this._token('INTCONSTANT');
                tok.value = parseInt(tok.text.slice(2), 16);

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ' = ' + this.value;
                };
            }).bind(this)
        });

        // literal decimal integer
        this._matchers.push({
            regex: this._options.decimalClass,
            finishToken: (function(tok) {
                tok.id = this._token('INTCONSTANT');
                tok.value = parseInt(tok.text, 10);

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ' = ' + this.value;
                };
            }).bind(this)
        });

        // literal octal integer
        this._matchers.push({
            regex: this._options.octalClass,
            finishToken: (function(tok) {
                tok.id = this._token('INTCONSTANT');
                tok.value = parseInt(tok.text, 8);

                tok.marshal = function() {
                    return Token.prototype.marshal.call(this) + ' = ' + this.value;
                };
            }).bind(this)
        });
    }
};

BaseTokenizer.prototype.createToken = function(id, text, location) {
    var tok = new Token(id, text, location);
    tok._tokenizer = this;

    return tok;
};

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

function regexChoices(l) {
    l = l.slice(0);

    l.sort(function(a, b) {
        if (a.length > b.length) {
            return -1;
        }

        if (b.length > a.length) {
            return 1;
        }

        return 0;
    });

    for (var i = 0; i < l.length; i++) {
        l[i] = regexEscape(l[i]);
    }

    return '(' + l.join('|') + ')';
}

BaseTokenizer.prototype._extractOperators = function() {
    var ops = [];

    for (var op in this._operators) {
        ops.push(op);
    }

    if (ops.length !== 0) {
        this._roperators = new RegExp('^' + regexChoices(ops));
    } else {
        this._roperators = null;
    }
};

BaseTokenizer.prototype._defineToken = function(b, name, t) {
    var id = ++this._lastTokenId;

    this['T_' + t] = id;
    b['T_' + t] = id;

    this._tokenIdMap[id] = t;
    this._tokenNameMap[id] = name;
};

BaseTokenizer.prototype.tokenName = function(id) {
    return this._tokenNameMap[id];
};

BaseTokenizer.prototype.tokenIdName = function(id) {
    return this._tokenIdMap[id];
};

BaseTokenizer.prototype._defineTokens = function(b, tmap) {
    var ids = [];

    for (var k in tmap) {
        ids.push(k);
    }

    ids.sort();

    for (var i = 0; i < ids.length; i++) {
        this._defineToken(b, ids[i], tmap[ids[i]]);
    }
};

BaseTokenizer.prototype._skipWs = function() {
    this._source.skip(this._options.whitespaceClass);
};

BaseTokenizer.prototype.peek = function() {
    return this.unconsume(this.next());
};

BaseTokenizer.prototype.unconsume = function(tok) {
    this._cached.unshift(tok);
    return tok;
};

BaseTokenizer.prototype._postComments = function(tok) {
    this._options.skipComments = false;

    while (true) {
        var ntok = this.peek();

        if (ntok.id == this.T_COMMENT) {
            if (ntok.location.start.line == tok.location.start.line) {
                tok.comments.push(ntok);
                this.next();
            } else {
                break;
            }
        } else {
            break;
        }
    }

    this._options.skipComments = true;
    return tok;
};

BaseTokenizer.prototype.next = function() {
    var comments = [];

    if (this._options.comments && this._options.skipComments) {
        while (this._cached.length > 0 && this._cached[0].id == this.T_COMMENT) {
            comments.push(this._cached.shift());
        }
    }

    if (this._cached.length !== 0) {
        var ret = this._cached.shift();
        ret.comments = ret.comments.concat(comments);

        return ret;
    }

    var processingComments = true;

    while (processingComments) {
        processingComments = false;
        this._skipWs();

        if (this._source.eof()) {
            var tok = new Token(this.T_EOF, '', this.location().toRange(), comments);
            tok._tokenizer = this;

            return tok;
        }

        for (var i = 0; i < this._matchers.length; i++) {
            var m = this._matchers[i];

            if (m.regex === null) {
                continue;
            }

            var tok = this._source.next(m.regex);

            if (tok !== null) {
                tok._tokenizer = this;

                m.finishToken(tok);

                if (tok.id == this.T_COMMENT) {
                    if (this._options.comments && this._options.skipComments) {
                        comments.push(tok);
                        processingComments = true;
                    } else {
                        return tok;
                    }
                } else {
                    tok.comments = comments;

                    if (this._options.comments && this._options.skipComments) {
                        return this._postComments(tok);
                    }

                    return tok;
                }

                break;
            }
        }
    }

    var tok = this._source.next(/./);
    tok.id = this.T_UNSUPPORTED;

    return tok;
};

BaseTokenizer.prototype.remainder = function() {
    this._skipWs();
    return this._source.next(/.*/);
};

BaseTokenizer.prototype.eof = function() {
    return this._source.eof();
};

BaseTokenizer.prototype.location = function() {
    return this._source.location();
};

BaseTokenizer.prototype._token = function(n) {
    return this['T_' + n];
};

function Tokenizer(source) {
    BaseTokenizer.prototype.init.call(this, source);
}

Tokenizer.keywords = {
    'attribute': 'ATTRIBUTE',
    'const': 'CONST',
    'bool': 'BOOL',
    'float': 'FLOAT',
    'int': 'INT',
    'break': 'BREAK',
    'continue': 'CONTINUE',
    'do': 'DO',
    'else': 'ELSE',
    'for': 'FOR',
    'if': 'IF',
    'discard': 'DISCARD',
    'return': 'RETURN',
    'bvec2': 'BVEC2',
    'bvec3': 'BVEC3',
    'bvec4': 'BVEC4',
    'ivec2': 'IVEC2',
    'ivec3': 'IVEC3',
    'ivec4': 'IVEC4',
    'vec2': 'VEC2',
    'vec3': 'VEC3',
    'vec4': 'VEC4',
    'mat2': 'MAT2',
    'mat3': 'MAT3',
    'mat4': 'MAT4',
    'in': 'IN',
    'out': 'OUT',
    'inout': 'INOUT',
    'uniform': 'UNIFORM',
    'varying': 'VARYING',
    'sampler2D': 'SAMPLER2D',
    'samplerCube': 'SAMPLERCUBE',
    'struct': 'STRUCT',
    'void': 'VOID',
    'while': 'WHILE',
    'invariant': 'INVARIANT',
    'highp': 'HIGH_PRECISION',
    'mediump': 'MEDIUM_PRECISION',
    'lowp': 'LOW_PRECISION',
    'precision': 'PRECISION'
};

Tokenizer.operators = {
    '<<': 'LEFT_OP',
    '>>': 'RIGHT_OP',
    '++': 'INC_OP',
    '--': 'DEC_OP',
    '<=': 'LE_OP',
    '>=': 'GE_OP',
    '==': 'EQ_OP',
    '!=': 'NE_OP',
    '&&': 'AND_OP',
    '||': 'OR_OP',
    '^^': 'XOR_OP',

    '*=': 'MUL_ASSIGN',
    '/=': 'DIV_ASSIGN',
    '+=': 'ADD_ASSIGN',
    '%=': 'MOD_ASSIGN',
    '<<=': 'LEFT_ASSIGN',
    '>>=': 'RIGHT_ASSIGN',
    '&=': 'AND_ASSIGN',
    '^=': 'XOR_ASSIGN',
    '|=': 'OR_ASSIGN',
    '-=': 'SUB_ASSIGN',

    '(': 'LEFT_PAREN',
    ')': 'RIGHT_PAREN',
    '[': 'LEFT_BRACKET',
    ']': 'RIGHT_BRACKET',
    '{': 'LEFT_BRACE',
    '}': 'RIGHT_BRACE',

    '.': 'DOT',
    ',': 'COMMA',
    ':': 'COLON',
    '=': 'EQUAL',
    ';': 'SEMICOLON',
    '!': 'BANG',
    '-': 'DASH',
    '~': 'TILDE',
    '+': 'PLUS',
    '*': 'STAR',
    '/': 'SLASH',
    '%': 'PERCENT',

    '<': 'LEFT_ANGLE',
    '>': 'RIGHT_ANGLE',
    '|': 'VERTICAL_BAR',
    '^': 'CARET',
    '&': 'AMPERSAND',
    '?': 'QUESTION',
};

Tokenizer.prototype = new BaseTokenizer(Tokenizer, {
    floats: true,
    ints: true,
    bools: true,
    comments: true
});

exports.Base = BaseTokenizer;
exports.Tokenizer = Tokenizer;

exports.regexChoices = regexChoices;
exports.regexEscape = regexEscape;

// vi:ts=4:et

},{}],18:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var glMatrix = require('../vendor/gl-matrix');

/**
 * A general 3d transform. This class represents a transformation from one
 * frame to another as a pair of a quaternion orientation and a vec3
 * position.
 *
 * @constructor
 * @param orientation the initial orientation.
 * @param position the initial position.
 */
function transform(orientation, position) {
    /** a quat representing the transforms orientation. */
    this.orientation = orientation;

    /** a vec3 representing the transforms position. */
    this.position = position;

    this._dirty = 1;
}

transform.__doc__ = {"description":"A general 3d transform. This class represents a transformation from one\nframe to another as a pair of a quaternion orientation and a vec3\nposition.","kind":"class","refid":"transform","params":[{"description":"the initial orientation.","name":"orientation"},{"description":"the initial position.","name":"position"}],"members":{"orientation":"a quat representing the transforms orientation.","position":"a vec3 representing the transforms position."}};


/**
 * Create a new identity transform. Note that this is equivalent to calling
 * new transform(math.quat.create(), math.vec3.create())
 */
transform.create = function() {
    return new transform(glMatrix.quat.create(), glMatrix.vec3.create());
};

/**
 * Track changes in one transform to derive a value whenever the transform
 * changes. This can be used to lazily update transformations that depend
 * on another transformation (for example the full transforms of models),
 * only when it is needed. The return value is a function which can be
 * called to obtain the transformed value. The provided function which
 * should perform the transformation receives the @out parameter as its
 * first value, and the original transform (i.e. @value[@property]) as its
 * second. It should return the newly computed value, which may be just @out
 * if the computation is done in-place.
 *
 * Note that the returned function also implements the tracking contract and
 * can be used as a value transform to track, effectively allowing chained
 * tracking of multiple tracked transforms.
 *
 * @param out the output value to be provided to the function.
 * @param value the container object of the transform property.
 * @param property the name of the property in @value which contains the transform to track.
 * @param func a function (out = func(out, transform)) to call to perform the transformation when needed.
 */
transform.track = function(out, value, property, func) {
    var prev;

    var ret = function() {
        var tr = value[property];

        if (tr.orientation !== prev.orientation ||
            tr.position !== prev.position ||
            tr._dirty !== prev._dirty) {

            out = func(out, tr);

            prev.orientation = tr.orientation;
            prev.position = tr.position;
            prev._dirty = tr._dirty;
        }

        return out;
    };

    ret.orientation = null;
    ret.position = null;
    ret._dirty = 0;

    prev = ret;
    return ret;
};

transform.clone = function(a) {
    return a.clone();
};

/**
 * Clone the transform.
 */
transform.prototype.clone = function() {
    return new transform(glMatrix.quat.clone(this.orientation),
                         glMatrix.vec3.clone(this.position));
}

transform.prototype.clone.__doc__ = {"description":"Clone the transform.","kind":"function","refid":"transform#clone"};
;

transform.copy = function(out, a) {
    glMatrix.quat.copy(out.orientation, a.orientation);
    glMatrix.vec3.copy(out.position, a.position);

    out._dirty++;

    return out;
};

transform.multiply = function(out, a, b) {
    var apos = a.position;
    var aori = a.orientation;

    var bpos = b.position;
    var bori = b.orientation;

    var oribpos = glMatrix.vec3.create();
    glMatrix.vec3.transformQuat(oribpos, bpos, aori);

    glMatrix.vec3.add(out.position, apos, oribpos);
    glMatrix.quat.mul(out.orientation, aori, bori);

    out._dirty++;

    return out;
};

transform.mul = transform.multiply;

/**
 * Multiply the transform by another transform. Note that this
 * modifies the receiving transform.
 *
 * @param other a transform to multiply with.
 */
transform.prototype.mul = function(other) {
    return transform.mul(this, this, other);
}

transform.prototype.mul.__doc__ = {"description":"Multiply the transform by another transform. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#mul","params":[{"description":"a transform to multiply with.","name":"other"}]};
;

/**
 * Pre-multiply the transform by another transform. Note that this
 * modifies the receiving transform.
 *
 * @param other a transform to pre-multiply with.
 */
transform.prototype.preMul = function(other) {
    return transform.mul(this, other, this);
}

transform.prototype.preMul.__doc__ = {"description":"Pre-multiply the transform by another transform. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#preMul","params":[{"description":"a transform to pre-multiply with.","name":"other"}]};
;

transform.rotateX = function(out, a, rad) {
    glMatrix.vec3.copy(out.position, a.position);
    glMatrix.quat.rotateX(out.orientation, a.orientation, rad);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform around its local X axis. Note that this
 * modifies the receiving transform.
 *
 * @param rad the angle by which to rotate in radians.
 */
transform.prototype.rotateX = function(rad) {
    return transform.rotateX(this, this, rad);
}

transform.prototype.rotateX.__doc__ = {"description":"Rotate the transform around its local X axis. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#rotateX","params":[{"description":"the angle by which to rotate in radians.","name":"rad"}]};
;

transform.preRotateX = function(out, a, rad) {
    glMatrix.vec3.rotateX(out.position, a.position, [0, 0, 0], rad);
    glMatrix.quat.rotateX(out.orientation, a.orientation, rad);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform around its global X axis. Note that this
 * modifies the receiving transform.
 *
 * @param rad the angle by which to rotate in radians.
 */
transform.prototype.preRotateX = function(rad) {
    return transform.preRotateX(this, this, rad);
}

transform.prototype.preRotateX.__doc__ = {"description":"Rotate the transform around its global X axis. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#preRotateX","params":[{"description":"the angle by which to rotate in radians.","name":"rad"}]};
;

transform.rotateY = function(out, a, rad) {
    glMatrix.vec3.copy(out.position, a.position);
    glMatrix.quat.rotateY(out.orientation, a.orientation, rad);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform around its local Y axis. Note that this
 * modifies the receiving transform.
 *
 * @param rad the angle by which to rotate in radians.
 */
transform.prototype.rotateY = function(rad) {
    return transform.rotateY(this, this, rad);
}

transform.prototype.rotateY.__doc__ = {"description":"Rotate the transform around its local Y axis. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#rotateY","params":[{"description":"the angle by which to rotate in radians.","name":"rad"}]};
;

transform.preRotateY = function(out, a, rad) {
    glMatrix.vec3.rotateY(out.position, a.position, [0, 0, 0], rad);
    glMatrix.quat.rotateY(out.orientation, a.orientation, rad);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform around its global Y axis. Note that this
 * modifies the receiving transform.
 *
 * @param rad the angle by which to rotate in radians.
 */
transform.prototype.preRotateY = function(rad) {
    return transform.preRotateY(this, this, rad);
}

transform.prototype.preRotateY.__doc__ = {"description":"Rotate the transform around its global Y axis. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#preRotateY","params":[{"description":"the angle by which to rotate in radians.","name":"rad"}]};
;

transform.rotateZ = function(out, a, rad) {
    glMatrix.vec3.copy(out.position, a.position);
    glMatrix.quat.rotateZ(out.orientation, a.orientation, rad);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform around its local Z axis. Note that this
 * modifies the receiving transform.
 *
 * @param rad the angle by which to rotate in radians.
 */
transform.prototype.rotateZ = function(rad) {
    return transform.rotateZ(this, this, rad);
}

transform.prototype.rotateZ.__doc__ = {"description":"Rotate the transform around its local Z axis. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#rotateZ","params":[{"description":"the angle by which to rotate in radians.","name":"rad"}]};
;

transform.preRotateZ = function(out, a, rad) {
    glMatrix.vec3.rotateZ(out.position, a.position, [0, 0, 0], rad);
    glMatrix.quat.rotateZ(out.orientation, a.orientation, rad);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform around its global Z axis. Note that this
 * modifies the receiving transform.
 *
 * @param rad the angle by which to rotate in radians.
 */
transform.prototype.preRotateZ = function(rad) {
    return transform.preRotateZ(this, this, rad);
}

transform.prototype.preRotateZ.__doc__ = {"description":"Rotate the transform around its global Z axis. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#preRotateZ","params":[{"description":"the angle by which to rotate in radians.","name":"rad"}]};
;

transform.rotate = function(out, a, q) {
    glMatrix.vec3.copy(out.position, a.position);
    glMatrix.quat.mul(out.orientation, a.orientation, q);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform by the given quaternion. Note that this
 * modifies the receiving transform.
 *
 * @param q the quaternion by which to rotate.
 */
transform.prototype.rotate = function(q) {
    return transform.rotate(this, this, q);
}

transform.prototype.rotate.__doc__ = {"description":"Rotate the transform by the given quaternion. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#rotate","params":[{"description":"the quaternion by which to rotate.","name":"q"}]};
;

transform.preRotate = function(out, a, q) {
    glMatrix.vec3.transformQuat(out.position, a.position, q);
    glMatrix.quat.mul(out.orientation, a.orientation, q);

    out._dirty++;

    return out;
};

/**
 * Rotate the transform globally by the given quaternion. Note that this
 * modifies the receiving transform.
 *
 * @param q the quaternion by which to rotate.
 */
transform.prototype.preRotate = function(q) {
    return transform.rotate(this, this, q);
}

transform.prototype.preRotate.__doc__ = {"description":"Rotate the transform globally by the given quaternion. Note that this\nmodifies the receiving transform.","kind":"function","refid":"transform#preRotate","params":[{"description":"the quaternion by which to rotate.","name":"q"}]};
;

transform.translateX = function(out, a, v) {
    glMatrix.quat.copy(out.orientation, a.orientation);
    glMatrix.vec3.copy(out.position, a.position);

    out.position[0] += v;

    out._dirty++;

    return out;
};

/**
 * Translate on X in the parent frame. If you want to translate
 * the transform in the local frame, use {@link module:math~transform#translateSide translateSide}.
 * Note that this modifies the receiving transform.
 *
 * @param v a scalar to translate by.
 * @see {@link module:math~transform#translateSide translateSide}.
 */
transform.prototype.translateX = function(v) {
    return transform.translateX(this, this, v);
}

transform.prototype.translateX.__doc__ = {"description":"Translate on X in the parent frame. If you want to translate\nthe transform in the local frame, use {@link module:math~transform#translateSide translateSide}.\nNote that this modifies the receiving transform.","kind":"function","refid":"transform#translateX","params":[{"description":"a scalar to translate by.","name":"v"}]};
;

transform.translateY = function(out, a, v) {
    glMatrix.quat.copy(out.orientation, a.orientation);
    glMatrix.vec3.copy(out.position, a.position);

    out.position[1] += v;

    out._dirty++;

    return out;
};

/**
 * Translate on Y in the parent frame. If you want to translate
 * the transform in the local frame, use {@link translateUp}.
 * Note that this modifies the receiving transform.
 *
 * @param v a scalar to translate by.
 * @see {@link translateUp}.
 */
transform.prototype.translateY = function(v) {
    return transform.translateY(this, this, v);
}

transform.prototype.translateY.__doc__ = {"description":"Translate on Y in the parent frame. If you want to translate\nthe transform in the local frame, use {@link translateUp}.\nNote that this modifies the receiving transform.","kind":"function","refid":"transform#translateY","params":[{"description":"a scalar to translate by.","name":"v"}]};
;

transform.translateZ = function(out, a, v) {
    glMatrix.quat.copy(out.orientation, a.orientation);
    glMatrix.vec3.copy(out.position, a.position);

    out.position[2] += v;

    out._dirty++;

    return out;
};

/**
 * Translate on Z in the parent frame. If you want to translate
 * the transform in the local frame, use {@link translateForward}.
 * Note that this modifies the receiving transform.
 *
 * @param v a scalar to translate by.
 * @see {@link translateForward}.
 */
transform.prototype.translateZ = function(v) {
    return transform.translateZ(this, this, v);
}

transform.prototype.translateZ.__doc__ = {"description":"Translate on Z in the parent frame. If you want to translate\nthe transform in the local frame, use {@link translateForward}.\nNote that this modifies the receiving transform.","kind":"function","refid":"transform#translateZ","params":[{"description":"a scalar to translate by.","name":"v"}]};
;

transform.translate = function(out, a, v) {
    glMatrix.quat.copy(out.orientation, a.orientation);
    glMatrix.vec3.add(out.position, a.position, v);

    out._dirty++;

    return out;
};

/**
 * Translate by the given vector. Note that this modifies the
 * receiving transform.
 *
 * @param v a vec3 to translate by.
 */
transform.prototype.translate = function(v) {
    return transform.translate(this, this, v);
}

transform.prototype.translate.__doc__ = {"description":"Translate by the given vector. Note that this modifies the\nreceiving transform.","kind":"function","refid":"transform#translate","params":[{"description":"a vec3 to translate by.","name":"v"}]};
;

transform.sideAxis = function(out, a) {
    var o = a.orientation,
        x = o[0], y = o[1], z = o[2], w = o[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,
        yy = y * y2,
        zz = z * z2,
        yx = y * x2,
        wz = w * z2,
        zx = z * x2,
        wy = w * y2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;

    return out;
};

/**
 * Obtain the local orientation's side axis. This is the same
 * as the X column of the transform's orientation matrix.
 */
transform.prototype.sideAxis = function() {
    return transform.sideAxis(glMatrix.vec3.create(), this);
}

transform.prototype.sideAxis.__doc__ = {"description":"Obtain the local orientation's side axis. This is the same\nas the X column of the transform's orientation matrix.","kind":"function","refid":"transform#sideAxis"};
;

transform.upAxis = function(out, a) {
    var o = a.orientation,
        x = o[0], y = o[1], z = o[2], w = o[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,
        yx = y * x2,
        wz = w * z2,
        xx = x * x2,
        zz = z * z2,
        zy = z * y2,
        wx = w * x2;

    out[0] = yx - wz;
    out[1] = 1 - xx - zz;
    out[2] = zy + wx;

    return out;
};

/**
 * Obtain the local orientation's up axis. This is the same
 * as the Y column of the transform's orientation matrix.
 */
transform.prototype.upAxis = function() {
    return transform.upAxis(glMatrix.vec3.create(), this);
}

transform.prototype.upAxis.__doc__ = {"description":"Obtain the local orientation's up axis. This is the same\nas the Y column of the transform's orientation matrix.","kind":"function","refid":"transform#upAxis"};
;

transform.forwardAxis = function(out, a) {
    var o = a.orientation,
        x = o[0], y = o[1], z = o[2], w = o[3],
        x2 = x + x,
        y2 = y + y,
        zx = z * x2,
        wy = w * y2,
        zy = z * y2,
        wx = w * x2,
        xx = x * x2,
        yy = y * y2;

    out[0] = zx + wy;
    out[1] = zy - wx;
    out[2] = 1 - xx - yy;

    return out;
};

/**
 * Obtain the local orientation's forward axis. This is the same
 * as the Z column of the transform's orientation matrix.
 */
transform.prototype.forwardAxis = function() {
    return transform.forwardAxis(glMatrix.vec3.create(), this);
}

transform.prototype.forwardAxis.__doc__ = {"description":"Obtain the local orientation's forward axis. This is the same\nas the Z column of the transform's orientation matrix.","kind":"function","refid":"transform#forwardAxis"};
;

transform.translateSide = function(out, a, v) {
    var axis = transform.sideAxis(glMatrix.vec3.create(), a);
    glMatrix.vec3.scale(axis, axis, v);

    out._dirty++;

    return transform.translate(out, a, axis);
};

/**
 * Translate the transform along its local orientation side axis.
 * Note that this modifies the receiving transform.
 *
 * @param v a scalar to translate sideways by.
 */
transform.prototype.translateSide = function(v) {
    return transform.translateSide(this, this, v);
}

transform.prototype.translateSide.__doc__ = {"description":"Translate the transform along its local orientation side axis.\nNote that this modifies the receiving transform.","kind":"function","refid":"transform#translateSide","params":[{"description":"a scalar to translate sideways by.","name":"v"}]};
;

transform.translateUp = function(out, a, v) {
    var axis = transform.upAxis(glMatrix.vec3.create(), a);
    glMatrix.vec3.scale(axis, axis, v);

    out._dirty++;

    return transform.translate(out, a, axis);
};

/**
 * Translate the transform along its local orientation up axis.
 * Note that this modifies the receiving transform.
 *
 * @param v a scalar to translate upwards by.
 */
transform.prototype.translateUp = function(v) {
    return transform.translateUp(this, this, v);
}

transform.prototype.translateUp.__doc__ = {"description":"Translate the transform along its local orientation up axis.\nNote that this modifies the receiving transform.","kind":"function","refid":"transform#translateUp","params":[{"description":"a scalar to translate upwards by.","name":"v"}]};
;

transform.translateForward = function(out, a, v) {
    var axis = transform.forwardAxis(glMatrix.vec3.create(), a);
    glMatrix.vec3.scale(axis, axis, v);

    out._dirty++;

    return transform.translate(out, a, axis);
};

/**
 * Translate the transform along its local orientation forward axis.
 * Note that this modifies the receiving transform.
 *
 * @param v a scalar amount to translate forwards by
 */
transform.prototype.translateForward = function(v) {
    return transform.translateForward(this, this, v);
}

transform.prototype.translateForward.__doc__ = {"description":"Translate the transform along its local orientation forward axis.\nNote that this modifies the receiving transform.","kind":"function","refid":"transform#translateForward","params":[{"description":"a scalar amount to translate forwards by","name":"v"}]};
;

transform.invert = function(out, a) {
    glMatrix.quat.invert(out.orientation, a.orientation);
    glMatrix.vec3.negate(out.position, a.position);

    glMatrix.vec3.transformQuat(out.position, out.position, out.orientation);

    out._dirty++;

    return out;
};

/**
 * Invert the transformation. Note that this modifies the receiving
 * transform.
 */
transform.prototype.invert = function() {
    return transform.invert(this, this);
}

transform.prototype.invert.__doc__ = {"description":"Invert the transformation. Note that this modifies the receiving\ntransform.","kind":"function","refid":"transform#invert"};
;

transform.lookAt = function(out, eye, center, up) {
    var m = glMatrix.mat4.lookAt(glMatrix.mat4.create(), eye, center, up);

    glMatrix.quat.fromMat3(out.orientation, glMatrix.mat3.fromMat4(glMatrix.mat3.create(), m));

    out.position[0] = m[12];
    out.position[1] = m[13];
    out.position[2] = m[14];

    return out;
};

transform.prototype.lookAt = function(eye, center, up) {
    return transform.lookAt(this, eye, center, up);
};

transform.str = function(a) {
    return '{' + glMatrix.quat.str(a.orientation) + ', ' + glMatrix.vec3.str(a.position) + '}';
};

transform.prototype.str = function() {
    return transform.str(this);
};

glMatrix.mat4.fromTransform = function(out, t) {
    return glMatrix.mat4.fromRotationTranslation(glMatrix.mat4.create(), t.orientation, t.position);
};

glMatrix.vec4.transformTransform = function(out, a, t) {
    glMatrix.vec3.transformTransform(out, a, t);

    var tr = t.position;

    out[0] += a[3] * tr[0];
    out[1] += a[3] * tr[1];
    out[2] += a[3] * tr[2];
    out[3] = a[4];

    return out;
};

glMatrix.vec3.transformTransform = function(out, a, t) {
    return glMatrix.vec3.add(out, glMatrix.vec3.transformQuat(out, t.orientation), t.position);
};

function wrapIsMat(orig) {
    return function() {
        var ret = orig.apply(this, arguments);
        ret.isMat = true;

        return ret;
    };
}

var numWrappers = {
    int8: Int8Array,
    int16: Int16Array,
    int32: Int32Array,

    uint8: Uint8Array,
    uint16: Uint16Array,
    uint32: Uint32Array,

    float32: Float32Array,
    float64: Float64Array
};

for (var k in numWrappers) {
    exports[k] = (function(W) {
        return function(v) {
            if (typeof v === 'object' && Array.prototype.isPrototypeOf(v)) {
                return new W(v);
            } else {
                return new W([v]);
            }
        };
    })(numWrappers[k]);
}

var mats = [glMatrix.mat2, glMatrix.mat3, glMatrix.mat4];

for (var i = 0; i < mats.length; i++) {
    mats[i].create = wrapIsMat(mats[i].create);
    mats[i].clone = wrapIsMat(mats[i].clone);
}

for (var k in glMatrix) {
    if (glMatrix.hasOwnProperty(k)) {
        var v = glMatrix[k];
        var f;

        if (typeof v.fromValues === 'function') {
            f = (function(obj) {
                return function() {
                    return obj.fromValues.apply(this, arguments);
                };
            })(v);
        } else if (k === 'mat2' || k === 'mat3' || k === 'mat4') {
            f = (function(obj) {
                return function() {
                    var ret = obj.create();

                    for (var i = 0; i < arguments.length; i++) {
                        ret[i] = arguments[i];
                    }

                    return ret;
                };
            })(v);
        } else {
            f = {};
        }

        for (var j in v) {
            if (v.hasOwnProperty(j)) {
                f[j] = v[j];

                f[j + '$'] = (function(v, j) {
                    var ret = function() {
                        var args = Array.prototype.slice.call(arguments);
                        args.unshift(v.create());

                        return v[j].apply(null, args);
                    };

                    return ret;
                })(v, j);
            }
        }

        exports[k] = f;
    }
}

exports.transform = transform;

// vi:ts=4:et

},{"../vendor/gl-matrix":55}],19:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');

/**
 * A simple box model. Creates a simple box geometry, centered around [0, 0, 0] for
 * the given dimensions.
 *
 * @param ctx the context.
 * @param dx the X size of the box.
 * @param dy the Y size of the box.
 * @param dz the Z size of the box.
 * @param options optional options.
 * @constructor
 */
function Box(ctx, dx, dy, dz, options) {
    Model.call(this, ctx, 'box', options);

    dx /= 2;
    dy /= 2;
    dz /= 2;

    var vertices = new Float32Array([
        // Right plane
         dx, -dy,  dz,
         dx, -dy, -dz,
         dx,  dy, -dz,
         dx,  dy,  dz,

        // Left plane
        -dx, -dy, -dz,
        -dx, -dy,  dz,
        -dx,  dy,  dz,
        -dx,  dy, -dz,

        // Top plane
        -dx,  dy,  dz,
         dx,  dy,  dz,
         dx,  dy, -dz,
        -dx,  dy, -dz,

        // Bottom plane
        -dx, -dy, -dz,
         dx, -dy, -dz,
         dx, -dy,  dz,
        -dx, -dy,  dz,

        // Front plane
        -dx, -dy, dz,
         dx, -dy, dz,
         dx,  dy, dz,
        -dx,  dy, dz,

        // Back plane
         dx, -dy, -dz,
        -dx, -dy, -dz,
        -dx,  dy, -dz,
         dx,  dy, -dz,
    ]);

    var normals = new Float32Array([
        // Right plane
         1,  0,  0,
         1,  0,  0,
         1,  0,  0,
         1,  0,  0,

        // Left plane
        -1,  0,  0,
        -1,  0,  0,
        -1,  0,  0,
        -1,  0,  0,

        // Top plane
         0,  1,  0,
         0,  1,  0,
         0,  1,  0,
         0,  1,  0,

        // Bottom plane
         0, -1,  0,
         0, -1,  0,
         0, -1,  0,
         0, -1,  0,

        // Front plane
         0,  0,  1,
         0,  0,  1,
         0,  0,  1,
         0,  0,  1,

        // Back plane
         0,  0, -1,
         0,  0, -1,
         0,  0, -1,
         0,  0, -1,
    ]);

    var indices = new Uint16Array([
        // Right plane
         0,  1,  2,
         0,  2,  3,

        // Left plane
         4,  5,  6,
         4,  6,  7,

        // Top plane
         8,  9, 10,
         8, 10, 11,

        // Bottom plane
        12, 13, 14,
        12, 14, 15,

        // Front plane
        16, 17, 18,
        16, 18, 19,

        // Back plane
        20, 21, 22,
        20, 22, 23,
    ]);

    this.renderer = new RenderGroup(ctx, new Geometry(ctx, vertices, normals), indices);
}

Box.__doc__ = {"description":"A simple box model. Creates a simple box geometry, centered around [0, 0, 0] for\nthe given dimensions.","kind":"class","refid":"Box","params":[{"description":"the context.","name":"ctx"},{"description":"the X size of the box.","name":"dx"},{"description":"the Y size of the box.","name":"dy"},{"description":"the Z size of the box.","name":"dz"},{"description":"optional options.","name":"options"}]};


Box.prototype = Object.create(Model.prototype);
Box.prototype.constructor = Box;

module.exports = Box;

// vi:ts=4:et

},{"./geometry":20,"./model":23,"./rendergroup":28}],20:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('../utils/utils');

/**
 * A representation of a geometry. A geometry contains a number
 * of vertex buffer objects specifying attributes such as vertices,
 * normals, etc. The vertices and normals provided to the constructor
 * are a convenience equivalent to calling addAttribute manually
 * respectively with the attribute names 'v_Position' and 'v_Normal'.
 *
 * Additional attributes can be added to a geometry after construction
 * using addAttribute. As a convenience, update can be used to update
 * vertices and normals instead of calling addAttribute manually.
 *
 * Note that a Geometry only consists of a number of attribute
 * buffers, but does not specify how to render objects contained
 * within these buffers (e.g. a single buffer may contain multiple
 * objects). See RenderGroup and RenderGroups for information on
 * how to index a Geometry for rendering.
 *
 * @param ctx the context.
 * @param vertices a Float32Array of vertices, or null.
 * @param normals a Float32Array of normals, or null.
 * @param options optional options <binding:> (defaults to <binding: gl.STATIC_DRAW>).
 * @constructor
 */
function Geometry(ctx, vertices, normals) {
    this._lastAttrId = 0;

    this.attributes = {};
    this._attributeIds = {};

    this.update(ctx, vertices, normals);
}

Geometry.__doc__ = {"description":"A representation of a geometry. A geometry contains a number\nof vertex buffer objects specifying attributes such as vertices,\nnormals, etc. The vertices and normals provided to the constructor\nare a convenience equivalent to calling addAttribute manually\nrespectively with the attribute names 'v_Position' and 'v_Normal'.\n\nAdditional attributes can be added to a geometry after construction\nusing addAttribute. As a convenience, update can be used to update\nvertices and normals instead of calling addAttribute manually.\n\nNote that a Geometry only consists of a number of attribute\nbuffers, but does not specify how to render objects contained\nwithin these buffers (e.g. a single buffer may contain multiple\nobjects). See RenderGroup and RenderGroups for information on\nhow to index a Geometry for rendering.","kind":"class","refid":"Geometry","params":[{"description":"the context.","name":"ctx"},{"description":"a Float32Array of vertices, or null.","name":"vertices"},{"description":"a Float32Array of normals, or null.","name":"normals"},{"description":"optional options <binding:> (defaults to <binding: gl.STATIC_DRAW>).","name":"options"}]};


/**
 * Update the geometry. This is a convenience around calling
 * addAttribute manually with respectively the names
 * 'v_Position' (for the vertices) and 'v_Normal' (for the normals).
 *
 * @param ctx the context.
 * @param vertices a Float32Array of vertices, or null.
 * @param normals a Float32Array of normals, or null.
 * @param options optional options <binding:> (defaults to <binding: gl.STATIC_DRAW>).
 */
Geometry.prototype.update = function(ctx, vertices, normals, options) {
    var gl = ctx.gl;

    var opts = utils.merge({
        binding: gl.STATIC_DRAW
    }, options);

    if (vertices) {
        this.addAttribute(ctx, 'v_Position', vertices, opts);
    }

    if (normals) {
        this.addAttribute(ctx, 'v_Normal', normals, opts);
    }
}

Geometry.prototype.update.__doc__ = {"description":"Update the geometry. This is a convenience around calling\naddAttribute manually with respectively the names\n'v_Position' (for the vertices) and 'v_Normal' (for the normals).","kind":"function","refid":"Geometry#update","params":[{"description":"the context.","name":"ctx"},{"description":"a Float32Array of vertices, or null.","name":"vertices"},{"description":"a Float32Array of normals, or null.","name":"normals"},{"description":"optional options <binding:> (defaults to <binding: gl.STATIC_DRAW>).","name":"options"}]};
;

/**
 * Remove an attribute buffer.
 *
 * @param name the name of the attribute to remove.
 */
Geometry.prototype.removeAttribute = function(ctx, name) {
    var gl = ctx.gl;

    if (!(name in this.attributes)) {
        return;
    }

    var attr = this.attributes[name];

    gl.deleteBuffer(attr.id);

    delete this._attributeIds[attr.id];
    delete this.attributes[name];
}

Geometry.prototype.removeAttribute.__doc__ = {"description":"Remove an attribute buffer.","kind":"function","refid":"Geometry#removeAttribute","params":[{"description":"the name of the attribute to remove.","name":"name"}]};
;

/**
 * Add an attribute buffer. If an attribute buffer with the given
 * name already exists, then this existing buffer is first removed.
 *
 * @param name the name of the attribute to remove.
 * @param data the attribute data.
 * @param options attribute options. Valid options map to
 * parameters required for gl.bufferData and gl.vertexAttribPointer
 * and include binding, size, type, normalized and stride.
 */
Geometry.prototype.addAttribute = function(ctx, name, data, options) {
    var gl = ctx.gl;

    var opts = utils.merge({
        binding: gl.STATIC_DRAW,
        size: 3,
        type: gl.FLOAT,
        normalized: false,
        stride: 0
    }, options);

    if (name in this.attributes) {
        this.removeAttribute(ctx, name);
    }

    var i = 0;

    while (i in this._attributeIds) {
        i++;
    }

    if (opts.type === gl.FLOAT && data !== null && (typeof data !== 'object' || Object.getPrototypeOf(data) !== Float32Array.prototype)) {
        data = new Float32Array(data);
    }

    var attr = {
        data: data,
        id: i,
        vbo: gl.createBuffer(),
        size: opts.size,
        type: opts.type,
        normalized: opts.normalized,
        stride: opts.stride,
        enabled: true
    };

    gl.bindBuffer(gl.ARRAY_BUFFER, attr.vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, opts.binding);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    this.attributes[name] = attr;
    this._attributeIds[attr.id] = true;
}

Geometry.prototype.addAttribute.__doc__ = {"description":"Add an attribute buffer. If an attribute buffer with the given\nname already exists, then this existing buffer is first removed.","kind":"function","refid":"Geometry#addAttribute","params":[{"description":"the name of the attribute to remove.","name":"name"},{"description":"the attribute data.","name":"data"},{"description":"attribute options. Valid options map to\nparameters required for gl.bufferData and gl.vertexAttribPointer\nand include binding, size, type, normalized and stride.","name":"options"}]};
;

/**
 * Bind the geometry in the current context.
 *
 * @param ctx the context.
 */
Geometry.prototype.bind = function(ctx) {
    var gl = ctx.gl;

    for (var k in this.attributes) {
        var attr = this.attributes[k];

        gl.bindBuffer(gl.ARRAY_BUFFER, attr.vbo);
        gl.vertexAttribPointer(attr.id, attr.size, attr.type, attr.normalized, attr.stride, 0);

        if (attr.enabled) {
            gl.enableVertexAttribArray(attr.id);
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, null);
}

Geometry.prototype.bind.__doc__ = {"description":"Bind the geometry in the current context.","kind":"function","refid":"Geometry#bind","params":[{"description":"the context.","name":"ctx"}]};
;

/**
 * Unbind the geometry from the current context.
 *
 * @param ctx the context.
 */
Geometry.prototype.unbind = function(ctx) {
    var gl = ctx.gl;

    for (var k in this.attributes) {
        var attr = this.attributes[k];

        if (attr.enabled) {
            gl.disableVertexAttribArray(attr.id);
        }
    }
}

Geometry.prototype.unbind.__doc__ = {"description":"Unbind the geometry from the current context.","kind":"function","refid":"Geometry#unbind","params":[{"description":"the context.","name":"ctx"}]};
;

module.exports = Geometry;

// vi:ts=4:et

},{"../utils/utils":52}],21:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');
var math = require('../math/math');

/**
 * A simple ico sphere. Creates a simple ico sphere geometry, centered around [0, 0, 0] for
 * the given radius and number of subdivisions.
 *
 * @param ctx the context.
 * @param radius the radius of the sphere.
 * @param subdivisions the number of subdivisions to generate the sphere (minimal 1).
 * @param options optional options.
 * @constructor
 */
function IcoSphere(ctx, radius, subdivisions, options) {
    Model.call(this, ctx, 'icosphere', options);

    // golden ratio, phi
    var x = 1;
    var y = 0.5 * (1 + Math.sqrt(5));

    var l = radius / Math.sqrt(x * x + y * y);

    x *= l;
    y *= l;

    var vertices = [-x,  y, 0,
                     x,  y, 0,
                    -x, -y, 0,
                     x, -y, 0,

                     0, -x,  y,
                     0,  x,  y,
                     0, -x, -y,
                     0,  x, -y,

                     y,  0, -x,
                     y,  0,  x,
                    -y,  0, -x,
                    -y,  0,  x];

    var normals = [];
    var i;

    for (i = 0; i < vertices.length; i++) {
        normals.push(vertices[i] / radius);
    }

    var indices = [
         0, 11,  5,
         0,  5,  1,
         0,  1,  7,
         0,  7, 10,
         0, 10, 11,

         1,  5,  9,
         5, 11,  4,
        11, 10,  2,
        10,  7,  6,
         7,  1,  8,

         3,  9,  4,
         3,  4,  2,
         3,  2,  6,
         3,  6,  8,
         3,  8,  9,

         4,  9,  5,
         2,  4, 11,
         6,  2, 10,
         8,  6,  7,
         9,  8,  1
    ];

    subdivisions = (subdivisions || 1);

    for (var s = 1; s < subdivisions; s++) {
        var nindices = [];

        var split = {};

        // for each face
        for (i = 0; i < indices.length; i += 3) {
            var i0 = this._splitEdge(vertices, normals, indices[i], indices[i + 1], split, radius);
            var i1 = this._splitEdge(vertices, normals, indices[i + 1], indices[i + 2], split, radius);
            var i2 = this._splitEdge(vertices, normals, indices[i + 2], indices[i], split, radius);

            nindices.push(indices[i], i0, i2,
                          i0, indices[i + 1], i1,
                          i0, i1, i2,
                          i2, i1, indices[i + 2]);
        }

        indices = nindices;
    }

    this.renderer = new RenderGroup(ctx, new Geometry(ctx, vertices, normals), indices);
}

IcoSphere.__doc__ = {"description":"A simple ico sphere. Creates a simple ico sphere geometry, centered around [0, 0, 0] for\nthe given radius and number of subdivisions.","kind":"class","refid":"IcoSphere","params":[{"description":"the context.","name":"ctx"},{"description":"the radius of the sphere.","name":"radius"},{"description":"the number of subdivisions to generate the sphere (minimal 1).","name":"subdivisions"},{"description":"optional options.","name":"options"}]};


IcoSphere.prototype = Object.create(Model.prototype);
IcoSphere.prototype.constructor = IcoSphere;

IcoSphere.prototype._splitEdge = function(vertices, normals, i1, i2, split, radius) {
    var splitKey;

    if (i1 < i2) {
        splitKey = i1 + '-' + i2;
    } else {
        splitKey = i2 + '-' + i1;
    }

    var pt = split[splitKey];

    if (pt) {
        return pt;
    }

    var i = vertices.length / 3;
    split[splitKey] = i;

    var i1s = i1 * 3;
    var i1e = i1s + 3;
    var i2s = i2 * 3;
    var i2e = i2s + 3;

    var m = math.vec3.add$(vertices.slice(i1s, i1e), vertices.slice(i2s, i2e));
    var l = radius / math.vec3.len(m);

    vertices.push(m[0] * l, m[1] * l, m[2] * l);

    var n = math.vec3.normalize$(math.vec3.add$(normals.slice(i1s, i1e), normals.slice(i2s, i2e)));
    normals.push(n[0], n[1], n[2]);

    return i;
};

module.exports = IcoSphere;

// vi:ts=4:et

},{"../math/math":18,"./geometry":20,"./model":23,"./rendergroup":28}],22:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var math = require('../math/math');
var Texture = require('./texture');
var utils = require('../utils/utils');

/**
 * A basic material. A material contains a specification of the material
 * properties used to render a model. These material properties are transfered
 * to a glsl program as uniforms.
 *
 * @param uniforms initial material uniforms.
 *
 * @constructor
 */
function Material(uniforms) {
    /**
     * A map of uniform names to values. Any values set in this map,
     * with a corresponding uniform in the material program, are
     * automatically bound to the 'material' uniform when the material
     * is used. Use the various math.vec/mat types to map to the glsl
     * types.
     */
    this.uniforms = utils.merge({
        ambient: {
            color: math.vec4(1.0, 1.0, 1.0, 1.0),
            intensity: 0.1
        },

        diffuse: {
            color: math.vec4(0.8, 0.8, 0.8, 1.0),
            intensity: 0.8
        },

        specular: {
            color: math.vec4(1.0, 1.0, 1.0, 1.0),
            intensity: 0.5,
            hardness: 50.0
        }
    }, uniforms);

    this._texunit = 0;
    this._textures = {};

    /**
     * Sets the visibility of the material. The value should be one of
     * Material.VISIBLE, Material.INVISIBLE or Material.ONLY_CHILDREN.
     * Models with an invisible material are not rendered at all, while
     * models with a material visibility set to Material.ONLY_CHILDREN will
     * render only the models children (but not the model itself) (defaults
     * to Material.VISIBLE).
     */
    this.visible = true;

    /**
     * The name of the program to render, or null to use the default
     * program (defaults to null).
     */
    this.program = null;
}

Material.__doc__ = {"description":"A basic material. A material contains a specification of the material\nproperties used to render a model. These material properties are transfered\nto a glsl program as uniforms.","kind":"class","refid":"Material","params":[{"description":"initial material uniforms.","name":"uniforms"}],"members":{"uniforms":"A map of uniform names to values. Any values set in this map,\nwith a corresponding uniform in the material program, are\nautomatically bound to the 'material' uniform when the material\nis used. Use the various math.vec/mat types to map to the glsl\ntypes.","visible":"Sets the visibility of the material. The value should be one of\nMaterial.VISIBLE, Material.INVISIBLE or Material.ONLY_CHILDREN.\nModels with an invisible material are not rendered at all, while\nmodels with a material visibility set to Material.ONLY_CHILDREN will\nrender only the models children (but not the model itself) (defaults\nto Material.VISIBLE).","program":"The name of the program to render, or null to use the default\nprogram (defaults to null).","VISIBLE":"Visible, renders the model normally.","INVISIBLE":"Invisible, will not render the model.","ONLY_CHILDREN":"Only children, renders only the children, but not the model itself."}};


Material._ignoreUniforms = {
    model: true,
    view: true,
    modelView: true,
    projection: true,
    modelViewProjection: true
};

Material._ignoreUniforms['material.ambient.color'] = true;
Material._ignoreUniforms['material.ambient.intensity'] = true;
Material._ignoreUniforms['material.diffuse.color'] = true;
Material._ignoreUniforms['material.diffuse.intensity'] = true;
Material._ignoreUniforms['material.specular.color'] = true;
Material._ignoreUniforms['material.specular.intensity'] = true;
Material._ignoreUniforms['material.specular.hardness'] = true;

Material.prototype._mixColor = function(mecol, color, prop) {
    mecol[prop] = math.vec4(mecol.color[0] * mecol.intensity * color[0],
                            mecol.color[1] * mecol.intensity * color[1],
                            mecol.color[2] * mecol.intensity * color[2],
                            mecol.color[3] * color[3]);
};

Material.prototype.mixColors = function(color, prop) {
    this._mixColor(this.uniforms.ambient, color, prop);
    this._mixColor(this.uniforms.diffuse, color, prop);
    this._mixColor(this.uniforms.specular, color, prop);
};

Material.prototype._setUniformTyped = function(ctx, u, v, name) {
    var l;

    if (v.typeLength) {
        l = v.typeLength;
    } else {
        l = v.length;
    }

    switch (Object.getPrototypeOf(v)) {
    case Float32Array.prototype:
        switch (l) {
        case 1:
            ctx.gl.uniform1fv(u, v);
            break;
        case 2:
            ctx.gl.uniform2fv(u, v);
            break;
        case 3:
            ctx.gl.uniform3fv(u, v);
            break;
        case 4:
            if (v.isMat) {
                ctx.gl.uniformMatrix2fv(u, false, v);
            } else {
                ctx.gl.uniform4fv(u, v);
            }
            break;
        case 9:
            ctx.gl.uniformMatrix3fv(u, false, v);
            break;
        case 16:
            ctx.gl.uniformMatrix4fv(u, false, v);
            break;
        default:
            throw new Error('cannot set uniform ' + name + ' = ' + v);
        }
        break;
    case Int32Array.prototype:
        switch (l) {
        case 1:
            ctx.gl.uniform1iv(u, v);
            break;
        case 2:
            ctx.gl.uniform2iv(u, v);
            break;
        case 3:
            ctx.gl.uniform3iv(u, v);
            break;
        case 4:
            ctx.gl.uniform4iv(u, v);
            break;
        default:
            throw new Error('cannot set uniform ' + name + ' = ' + v);
        }
        break;
    default:
        break;
    }
};

Material.prototype._setUniform = function(ctx, u, v, name) {
    if (typeof v === 'number') {
        ctx.gl.uniform1f(u, v);
        return;
    }

    if (typeof v === 'boolean') {
        ctx.gl.uniform1i(u, v);
        return;
    }

    switch (Object.getPrototypeOf(v)) {
    case Float32Array.prototype:
    case Int32Array.prototype:
        this._setUniformTyped(ctx, u, v, name);
        break;
    case Texture.prototype:
        var unit = this._texunit++;
        v.bind(ctx, unit);
        ctx.gl.uniform1i(u, unit);
        break;
    default:
        throw new Error('cannot set uniform ' + v);
    }
};

Material.prototype._setUniforms = function(ctx, p, uniforms, prefix, depth, seen) {
    if (!seen) {
        seen = [];
    }

    if (!depth) {
        depth = 0;
    }

    if (depth > 4) {
        throw new Error('maximum nested levels of uniforms exceeded (maximum is ' + depth + ')');
    }

    if (!p.uniforms) {
        p.uniforms = {};
    }

    for (var k in uniforms) {
        if (!uniforms.hasOwnProperty(k)) {
            continue;
        }

        var fname;

        if (prefix) {
            fname = prefix + '.' + k;
        } else {
            fname = k;
        }

        var v = uniforms[k];

        if (typeof v === 'object') {
            if (v === null || seen.indexOf(v) !== -1) {
                continue;
            }

            var proto = Object.getPrototypeOf(v);
            seen.push(v);

            if (proto !== Float32Array.prototype && proto !== Int32Array.prototype && proto !== Texture.prototype && proto !== Array.prototype) {
                this._setUniforms(ctx, p, v, fname, depth + 1, seen);
                continue;
            }
        }

        if (!(fname in p.uniforms)) {
            p.uniforms[fname] = ctx.gl.getUniformLocation(p.program, fname);

            if (p.uniforms[fname] === null && !Material._ignoreUniforms[fname]) {
                console.error('could not find uniform location for ' + p.name + '.' + fname);
            }
        }

        var u = p.uniforms[fname];

        if (u !== null) {
            this._setUniform(ctx, u, v, fname);
        }
    }
};

/**
 * Bind the material in the given context. This sets up the material
 * program as well as binding all the material uniforms. Additional
 * non-material uniforms can be provided (for example the modelViewProjection
 * matrix).
 *
 * Note that this is automatically called when rendering a model and
 * should usually not be called by the user.
 *
 * @param ctx the context.
 * @param uniforms a map of additional uniform values to set.
 */
Material.prototype.bind = function(ctx, uniforms) {
    var p = ctx.findProgram(this.program);

    if (p === null) {
        return;
    }

    if (ctx.program === null || ctx.program.program !== p.program) {
        ctx.gl.useProgram(p.program);
        ctx.program = p;
    }

    this._texunit = 0;
    this._textures = {};

    this._setUniforms(ctx, p, this.uniforms, 'material');
    this._setUniforms(ctx, p, uniforms);
}

Material.prototype.bind.__doc__ = {"description":"Bind the material in the given context. This sets up the material\nprogram as well as binding all the material uniforms. Additional\nnon-material uniforms can be provided (for example the modelViewProjection\nmatrix).\n\nNote that this is automatically called when rendering a model and\nshould usually not be called by the user.","kind":"function","refid":"Material#bind","params":[{"description":"the context.","name":"ctx"},{"description":"a map of additional uniform values to set.","name":"uniforms"}]};
;

/** Visible, renders the model normally. */
Material.VISIBLE = true;

/** Invisible, will not render the model. */
Material.INVISIBLE = false;

/** Only children, renders only the children, but not the model itself. */
Material.ONLY_CHILDREN = 2;

module.exports = Material;

// vi:ts=4:et

},{"../math/math":18,"../utils/utils":52,"./texture":30}],23:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Material = require('./material');
var math = require('../math/math');

/**
 * Basic model. A model useful high-level representation
 * of a transform, geometry and material which can be rendered.
 * Models can be organized hierarchically (see add, remove).
 *
 * @param ctx the context.
 * @param name the name of the model.
 * @param options options.
 * @constructor
 */
function Model(ctx, name, options) {
    /** The name. */
    this.name = name;

    var mat;

    if (options && options.material) {
        mat = options.material;
    } else {
        mat = new Material();
    }

    /** The material (see Material). */
    this.material = mat;

    /**
     * The parent (or null). Do not set this directly,
     * use add/remove instead.
     */
    this.parent = null;

    /**
     * The children. Do not set this directly, use add/remove instead.
     */
    this.children = [];

    /** The transform. */
    this.transform = math.transform.create();

    /** The full transform (i.e. to world coordinates). This will
     * be computed and cached as needed when rendering.
     */
    this.fullTransform = math.transform.track(math.transform.create(), this, 'transform', function(out, tr) {
        return math.transform.copy(out, tr);
    });

    /** The geometry to render. This is usually a RenderGroup or
      * RenderGroups, but may be anything with a .renderParts()
      * function, returning an array of elements containing:
      * 1) a .geometry field containing a Geometry.
      * 2) a .render(ctx) function.
      */
    this.renderer = null;
}

Model.__doc__ = {"description":"Basic model. A model useful high-level representation\nof a transform, geometry and material which can be rendered.\nModels can be organized hierarchically (see add, remove).","kind":"class","refid":"Model","params":[{"description":"the context.","name":"ctx"},{"description":"the name of the model.","name":"name"},{"description":"options.","name":"options"}],"members":{"name":"The name.","material":"The material (see Material).","parent":"The parent (or null). Do not set this directly,\nuse add/remove instead.","children":"The children. Do not set this directly, use add/remove instead.","transform":"The transform.","fullTransform":"The full transform (i.e. to world coordinates). This will\nbe computed and cached as needed when rendering.","renderer":"The geometry to render. This is usually a RenderGroup or\nRenderGroups, but may be anything with a .renderParts()\nfunction, returning an array of elements containing:\n1) a .geometry field containing a Geometry.\n2) a .render(ctx) function."}};


/**
 * Render the model in the given context. Rendering will use the current view
 * set in the context.
 *
 * @param ctx the context.
 */
Model.prototype.render = function(ctx, options) {
    if (this.material.visible === Material.INVISIBLE) {
        return;
    }

    options = options || {};

    var view = ctx.view();

    var fullTransform = this.fullTransform();

    var i;

    for (i = 0; i < this.children.length; i++) {
        this.children[i].render(ctx, options);
    }

    if (this.material.visible === Material.ONLY_CHILDREN || this.renderer === null) {
        return;
    }

    var uniforms = {
        model: math.mat4.fromTransform(math.mat4.create(), fullTransform),
        view: null,
        modelView: null,
        projection: null,
        modelViewProjection: null
    };

    if (view) {
        uniforms.view = math.mat4.fromTransform$(view.originTransform());
        uniforms.modelView = math.mat4.mul$(uniforms.view, uniforms.model);
        uniforms.projection = view.projection();
        uniforms.modelViewProjection = math.mat4.mul$(uniforms.projection, uniforms.modelView);
    } else {
        uniforms.view = math.mat4.create();
        uniforms.modelView = uniforms.model;
        uniforms.projection = math.mat4.create();
        uniforms.modelViewProjection = uniforms.model;
    }

    if (options && options.uniforms) {
        for (var k in options.uniforms) {
            if (options.uniforms.hasOwnProperty(k)) {
                uniforms[k] = options.uniforms[k];
            }
        }
    }

    var material;

    if (options.material) {
        material = options.material;
    } else {
        material = this.material;
    }

    var p = ctx.findProgram(material.program);
    var parts = this.renderer.renderParts();

    var prevGeometry = null;

    var attr;

    for (i = 0; i < parts.length; i++) {
        var part = parts[i];
        var geometry = part.geometry;
        var needsRebind = false;
        var attrname;

        if (p !== null) {
            // Reconcile geometry attributes with program attributes
            for (attrname in geometry.attributes) {
                attr = geometry.attributes[attrname];

                if (!(attrname in p.attributes) || p.attributes[attrname] !== attr.id) {
                    needsRebind = true;
                    break;
                }
            }

            if (needsRebind) {
                var gl = ctx.gl;

                p.attributes = {};
                p.uniforms = {};

                for (attrname in geometry.attributes) {
                    attr = geometry.attributes[attrname];
                    gl.bindAttribLocation(p.program, attr.id, attrname);

                    p.attributes[attrname] = attr.id;
                }

                gl.linkProgram(p.program);
            }
        }

        if (geometry !== prevGeometry) {
            geometry.bind(ctx);
            prevGeometry = geometry;
        }

        if (needsRebind || i === 0) {
            material.bind(ctx, uniforms);
        }

        part.render(ctx);
    }

    if (prevGeometry !== null) {
        prevGeometry.unbind(ctx);
    }
}

Model.prototype.render.__doc__ = {"description":"Render the model in the given context. Rendering will use the current view\nset in the context.","kind":"function","refid":"Model#render","params":[{"description":"the context.","name":"ctx"}]};
;

/**
 * Remove a child model.
 *
 * @param child the model to remove.
 */
Model.prototype.remove = function(child) {
    if (child.parent === this) {
        child.parent = null;

        child.fullTransform = (function() {
            return this.transform;
        }).bind(child);
    }

    var i = this.children.indexOf(child);

    if (i !== -1) {
        this.children.splice(i, 1);
    }
}

Model.prototype.remove.__doc__ = {"description":"Remove a child model.","kind":"function","refid":"Model#remove","params":[{"description":"the model to remove.","name":"child"}]};
;

/**
 * Add a child model.
 *
 * @param child the model to add.
 */
Model.prototype.add = function(child) {
    if (child.parent === this) {
        return;
    }

    if (child.parent !== null) {
        child.parent.remove(child);
    }

    child.parent = this;
    this.children.push(child);

    child.fullTransform = math.transform.track(math.transform.create(), this, 'fullTransform', function(out, tr) {
        return child.transform.preMul(tr());
    });
}

Model.prototype.add.__doc__ = {"description":"Add a child model.","kind":"function","refid":"Model#add","params":[{"description":"the model to add.","name":"child"}]};
;

module.exports = Model;

var objloader = require('./objloader');
Model.load = objloader.load;

// vi:ts=4:et

},{"../math/math":18,"./material":22,"./objloader":25}],24:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

module.exports = {
    Box: require('./box'),
    Geometry: require('./geometry'),
    RenderGroup: require('./rendergroup'),
    RenderGroups: require('./rendergroups'),
    Material: require('./material'),
    Model: require('./model'),
    Quad: require('./quad'),
    Triangle: require('./triangle'),
    Plane: require('./plane'),
    IcoSphere: require('./icosphere'),
    UvSphere: require('./uvsphere'),
    Texture: require('./texture'),
    View: require('./view')
};

// vi:ts=4:et

},{"./box":19,"./geometry":20,"./icosphere":21,"./material":22,"./model":23,"./plane":26,"./quad":27,"./rendergroup":28,"./rendergroups":29,"./texture":30,"./triangle":31,"./uvsphere":32,"./view":33}],25:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('../utils/utils');
var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');
var RenderGroups = require('./rendergroups');
var Store = require('../app/store');

var objectCache = {};



function WavefrontParser() {
    if (utils.Browser.IsIE) {
        this._worker = new Worker(global.Settings.frontend.url('assets/js/models/wavefrontparser.js'));
    } else {
        var code = new Blob(["// jshint worker:true\n\n/*\n * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *    * Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *    * Redistributions in binary form must reproduce the above\n *      copyright notice, this list of conditions and the following disclaimer\n *      in the documentation and/or other materials provided with the\n *      distribution.\n *    * Neither the name of Google Inc. nor the names of its\n *      contributors may be used to endorse or promote products derived from\n *      this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nfunction ensureObject(state, name) {\n    if (state.object === null || typeof name !== 'undefined') {\n        state.object = {\n            name: name || 'Default',\n            vertices: [],\n            normals: [],\n            texcoords: [],\n            sharedVertices: {},\n            groups: [],\n\n            attributes: {\n                vertices: [],\n                normals: [],\n                texcoords: []\n            }\n        };\n\n        state.objects.push(state.object);\n        state.group = null;\n    }\n}\n\nfunction ensureGroup(state, autosmooth, name) {\n    ensureObject(state);\n\n    if (state.group === null || typeof name !== 'undefined') {\n        state.group = {\n            smooth: autosmooth ? true : false,\n            name: name || 'Default',\n            indices: [],\n            aabbox: [\n                {\n                    min: null,\n                    max: null\n                },\n\n                {\n                    min: null,\n                    max: null\n                },\n\n                {\n                    min: null,\n                    max: null\n                }\n            ]\n        };\n\n        state.object.groups.push(state.group);\n    }\n}\n\nfunction uniqueName(col, name) {\n    var i = 1;\n    var uname = name;\n\n    while (col.indexOf(uname) !== -1) {\n        uname = name + ' ' + i;\n        i++;\n    }\n\n    return uname;\n}\n\nfunction cross(v, w) {\n    return new Float64Array([\n        v[1] * w[2] - v[2] * w[1],\n        v[2] * w[0] - v[0] * w[2],\n        v[0] * w[1] - v[1] * w[0]\n    ]);\n}\n\nfunction normalize(v) {\n    var l = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n\n    if (l > 0) {\n        v[0] = v[0] / l;\n        v[1] = v[1] / l;\n        v[2] = v[2] / l;\n    }\n\n    return v;\n}\n\nfunction faceNormal(p1, p2, p3) {\n    var v = new Float64Array([0, 0, 0]);\n    var w = new Float64Array([0, 0, 0]);\n    var n = new Float64Array([0, 0, 0]);\n\n    for (var i = 0; i < 3; i++) {\n        v[i] = p2[i] - p1[i];\n        w[i] = p3[i] - p1[i];\n    }\n\n    // cross product\n    n = cross(v, w);\n    return normalize(n);\n}\n\nfunction parseIndex(idx, l) {\n    if (idx < 0) {\n        return l - 1 + 3 * idx;\n    } else {\n        return (idx - 1) * 3;\n    }\n}\n\nfunction makeIndex(buffer, index, original, mapping) {\n    var i = mapping[index];\n\n    if (typeof i !== 'undefined') {\n        return i;\n    }\n\n    i = buffer.vertices.length / 3;\n    mapping[index] = i;\n\n    var i3 = index * 3;\n    var i2 = index * 2;\n\n    if (original.vertices.length > 0) {\n        buffer.vertices.push(original.vertices[i3 + 0],\n                             original.vertices[i3 + 1],\n                             original.vertices[i3 + 2]);\n    }\n\n    if (original.texcoords.length > 0) {\n        buffer.texcoords.push(original.texcoords[i2 + 0],\n                              original.texcoords[i2 + 1]);\n    }\n\n    if (original.normals.length > 0) {\n        buffer.normals.push(original.normals[i3 + 0],\n                            original.normals[i3 + 1],\n                            original.normals[i3 + 2]);\n    }\n\n    return i;\n}\n\nfunction splitObj(o) {\n    // Indices are uint16, and are thus limited to what they can actually index\n    var indexLimit = (1 << 16) / 2;\n\n    if (o.attributes.vertices.length / 3 <= indexLimit) {\n        return {\n            name: o.name,\n            buffers: [o]\n        };\n    }\n\n    var ret = {\n        name: o.name,\n        buffers: [],\n        aabbox: [\n            { min: 0, max: 0 },\n            { min: 0, max: 0 },\n            { min: 0, max: 0 }\n        ]\n    };\n\n    // Iterate over groups, keep appending to the current buffer,\n    // as long as its smaller than the maximum size. This might split\n    // groups as well, but can't be avoided anyway.\n    function makeBuffer() {\n        return {\n            attributes: {\n                vertices: [],\n                texcoords: [],\n                normals: []\n            },\n\n            groups: []\n        };\n    }\n\n    var buffer = makeBuffer();\n    ret.buffers.push(buffer);\n\n    var group = null;\n    var indexMap = {};\n\n    for (var gi = 0; gi < o.groups.length; gi++) {\n        var g = o.groups[gi];\n        group = null;\n\n        var i;\n\n        for (i = 0; i < 3; i++) {\n            if (gi === 0) {\n                ret.aabbox[i].min = g.aabbox[i].min;\n                ret.aabbox[i].max = g.aabbox[i].max;\n            } else {\n                if (g.aabbox[i].min < ret.aabbox[i].min) {\n                    ret.aabbox[i].min = g.aabbox[i].min;\n                }\n\n                if (g.aabbox[i].max < ret.aabbox[i].max) {\n                    ret.aabbox[i].max = g.aabbox[i].max;\n                }\n            }\n        }\n\n        for (i = 0; i < g.indices.length; i += 3) {\n            if ((buffer.attributes.vertices.length / 3) + 3 > indexLimit) {\n                buffer = makeBuffer();\n                ret.buffers.push(buffer);\n\n                group = null;\n                indexMap = {};\n            }\n\n            if (group === null) {\n                group = {\n                    name: g.name,\n                    indices: [],\n                    aabbox: [\n                        { min: null, max: null },\n                        { min: null, max: null },\n                        { min: null, max: null }\n                    ]\n                };\n\n                buffer.groups.push(group);\n            }\n\n            group.indices.push(makeIndex(buffer.attributes, g.indices[i + 0], o.attributes, indexMap),\n                               makeIndex(buffer.attributes, g.indices[i + 1], o.attributes, indexMap),\n                               makeIndex(buffer.attributes, g.indices[i + 2], o.attributes, indexMap));\n        }\n    }\n\n    return ret;\n}\n\nfunction parseObj(s, options) {\n    var i = 0, n, j;\n\n    var lineno = 1;\n\n    var state = {\n        objects: [],\n        object: null,\n        group: null\n    };\n\n    while (i < s.length) {\n        var nl = i;\n\n        // Read a single line\n        var isspace = true;\n        var iscomment = false;\n        var st = i;\n\n        while (nl < s.length && s[nl] !== '\\n') {\n            if (isspace) {\n                if (s[nl] === '#') {\n                    iscomment = true;\n                }\n\n                if (s[nl] !== ' ') {\n                   isspace = false;\n                   st = nl;\n                }\n            }\n\n            nl++;\n        }\n\n        i = nl + 1;\n\n        if (iscomment) {\n            lineno++;\n            continue;\n        }\n\n        if (nl < s.length && nl > 0 && s[nl - 1] === '\\r') {\n            nl--;\n        }\n\n        var line = s.slice(st, nl);\n        var parts = line.trim().split(/ +/);\n        var h, k, sh, name;\n\n        switch (parts[0]) {\n        case 'v':\n            ensureObject(state);\n\n            if (parts.length === 4) {\n                state.object.vertices.push(parseFloat(parts[1]),\n                                           parseFloat(parts[2]),\n                                           parseFloat(parts[3]));\n            } else {\n                throw new Error('l' + lineno + ': Only 3 coordinates per vertex are currently supported');\n            }\n            break;\n        case 'vt':\n            ensureObject(state);\n\n            if (parts.length === 3) {\n                state.object.texcoords.push(parseFloat(parts[1]),\n                                            parseFloat(parts[2]));\n            } else {\n                throw new Error('l' + lineno + ': Only 2 coordinates per texture coordinate are currently supported');\n            }\n            break;\n        case 'vn':\n            ensureObject(state);\n\n            if (parts.length === 4) {\n                state.object.normals.push(parseFloat(parts[1]),\n                                          parseFloat(parts[2]),\n                                          parseFloat(parts[3]));\n            } else {\n                throw new Error('l' + lineno + ': Normals must have 3 coordinates');\n            }\n            break;\n        case 'f':\n            ensureGroup(state, options.autosmooth);\n\n            var gv = state.object.attributes.vertices;\n            var gn = state.object.attributes.normals;\n            var gt = state.object.attributes.texcoords;\n            var gi = state.group.indices;\n\n            if (parts.length === 4) {\n                var p = [parts[1].split('/'), parts[2].split('/'), parts[3].split('/')];\n\n                if (p[0].length !== p[1].length || p[0].length !== p[2].length) {\n                    throw new Error('l' + lineno + ': Face must have same attributes for each vertex');\n                } else if (p[0].length > 3) {\n                    throw new Error('l' + lineno + ': Too many attributes');\n                } else {\n                    var v = state.object.vertices;\n                    var t = state.object.texcoords;\n                    n = state.object.normals;\n\n                    var l = p[0].length;\n\n                    var ii = gv.length / 3;\n                    var verts = [null, null, null];\n\n                    var hasT = (l > 1 && p[k][1].length > 0);\n                    var hasN = (l > 2 && p[k][2].length !== 0);\n\n                    for (k = 0; k < 3; k++) {\n                        h = parts[k + 1];\n\n                        var vi = parseIndex(parseInt(p[k][0]), v.length);\n\n                        // Keep verts to calculate face normal if necessary\n                        verts[k] = [v[vi], v[vi + 1], v[vi + 2]];\n\n                        var ninit = new Float64Array([0, 0, 0]);\n\n                        // Reuse vertices for smooth surfaces, or those\n                        // with normals defined\n                        if (state.group.smooth || hasN) {\n                            if (options.shareVertices) {\n                                var seen = state.object.sharedVertices[h];\n\n                                if (typeof seen !== 'undefined') {\n                                    gi.push(seen);\n                                    continue;\n                                } else {\n                                    state.object.sharedVertices[h] = ii;\n                                }\n                            } else {\n                                sh = state.object.sharedVertices[h];\n\n                                if (!sh) {\n                                    state.object.sharedVertices[h] = [ii];\n                                } else {\n                                    var ni = sh[0] * 3;\n\n                                    ninit = gn.slice(ni, ni + 3);\n                                    state.object.sharedVertices[h].push(ii);\n                                }\n                            }\n                        }\n\n                        gi.push(ii);\n                        gv.push(verts[k][0], verts[k][1], verts[k][2]);\n\n                        for (j = 0; j < 3; j++) {\n                            if (state.group.aabbox[j].min === null || verts[k][j] < state.group.aabbox[j].min) {\n                                state.group.aabbox[j].min = verts[k][j];\n                            }\n\n                            if (state.group.aabbox[j].max === null || verts[k][j] > state.group.aabbox[j].min) {\n                                state.group.aabbox[j].max = verts[k][j];\n                            }\n                        }\n\n                        if (hasT) {\n                            var ti = parseIndex(parseInt(p[k][1]), t.length);\n                            gt.push(t[ti], t[ti + 1], t[ti + 2]);\n                        }\n\n                        if (hasN) {\n                            var nii = parseIndex(parseInt(p[k][2]), n.length);\n                            gn.push(n[nii], n[nii + 1], n[nii + 2]);\n                        } else if (state.group.smooth) {\n                            gn.push(ninit[0], ninit[1], ninit[2]);\n                        }\n\n                        ii++;\n                    }\n\n                    // Generate normal for non-smooth surfaces without\n                    // defined normals\n                    if (!hasN) {\n                        n = faceNormal(verts[0], verts[1], verts[2]);\n\n                        // Use face normal for each vertex\n                        if (state.group.smooth) {\n                            for (k = 0; k < 3; k++) {\n                                h = parts[k + 1];\n\n                                if (options.shareVertices) {\n                                    sh = [state.object.sharedVertices[h]];\n                                } else {\n                                    sh = state.object.sharedVertices[h];\n                                }\n\n                                for (var si = 0; si < sh.length; si++) {\n                                    var idx = sh[si] * 3;\n\n                                    gn[idx + 0] += n[0];\n                                    gn[idx + 1] += n[1];\n                                    gn[idx + 2] += n[2];\n                                }\n                            }\n                        } else {\n                            for (k = 0; k < 3; k++) {\n                                gn.push(n[0], n[1], n[2]);\n                            }\n                        }\n                    }\n                }\n            } else {\n                throw new Error('l' + lineno + ': Only triangular faces are currently supported (got ' + (parts.length - 1) + ' face vertices)');\n            }\n            break;\n        case 'o':\n            if (parts.length === 1) {\n                throw new Error('l' + lineno + ': expected object name');\n            }\n\n            name = parts[1].trim();\n\n            if (name.length === 0) {\n                throw new Error('l' + lineno + ': expected non-empty object name');\n            }\n\n            name = uniqueName(state.objects);\n            ensureObject(state, name);\n            break;\n        case 'g':\n            if (parts.length === 1) {\n                throw new Error('l' + lineno + ': expected group name');\n            }\n\n            name = parts[1].trim();\n\n            if (name.length === 0) {\n                throw new Error('l' + lineno + ': expected non-empty group name');\n            }\n\n            if (state.object !== null) {\n                name = uniqueName(state.object.groups, name);\n            }\n\n            ensureGroup(state, options.autosmooth, name);\n            break;\n        case 's':\n            ensureGroup(state, options.autosmooth);\n\n            if (parts.length === 2) {\n                if (parts[1] === '1' || parts[1] === 'on') {\n                    state.group.smooth = true;\n                } else if (parts[1] === '0' || parts[1] === 'off') {\n                    state.group.smooth = false;\n                }\n            }\n            break;\n        }\n\n        lineno++;\n    }\n\n    var ret = [];\n\n    for (i = 0; i < state.objects.length; i++) {\n        var o = state.objects[i];\n\n        n = o.attributes.normals;\n\n        for (j = 0; j < n.length; j += 3) {\n            var nn = new Float64Array(n.slice(j, j + 3));\n            nn = normalize(nn);\n\n            n[j + 0] = nn[0];\n            n[j + 1] = nn[1];\n            n[j + 2] = nn[2];\n        }\n\n        ret.push(splitObj(o));\n    }\n\n    return ret;\n}\n\nself.addEventListener('message', function(e) {\n    var ret = parseObj(e.data.data, e.data.options);\n\n    postMessage({\n        id: e.data.id,\n        result: ret\n    });\n});\n\n// vi:ts=4:et\n"],
                            { type: 'application/javascript '});

        this._worker = new Worker(URL.createObjectURL(code));
    }

    this._worker.addEventListener('message', this._onWorkerMessage.bind(this));

    this._id = 0;
    this._callbacks = {};
}

WavefrontParser.prototype._onWorkerMessage = function(message) {
    var cb = this._callbacks[message.data.id];

    if (cb) {
        delete this._callbacks[message.data.id];
        cb(message.data.result);
    }
};

WavefrontParser.prototype.parse = function(data, options, cb) {
    var id = this._id++;
    this._callbacks[id] = cb;

    this._worker.postMessage({
        data: data,
        options: options,
        id: id
    });
};

var wavefrontParser = new WavefrontParser();

function createModel(ctx, ret, objects, options) {
    for (var i = 0; i < objects.length; i++) {
        var o = objects[i];
        var m = new Model(ctx, o.name, options);

        m.renderer = new RenderGroups({
            aabbox: o.aabbox
        });

        for (var k = 0; k < o.buffers.length; k++) {
            var buffer = o.buffers[k];

            var geom = new Geometry(ctx,
                                    new Float32Array(buffer.attributes.vertices),
                                    new Float32Array(buffer.attributes.normals));

            for (var gi = 0; gi < buffer.groups.length; gi++) {
                var g = buffer.groups[gi];

                m.renderer.add(new RenderGroup(ctx, geom, new Uint16Array(g.indices), {
                    aabbox: g.aabbox
                }));
            }
        }

        if (m.renderer.groups.length === 1) {
            m.renderer = m.renderer.groups[0];
        }

        ret.add(m);
    }

    return ret;
}

function cacheKey(filename, options) {
    return filename + '::' + JSON.stringify({
        autosmooth: options.autosmooth,
        shareVertices: options.shareVertices
    });
}

function parseOrCachedObj(ctx, date, filename, ret, body, fromCache, options) {
    var key = cacheKey(filename, options);

    // Try local/session cache first
    var cached = objectCache[key];

    if (cached && cached.date.getTime() === date.getTime()) {
        // Already loaded from cache
        options.success(ret);
        return ret;
    }

    // Try storage cache
    new Store(function(store) {
        store.objectFromCache(key, date, function(store, objects) {
            var f = function(objects) {
                objectCache[key] = {
                    date: date,
                    objects: objects
                };

                // Remove models loaded from the cache
                if (fromCache !== null) {
                    for (var i = 0; i < fromCache.length; i++) {
                        ret.remove(fromCache[i]);
                    }
                }

                createModel(ctx, ret, objects, options);

                options.complete(ret);
                options.success(ret);
            };

            if (!objects) {
                var parseOptions = {
                    autosmooth: options.autosmooth,
                    shareVertices: options.shareVertices
                };

                wavefrontParser.parse(body, parseOptions, function(objects) {
                    store.objectToCache(key, filename, date, objects);
                    f(objects);
                });
            } else {
                f(objects);
            }
        });
    });

    return ret;
}

/**
 * Load a Wavefront OBJ from file. This asynchronously loads
 * the given file and constructs a model from its definition.
 * This function returns an initially empty model which will
 * be filled in with child models representing all the objects
 * from the loaded file when the file is loaded. It is valid
 * to render the returned model immediately, but it will be
 * empty until the file finishes loading.
 *
 * To be notified of the model being finished loading, you can
 * specify a 'success(model)' callback in the options parameter.
 * If an error occurred during loading, the 'error(request, message)'
 * callback will be called instead.
 *
 * @param ctx the context.
 * @param filename the filename.
 * @param options optional options.
 */
exports.load = function(ctx, filename, options) {
    var localPrefix = 'local:';
    var isLocal = (filename.indexOf(localPrefix) === 0);

    if (!isLocal && document.location.protocol.indexOf('file') === 0) {
        throw new Error('Cannot load external models in local mode');
    }

    var makeError = (function(stack) {
        return function(message) {
            var e = new Error(message);
            e.originalStack = stack;

            return e;
        };
    })((new Error()).stack);

    options = utils.merge({
        error: function(m) { throw makeError(m); },
        success: function() {},
        complete: function() {},
        autosmooth: false,
        shareVertices: true
    }, options);

    var ret = new Model(ctx, filename, options);

    // Load previous from cache if possible.
    var cached = objectCache[cacheKey(filename, options)];
    var fromCache = null;

    if (cached) {
        createModel(ctx, ret, cached.objects, options);
        options.complete(ret);

        fromCache = ret.children.slice(0);
    }

    if (isLocal) {
        new Store(function(store) {
            var localName = filename.slice(localPrefix.length);

            store.modelData(localName, function(store, model) {
                if (model !== null) {
                    try {
                        parseOrCachedObj(ctx, model.creationTime, filename, ret, model.data, fromCache, options);
                    } catch (e) {
                        console.error(e.stack);
                        options.error(e.message);
                    }
                } else {
                    options.error('Model not found');
                }
            });
        });
    } else {
        var backend;
        var url;

        if (filename.indexOf('http:') === 0 || filename.indexOf('https:') === 0) {
            url = 'm/';
            backend = true;
        } else {
            url = global.Settings.frontend.url('assets/models/');
            backend = false;
        }

        url += encodeURIComponent(filename);

        utils.get(url, {
            success: function(req, body) {
                try {
                    var date = new Date(req.getResponseHeader('Last-Modified'));
                    parseOrCachedObj(ctx, date, filename, ret, body, fromCache, options);
                } catch (e) {
                    console.error(e.stack);
                    options.error(e.message);
                }
            },

            error: function(req, e) {
                options.error(e ? e.message : req.responseText);
            },

            backend: backend,
            json: false
        });
    }

    return ret;
};

// vi:ts=4:et

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../app/store":8,"../utils/utils":52,"./geometry":20,"./model":23,"./rendergroup":28,"./rendergroups":29}],26:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');

/**
 * A simple plane model. Creates a simple plane geometry, centered around [0, 0, 0] for
 * the given dimensions.
 *
 * @param ctx the context.
 * @param dx the X size of the plane.
 * @param dz the Z size of the plane.
 * @param options optional options.
 * @constructor
 */
function Plane(ctx, dx, dz, options) {
    Model.call(this, ctx, 'plane', options);

    dx /= 2;
    dz /= 2;

    var vertices = [
        -dx, 0,  dz,
         dx, 0,  dz,
         dx, 0, -dz,
        -dx, 0, -dz
    ];

    var normals = [
         0,  1,  0,
         0,  1,  0,
         0,  1,  0,
         0,  1,  0
    ];

    var indices = [
         0,  1,  2,
         0,  2,  3
    ];

    if (options.doubleSided) {
        vertices.push(-dx, 0, -dz,
                       dx, 0, -dz,
                       dx, 0,  dz,
                      -dx, 0,  dz);

        normals.push(0, -1, 0,
                     0, -1, 0,
                     0, -1, 0,
                     0, -1, 0);

        indices.push(4, 5, 6,
                     4, 6, 7);
    }

    this.renderer = new RenderGroup(ctx, new Geometry(ctx, vertices, normals), indices);
}

Plane.__doc__ = {"description":"A simple plane model. Creates a simple plane geometry, centered around [0, 0, 0] for\nthe given dimensions.","kind":"class","refid":"Plane","params":[{"description":"the context.","name":"ctx"},{"description":"the X size of the plane.","name":"dx"},{"description":"the Z size of the plane.","name":"dz"},{"description":"optional options.","name":"options"}]};


Plane.prototype = Object.create(Model.prototype);
Plane.prototype.constructor = Plane;

module.exports = Plane;

// vi:ts=4:et

},{"./geometry":20,"./model":23,"./rendergroup":28}],27:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');

/**
 * A simple quad model. Creates a single quad geometry for
 * the given vertices.
 *
 * @param ctx the context.
 * @param p1 the position of the first vertex (math.vec3).
 * @param p2 the position of the second vertex (math.vec3).
 * @param p3 the position of the third vertex (math.vec3).
 * @param p4 the position of the fourth vertex (math.vec3).
 * @param options optional options.
 * @constructor
 */
function Quad(ctx, p1, p2, p3, p4, options) {
    Model.call(this, ctx, 'quad', options);

    var vertices = new Float32Array([
        p1[0], p1[1], p1[2],
        p2[0], p2[1], p2[2],
        p3[0], p3[1], p3[2],
        p4[0], p4[1], p4[2]
    ]);

    var normals = new Float32Array([
         0,  0,  1,
         0,  0,  1,
         0,  0,  1,
         0,  0,  1
    ]);

    var indices = new Uint16Array([
         0,  1,  2,
         0,  2,  3
    ]);

    this.renderer = new RenderGroup(ctx, new Geometry(ctx, vertices, normals), indices);
}

Quad.__doc__ = {"description":"A simple quad model. Creates a single quad geometry for\nthe given vertices.","kind":"class","refid":"Quad","params":[{"description":"the context.","name":"ctx"},{"description":"the position of the first vertex (math.vec3).","name":"p1"},{"description":"the position of the second vertex (math.vec3).","name":"p2"},{"description":"the position of the third vertex (math.vec3).","name":"p3"},{"description":"the position of the fourth vertex (math.vec3).","name":"p4"},{"description":"optional options.","name":"options"}]};


Quad.prototype = Object.create(Model.prototype);
Quad.prototype.constructor = Quad;

module.exports = Quad;

// vi:ts=2:et

},{"./geometry":20,"./model":23,"./rendergroup":28}],28:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('../utils/utils');

/**
 * Render an object from a geometry buffer. A RendeGroup is a wrapper
 * around an element array buffer, containing element indices into
 * an existing Geometry.
 *
 * @param ctx the context.
 * @param geometry a Geometry.
 * @param indices the indices in the geometry to render.
 * @param options optional options, defaults to <binding:gl.STATIC_DRAW, type:gl.TRIANGLES>.
 */
function RenderGroup(ctx, geometry, indices, options) {
    this._ibo = null;
    this._geometry = null;

    this.update(ctx, geometry, indices, options);
}

RenderGroup.__doc__ = {"description":"Render an object from a geometry buffer. A RendeGroup is a wrapper\naround an element array buffer, containing element indices into\nan existing Geometry.","kind":"function","refid":"RenderGroup","params":[{"description":"the context.","name":"ctx"},{"description":"a Geometry.","name":"geometry"},{"description":"the indices in the geometry to render.","name":"indices"},{"description":"optional options, defaults to <binding:gl.STATIC_DRAW, type:gl.TRIANGLES>.","name":"options"}]};


/**
 * Update the render group.
 *
 * @param ctx the context.
 * @param geometry a Geometry.
 * @param indices the indices in the geometry to render.
 * @param options optional options, defaults to <binding:gl.STATIC_DRAW, type:gl.TRIANGLES>.
 */
RenderGroup.prototype.update = function(ctx, geometry, indices, options) {
    var gl = ctx.gl;

    this.geometry = geometry;
    this.indices = indices;

    var opts = utils.merge({
        binding: gl.STATIC_DRAW,
        type: gl.TRIANGLES,
        aabbox: null
    }, options);

    this.type = opts.type;
    this.aabbox = opts.aabbox;

    if (this._ibo) {
        gl.deleteBuffer(this._ibo);
    }

    if (indices && (typeof indices !== 'object' || Object.getPrototypeOf(indices) !== Uint16Array.prototype)) {
        indices = new Uint16Array(indices);
    }

    this._ibo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, opts.binding);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    this.length = indices.length;
}

RenderGroup.prototype.update.__doc__ = {"description":"Update the render group.","kind":"function","refid":"RenderGroup#update","params":[{"description":"the context.","name":"ctx"},{"description":"a Geometry.","name":"geometry"},{"description":"the indices in the geometry to render.","name":"indices"},{"description":"optional options, defaults to <binding:gl.STATIC_DRAW, type:gl.TRIANGLES>.","name":"options"}]};
;

/**
 * Get all render parts of the render group. Note that this just returns
 * an array with a single element, this.
 */
RenderGroup.prototype.renderParts = function() {
    if (this.length === 0) {
        return [];
    }

    return [this];
}

RenderGroup.prototype.renderParts.__doc__ = {"description":"Get all render parts of the render group. Note that this just returns\nan array with a single element, this.","kind":"function","refid":"RenderGroup#renderParts"};
;

/**
 * Bind the render group in the given context.
 *
 * @param ctx the context.
 */
RenderGroup.prototype.bind = function(ctx) {
    var gl = ctx.gl;

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
}

RenderGroup.prototype.bind.__doc__ = {"description":"Bind the render group in the given context.","kind":"function","refid":"RenderGroup#bind","params":[{"description":"the context.","name":"ctx"}]};
;

/**
 * Unbind the render group from the given context.
 *
 * @param ctx the context.
 */
RenderGroup.prototype.unbind = function(ctx) {
    var gl = ctx.gl;

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}

RenderGroup.prototype.unbind.__doc__ = {"description":"Unbind the render group from the given context.","kind":"function","refid":"RenderGroup#unbind","params":[{"description":"the context.","name":"ctx"}]};
;

/**
 * Render the render group.
 *
 * @param ctx the context.
 */
RenderGroup.prototype.render = function(ctx) {
    var gl = ctx.gl;

    this.bind(ctx);

    ctx._renderedSomething = true;
    gl.drawElements(this.type, this.length, gl.UNSIGNED_SHORT, 0);

    this.unbind(ctx);
}

RenderGroup.prototype.render.__doc__ = {"description":"Render the render group.","kind":"function","refid":"RenderGroup#render","params":[{"description":"the context.","name":"ctx"}]};
;

module.exports = RenderGroup;

// vi:ts=4:et

},{"../utils/utils":52}],29:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('../utils/utils');

/**
 * A collection of render groups.
 */
function RenderGroups(options) {
	options = utils.merge({
		aabbox: null
	}, options);

    this.groups = [];
    this.aabbox = options.aabbox;
}

RenderGroups.__doc__ = {"description":"A collection of render groups.","kind":"function","refid":"RenderGroups"};


/**
 * Add a render group.
 *
 * @param group the group to add.
 */
RenderGroups.prototype.add = function(group) {
    this.groups.push(group);
}

RenderGroups.prototype.add.__doc__ = {"description":"Add a render group.","kind":"function","refid":"RenderGroups#add","params":[{"description":"the group to add.","name":"group"}]};
;

/**
 * Remove a render group.
 *
 * @param group the group to remove.
 */
RenderGroups.prototype.remove = function(group) {
    var idx = this.groups.indexOf(group);

    if (idx !== -1) {
        this.groups.splice(idx, 1);
    }
}

RenderGroups.prototype.remove.__doc__ = {"description":"Remove a render group.","kind":"function","refid":"RenderGroups#remove","params":[{"description":"the group to remove.","name":"group"}]};
;

/**
 * Get all render parts of the group.
 */
RenderGroups.prototype.renderParts = function() {
    return this.groups;
}

RenderGroups.prototype.renderParts.__doc__ = {"description":"Get all render parts of the group.","kind":"function","refid":"RenderGroups#renderParts"};
;

module.exports = RenderGroups;

// vi:ts=4:et

},{"../utils/utils":52}],30:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('../utils/utils');

function Texture(ctx, options) {
    var gl = ctx.gl;

    options = utils.merge({
        target: gl.TEXTURE_2D,

        filter: {
            mag: gl.NEAREST,
            min: gl.NEAREST
        },

        wrap: {
            s: gl.CLAMP_TO_EDGE,
            t: gl.CLAMP_TO_EDGE
        }
    }, options);

    this.id = gl.createTexture();
    this.target = options.target;

    this.bind(ctx);
    gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, options.filter.mag);
    gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, options.filter.min);
    gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, options.wrap.s);
    gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, options.wrap.t);
    this.unbind(ctx);
}

Texture.prototype.data = function(ctx, width, height, data, options) {
    var gl = ctx.gl;

    options = utils.merge({
        internalFormat: gl.RGBA,
        format: gl.RGBA,
        type: gl.UNSIGNED_BYTE,
        level: 0
    }, options);

    this.bind(ctx);
    gl.texImage2D(this.target,
                  options.level,
                  options.internalFormat,
                  width,
                  height,
                  0,
                  options.format,
                  options.type,
                  data);
    this.unbind(ctx);
};

Texture.prototype.bind = function(ctx, unit) {
    var gl = ctx.gl;

    if (!unit) {
        unit = 0;
    }

    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(this.target, this.id);
};

Texture.prototype.unbind = function(ctx) {
    ctx.gl.bindTexture(this.target, null);
};

module.exports = Texture;

// vi:ts=4:et

},{"../utils/utils":52}],31:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');

/**
 * A simple triangle model. Creates a single triangle geometry for
 * the given vertices.
 *
 * @param ctx the context.
 * @param p1 the position of the first vertex (math.vec3).
 * @param p2 the position of the second vertex (math.vec3).
 * @param p3 the position of the third vertex (math.vec3).
 * @param options optional options.
 * @constructor
 */
function Triangle(ctx, p1, p2, p3, options) {
    Model.call(this, ctx, 'triangle', options);

    var vertices = new Float32Array([
        p1[0], p1[1], p1[2],
        p2[0], p2[1], p2[2],
        p3[0], p3[1], p3[2]
    ]);

    var normals = new Float32Array([
         0,  0,  1,
         0,  0,  1,
         0,  0,  1
    ]);

    var indices = new Uint16Array([
         0,  1,  2
    ]);

    this.renderer = new RenderGroup(ctx, new Geometry(ctx, vertices, normals), indices);
}

Triangle.__doc__ = {"description":"A simple triangle model. Creates a single triangle geometry for\nthe given vertices.","kind":"class","refid":"Triangle","params":[{"description":"the context.","name":"ctx"},{"description":"the position of the first vertex (math.vec3).","name":"p1"},{"description":"the position of the second vertex (math.vec3).","name":"p2"},{"description":"the position of the third vertex (math.vec3).","name":"p3"},{"description":"optional options.","name":"options"}]};


Triangle.prototype = Object.create(Model.prototype);
Triangle.prototype.constructor = Triangle;

module.exports = Triangle;

// vi:ts=2:et

},{"./geometry":20,"./model":23,"./rendergroup":28}],32:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var Geometry = require('./geometry');
var RenderGroup = require('./rendergroup');
var math = require('../math/math');

/**
 * A simple ico sphere. Creates a simple ico sphere geometry, centered around [0, 0, 0] for
 * the given radius and number of subdivisions.
 *
 * @param ctx the context.
 * @param radius the radius of the sphere.
 * @param subdivisions the number of subdivisions to generate the sphere (minimal 1).
 * @param options optional options.
 * @constructor
 */
function UvSphere(ctx, radius, segments, rings, options) {
    Model.call(this, ctx, 'uvsphere', options);

    var vertices = [];
    var indices = [];
    var normals = [];

    if (segments < 3) {
        segments = 3;
    }

    if (rings < 3) {
        rings = 3;
    }

    // Top
    vertices.push(0, radius, 0);
    normals.push(0, 1, 0);

    var n, r, s;

    for (r = 0; r < rings - 2; r++) {
        var a = Math.PI * ((r + 1) / (rings - 1));
        var y = Math.cos(a) * radius;
        var zr = Math.sin(a) * radius;

        for (s = 0; s < segments; s++) {
            var b = 2 * Math.PI * (s / segments);

            var x = Math.sin(b) * zr;
            var z = Math.cos(b) * zr;

            n = math.vec3.normalize$([x, y, z]);

            vertices.push(x, y, z);
            normals.push(n[0], n[1], n[2]);
        }
    }

    n = (rings - 2) * segments + 2;

    // Bottom
    vertices.push(0, -radius, 0);
    normals.push(0, -1, 0);

    // Top cap
    var i = 1;

    while (i <= segments) {
        if (i != segments) {
            indices.push(i, i + 1, 0);
        } else {
            indices.push(i, 1, 0);
        }

        i++;
    }

    // Segmented rings in between
    for (r = 1; r < rings - 2; r++) {
        for (s = 1; s <= segments; s++) {
            if (s != segments) {
                indices.push(i, i + 1, i + 1 - segments,
                             i, i + 1 - segments, i - segments);
            } else {
                indices.push(i, i + 1 - segments, i + 1 - 2 * segments,
                             i, i + 1 - 2 * segments, i - segments);
            }

            i++;
        }
    }

    // Bottom cap
    i -= segments;

    while (i < n - 1) {
        if (i != n - 2) {
            indices.push(i, n - 1, i + 1);
        } else {
            indices.push(i, n - 1, n - 1 - segments);
        }

        i++;
    }

    this.renderer = new RenderGroup(ctx, new Geometry(ctx, vertices, normals), indices);
}

UvSphere.__doc__ = {"description":"A simple ico sphere. Creates a simple ico sphere geometry, centered around [0, 0, 0] for\nthe given radius and number of subdivisions.","kind":"class","refid":"UvSphere","params":[{"description":"the context.","name":"ctx"},{"description":"the radius of the sphere.","name":"radius"},{"description":"the number of subdivisions to generate the sphere (minimal 1).","name":"subdivisions"},{"description":"optional options.","name":"options"}]};


UvSphere.prototype = Object.create(Model.prototype);
UvSphere.prototype.constructor = UvSphere;

module.exports = UvSphere;

// vi:ts=4:et

},{"../math/math":18,"./geometry":20,"./model":23,"./rendergroup":28}],33:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Model = require('./model');
var math = require('../math/math');
var utils = require('../utils/utils');
var Texture = require('./texture');

/**
 * A basic view. A View is a collection of transform (inherited from model),
 * a projection matrix and a viewport. Note that you can use View.perspective
 * and View.orthographic to create respectively a perspective projection
 * view or a orthographic projection view. If viewport is not given (or null),
 * then the viewport will automatically track the canvas dimensions.
 *
 * Additionally, a view specifies various gl states, such as whether to enable
 * depth testing, blending and face culling (see the view's properties).
 *
 * @param ctx the context.
 * @param projection the projection matrix (math.mat4).
 * @param viewport the viewport (math.vec4).
 * @param options optional options.
 * @constructor
 */
function View(ctx, projection, viewport, options) {
    Model.call(this, ctx, options);

    this._projection = projection;
    this._projectionSet = false;

    this.options = utils.merge({
        color: null,
        depth: ctx.gl.LESS,
        blend: false,
        scissor: true,
        cull: {
            face: ctx.gl.BACK,
            direction: ctx.gl.CCW
        },
        interactive: true,
        buffer: null
    }, options);

    if (this.options.viewport && !viewport) {
        viewport = this.options.viewport;
    }

    /** The viewport, or unset to track the canvas dimensions. */
    this.viewport = viewport;

    /** The clear color, or null to disable clearing the color (defaults to null). */
    this.color = this.options.color;

    /** The depth function, or false to disable depth testing (defaults to gl.LESS). */
    this.depth = this.options.depth;

    /** The blend function ({sfactor:, dfactor:}), or false to disable blending (defaults to false). */
    this.blend = this.options.blend;

    /** Whether to enable the scissor test matching the viewport (defaults to true). */
    this.scissor = this.options.scissor;

    /** Whether to cull faces ({face:, direction:}), or false to disable culling (defaults to {face: gl.BACK, direction: gl.CCW}). */
    this.cull = this.options.cull;

    this._buffer = null;

    this._interactive = false;
    this.interactive(ctx, this.options.interactive);

    this.originTransform = math.transform.track(math.transform.create(), this, 'transform', function(out, tr) {
        return math.transform.invert(out, tr);
    });

    this.updateViewport(ctx);
}

View.__doc__ = {"description":"A basic view. A View is a collection of transform (inherited from model),\na projection matrix and a viewport. Note that you can use View.perspective\nand View.orthographic to create respectively a perspective projection\nview or a orthographic projection view. If viewport is not given (or null),\nthen the viewport will automatically track the canvas dimensions.\n\nAdditionally, a view specifies various gl states, such as whether to enable\ndepth testing, blending and face culling (see the view's properties).","kind":"class","refid":"View","params":[{"description":"the context.","name":"ctx"},{"description":"the projection matrix (math.mat4).","name":"projection"},{"description":"the viewport (math.vec4).","name":"viewport"},{"description":"optional options.","name":"options"}],"members":{"viewport":"The viewport, or unset to track the canvas dimensions.","color":"The clear color, or null to disable clearing the color (defaults to null).","depth":"The depth function, or false to disable depth testing (defaults to gl.LESS).","blend":"The blend function ({sfactor:, dfactor:}), or false to disable blending (defaults to false).","scissor":"Whether to enable the scissor test matching the viewport (defaults to true).","cull":"Whether to cull faces ({face:, direction:}), or false to disable culling (defaults to {face: gl.BACK, direction: gl.CCW})."}};


View.prototype = Object.create(Model.prototype);
View.prototype.constructor = View;

View.prototype.interactive = function(ctx, v) {
    if (typeof v === 'undefined') {
        return this._interactive;
    }

    if (this._interactive) {
        ctx._signals.off('event', this._onEvent, this);
    }

    if (v === false) {
        this._interactive = false;
        return;
    }

    this._interactive = utils.merge({
        origin: math.vec3.create(),

        rotate: {
            scrollSensitivity: 0.01,
            mouseSensitivity: 0.01,
        },

        translate: {
            mouseSensitivity: 1,
            scrollSensitivity: 0.1
        },

        zoom: {
            mouseSensitivity: 0.1,
            scrollSensitivity: 0.1,
            sensitivity: 0.1
        }
    }, v === true ? {} : v);

    this._interactive._mousePressed = null;

    ctx._signals.on('event', this._onEvent, this);

    ctx.gl.canvas.addEventListener('contextmenu', function(e) {
        e.preventDefault();
    });
};

View.prototype._rotateDxDy = function(dx, dy, s, origTransform) {
    if (typeof origTransform !== 'undefined') {
        math.transform.copy(this.transform, origTransform);
    }

    var lrotX = math.quat.setAxisAngle(math.quat.create(), this.transform.sideAxis(), -dy * s);

    var rot = math.quat.mul(math.quat.create(),
                            math.quat.setAxisAngle(math.quat.create(),
                                                   [0, 1, 0],
                                                   -dx * s),
                            lrotX);

    rot = math.quat.mul(rot, rot, this.transform.orientation);

    var v = math.vec3.subtract(math.vec3.create(), this.transform.position, this._interactive.origin);
    var otr = math.vec3.transformQuat(math.vec3.create(), v, math.quat.invert(math.quat.create(), this.transform.orientation));

    var tr = math.vec3.transformQuat(math.vec3.create(), otr, rot);
    math.transform.copy(this.transform, new math.transform(rot, math.vec3.add(tr, tr, this._interactive.origin)));
};

View.prototype._translateDxDy = function(dx, dy, sx, sy, origTransform) {
    if (typeof origTransform !== 'undefined') {
        math.transform.copy(this.transform, origTransform);
    }

    this.transform.translateSide(dx * sx).translateUp(dy * sy);
};

View.prototype._zoomDxDy = function(dx, dy, s, origTransform) {
    if (typeof origTransform !== 'undefined') {
        math.transform.copy(this.transform, origTransform);
    }

    this.transform.translateForward((dx + dy) * s);
};

View.prototype._onEvent = function(ctx, e) {
    var mp;

    switch (e.type) {
    case 'wheel':
        if (e.shiftKey) {
            // Translate
            this._translateDxDy(e.deltaX,
                                  e.deltaY,
                                  this._interactive.translate.scrollSensitivity,
                                  this._interactive.translate.scrollSensitivity);
        } else if (e.ctrlKey) {
            // Zoom
            this._zoomDxDy(e.deltaX, e.deltaY, this._interactive.zoom.scrollSensitivity);
        } else {
            // Rotate
            this._rotateDxDy(e.deltaX, e.deltaY, this._interactive.rotate.scrollSensitivity);
        }

        e.preventDefault();
        e.stopPropagation();
        break;
    case 'mousedown':
        this._interactive._mousePressed = {
            x: e.pageX,
            y: e.pageY,
            button: e.button,
            transform: this.transform.clone(),
            translation: null
        };
        break;
    case 'mousemove':
        mp = this._interactive._mousePressed;

        if (mp !== null && mp.button === 0) {
            if (e.shiftKey) {
                // Translate
                var l = math.vec3.len(math.vec3.subtract(math.vec3.create(),
                                                         mp.transform.position,
                                                         this._interactive.origin));

                var proj = this.projection();
                var vp = this.currentViewport();

                var sensitivity = this._interactive.translate.mouseSensitivity;

                var scale = {
                    x: (2 * l) / (proj[0] * vp[2]) * sensitivity,
                    y: (2 * l) / (proj[5] * vp[3]) * sensitivity
                };

                var d = {
                    x: mp.x - e.pageX,
                    y: e.pageY - mp.y
                };

                this._translateDxDy(d.x,
                                      d.y,
                                      scale.x,
                                      scale.y,
                                      mp.transform);

                this._interactive._mousePressed.translation = [d.x * scale.x, d.y * scale.y, 0];
            } else if (e.ctrlKey) {
                // Zoom
                this._zoomDxDy(e.pageX - mp.x,
                                 e.pageY - mp.y,
                                 this._interactive.zoom.mouseSensitivity,
                                 mp.transform);
            } else {
                // Rotate
                this._rotateDxDy(e.pageX - mp.x,
                                   e.pageY - mp.y,
                                   this._interactive.rotate.mouseSensitivity,
                                   mp.transform);
            }

            e.preventDefault();
            e.stopPropagation();
        }
        break;
    case 'mouseup':
        mp = this._interactive._mousePressed;

        if (mp !== null && mp.translation !== null) {
            math.vec3.add(this._interactive.origin, this._interactive.origin, mp.translation);
        }

        this._interactive._mousePressed = null;
        break;
    }
};

/**
 * Get the currently used viewport. If the viewport property is set, then
 * this function returns that. If not, then this function returns the automatically
 * computed viewport from the canvas.
 */
View.prototype.currentViewport = function() {
    if (this.viewport) {
        return this.viewport;
    } else {
        return this._viewport;
    }
}

View.prototype.currentViewport.__doc__ = {"description":"Get the currently used viewport. If the viewport property is set, then\nthis function returns that. If not, then this function returns the automatically\ncomputed viewport from the canvas.","kind":"function","refid":"View#currentViewport"};
;

View.prototype.bufferTextures = function(name) {
    return this._buffer.textureBuffers[name];
};

View.prototype.activeBufferTexture = function(name) {
    var buf = this.bufferTextures(name);

    return buf.textures[buf.active];
};

View.prototype.cycleBufferTextures = function(ctx, names) {
    var gl = ctx.gl;

    gl.bindFramebuffer(gl.FRAMEBUFFER, this._buffer.fbo);

    if (!names) {
        names = [];

        for (var k in this._buffer.textureBuffers) {
            names.push(k);
        }
    }

    for (var i = 0; i < names.length; i++) {
        var buffer = this._buffer.textureBuffers[names[i]];

        if (buffer.textures.length === 1) {
            continue;
        }

        buffer.active++;

        if (buffer.active >= buffer.textures.length) {
            buffer.active = 0;
        }

        gl.framebufferTexture2D(gl.FRAMEBUFFER,
                                buffer.attachment,
                                buffer.textureTarget,
                                buffer.textures[buffer.active].id, 0);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

View.prototype._viewportChanged = function(vp) {
    if (!this._viewport) {
        return true;
    }

    for (var i = 0; i < 4; i++) {
        if (this._viewport[i] != vp[i]) {
            return true;
        }
    }

    return false;
};

/**
 * Update the viewport of the view. This is called automatically
 * when the canvas dimensions change. When no explicit viewport is
 * set, the viewport is automatically updated to cover the canvas.
 *
 * @param ctx the context.
 */
View.prototype.updateViewport = function(ctx) {
    var gl = ctx.gl;
    var vp;

    if (!this.viewport) {
        vp = [0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight];
    } else {
        vp = [this.viewport[0], this.viewport[1], this.viewport[2], this.viewport[3]];

        if (vp[0] < 0) {
            vp[0] = gl.canvas.clientWidth + vp[0];
        }

        if (vp[1] < 0) {
            vp[1] = gl.canvas.clientHeight + vp[1];
        }
    }

    if (!this._viewportChanged(vp)) {
        return;
    }

    this._viewport = vp;

    var i, buffer, texture, k;

    if (this.options.buffer !== null) {
        if (this._buffer !== null) {
            for (k in this._buffer.textureBuffers) {
                buffer = this._buffer.textureBuffers[k];

                for (i = 0; i < buffer.textures.length; i++) {
                    texture = buffer.textures[i];

                    if (texture.target !== gl.TEXTURE_CUBE) {
                        gl.deleteTexture(texture.id);
                    }
                }
            }

            for (i = 0; i < this._buffer.cubes.length; i++) {
                gl.deleteTexture(this._buffer.cubes[i].id);
            }

            for (i = 0; i < this._buffer.renderBuffers.length; i++) {
                buffer = this._buffer.renderBuffers[i];
                gl.deleteRenderbuffer(buffer.id);
            }

            gl.deleteFramebuffer(this._buffer.fbo);
        }

        this._buffer = {
            fbo: gl.createFramebuffer(),
            textureBuffers: {},
            renderBuffers: [],
            cubes: []
        };

        gl.bindFramebuffer(gl.FRAMEBUFFER, this._buffer.fbo);

        var hasDepth = false;
        var hasColor = false;

        for (k in this.options.buffer) {
            var n = this.options.buffer[k];

            n = utils.merge({
                texture: {
                    target: gl.TEXTURE_2D,
                    internalFormat: gl.RGBA,
                    format: gl.RGBA,
                    type: gl.UNSIGNED_BYTE
                },

                attachment: gl.COLOR_ATTACHMENT0,
                n: 1
            }, n);

            var textures = [];

            if (n.attachment === gl.DEPTH_ATTACHMENT || n.attachment === gl.DEPTH_STENCIL_ATTACHMENT) {
                hasDepth = true;
            } else {
                hasColor = true;
            }

            for (i = 0; i < n.n; i++) {
                if (n.texture.target === gl.TEXTURE_CUBE) {
                    if (i >= this._buffer.cubes.length) {

                        texture = new Texture(ctx, n.texture);
                        this._buffer.cubes.push(texture);
                    } else {
                        texture = this._buffer.cubes[i];
                    }
                } else {
                    texture = new Texture(ctx, n.texture);
                }

                texture.data(ctx, vp[2], vp[3], null, n.texture);

                if (i === 0) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, n.attachment, n.texture.target, texture.id, 0);
                }

                textures.push(texture);
            }

            this._buffer.textureBuffers[k] = {
                textures: textures,
                attachment: n.attachment,
                internalFormat: n.texture.internalFormat,
                format: n.texture.format,
                type: n.texture.type,
                textureTarget: n.texture.target,
                active: 0
            };
        }

        var rb;

        if (!hasColor) {
            rb = gl.createRenderbuffer();

            gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, vp[2], vp[3]);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, rb);

            this._buffer.renderBuffers.push({
                id: rb,
                attachment: gl.COLOR_ATTACHMENT0
            });
        }

        if (!hasDepth) {
            rb = gl.createRenderbuffer();

            gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, vp[2], vp[3]);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rb);

            this._buffer.renderBuffers.push({
                id: rb,
                attachment: gl.DEPTH_ATTACHMENT
            });
        }

        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        if (status !== gl.FRAMEBUFFER_COMPLETE) {
            var msgs = {};

            msgs[gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'not all attachment points are complete';
            msgs[gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'not all attached images have the same dimensions';
            msgs[gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'no images are attached to the framebuffer';
            msgs[gl.FRAMEBUFFER_UNSUPPORTED] = 'combination of internal formats of attached images violates restrictions';
            msgs[36059] = 'incomplete draw buffer';

            throw new Error('Framebuffer not complete: ' + status + '(' + msgs[status] + ')');
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
}

View.prototype.updateViewport.__doc__ = {"description":"Update the viewport of the view. This is called automatically\nwhen the canvas dimensions change. When no explicit viewport is\nset, the viewport is automatically updated to cover the canvas.","kind":"function","refid":"View#updateViewport","params":[{"description":"the context.","name":"ctx"}]};
;

/**
 * Get/set the projection matrix.
 *
 * @param projection the projection matrix (math.mat4) to set.
 */
View.prototype.projection = function(projection) {
    if (typeof projection !== 'undefined') {
        this._projection = projection;
        this._projectionSet = true;
    } else {
        return this._projection;
    }
}

View.prototype.projection.__doc__ = {"description":"Get/set the projection matrix.","kind":"function","refid":"View#projection","params":[{"description":"the projection matrix (math.mat4) to set.","name":"projection"}]};
;

View.prototype.unbind = function(ctx) {
    var gl = ctx.gl;

    if (this._buffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
};

/**
 * Binds the view to the given context. This sets the various gl
 * states corresponding to the view's settings. Note that this
 * is normally automatically called by setting the view in the
 * rendering context and should not be called by users.
 *
 * @param ctx the context.
 */
View.prototype.bind = function(ctx) {
    var c = this.color;
    var gl = ctx.gl;

    if (this._buffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._buffer.fbo);

        for (var k in this._buffer.textureBuffers) {
            var buffer = this._buffer.textureBuffers[k];

            gl.framebufferTexture2D(gl.FRAMEBUFFER,
                                    buffer.attachment,
                                    buffer.textureTarget,
                                    buffer.textures[buffer.active].id,
                                    0);
        }
    }

    var vp = this._viewport;
    gl.viewport(vp[0], vp[1], vp[2], vp[3]);

    if (this.scissor) {
        gl.scissor(vp[0], vp[1], vp[2], vp[3]);
        gl.enable(gl.SCISSOR_TEST);
    } else {
        gl.disable(gl.SCISSOR_TEST);
    }

    var cbit = 0;

    if (c) {
        gl.clearColor(c[0], c[1], c[2], c[3]);
        cbit |= gl.COLOR_BUFFER_BIT;
    }

    if (this.depth !== false) {
        cbit |= gl.DEPTH_BUFFER_BIT;
        gl.enable(gl.DEPTH_TEST);

        if (this.depth !== true) {
            if (typeof this.depth.initial !== 'undefined') {
                gl.depthFunc(this.depth.func);
                gl.clearDepth(this.depth.initial);
            } else {
                gl.depthFunc(this.depth);
                gl.clearDepth(1.0);
            }
        } else {
            gl.depthFunc(gl.LESS);
        }
    } else {
        gl.disable(gl.DEPTH_TEST);
    }

    if (this.blend) {
        gl.enable(gl.BLEND);

        if (this.blend === true) {
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        } else {
            gl.blendFunc(this.blend.sfactor, this.blend.dfactor);
        }
    } else {
        gl.disable(gl.BLEND);
    }

    if (this.cull) {
        gl.enable(gl.CULL_FACE);
        gl.cullFace(this.cull.face);
        gl.frontFace(this.cull.direction);
    } else {
        gl.disable(gl.CULL_FACE);
    }

    if (cbit !== 0) {
        gl.clear(cbit);
    }
}

View.prototype.bind.__doc__ = {"description":"Binds the view to the given context. This sets the various gl\nstates corresponding to the view's settings. Note that this\nis normally automatically called by setting the view in the\nrendering context and should not be called by users.","kind":"function","refid":"View#bind","params":[{"description":"the context.","name":"ctx"}]};
;

View._makePerspective = function(fovy, aspect, near, far) {
    return math.mat4.perspective(math.mat4.create(), fovy / 180 * Math.PI, aspect, near, far);
};

/**
 * Create a view with a perspective projection. By default the viewport will be
 * set to track the canvas dimensions. The default viewport can be changed
 * by setting the .viewport property after construction. If aspect is null,
 * then the aspect ratio will be derived automatically from the canvas (and
 * updated as the canvas is being resized).
 *
 * @param ctx the context.
 * @param fovy the field of view (in degrees) in the Y direction.
 * @param aspect the view's aspect ratio, or null to track the canvas aspect ratio.
 * @param near the near clipping plane (> 0).
 * @param far the far clipping plane (> 0).
 */
View.perspective = function(ctx, fovy, aspect, near, far, options) {
    var ap = aspect;

    if (!aspect) {
        var w = ctx.gl.canvas.clientWidth;
        var h = ctx.gl.canvas.clientHeight;

        ap = w / h;
    }

    var ret = new View(ctx, View._makePerspective(fovy, ap, near, far), null, options);

    if (!aspect) {
        ret.updateViewport = function(ctx) {
            View.prototype.updateViewport.call(ret, ctx);

            if (ret._projectionSet) {
                return;
            }

            var w = ctx.gl.canvas.clientWidth;
            var h = ctx.gl.canvas.clientHeight;

            var ap = w / h;

            ret._projection = View._makePerspective(fovy, ap, near, far);
        };
    }

    return ret;
};

/**
 * Create a view with an orthographic projection.
 *
 * @param ctx the context.
 * @param bounds the [left, right, top, bottom] (math.vec4) clipping planes.
 * @param near the near clipping plane.
 * @param far the far clipping plane.
 */
View.orthographic = function(ctx, bounds, near, far, options) {
    if (!bounds) {
        bounds = [0, 1, 0, 1];
    }

    var b = bounds;
    return new View(ctx, math.mat4.ortho(math.mat4.create(), b[0], b[1], b[2], b[3], near, far), null, options);
};

module.exports = View;

// vi:ts=4:et

},{"../math/math":18,"../utils/utils":52,"./model":23,"./texture":30}],34:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function Signals() {
    this._events = {};
    this._emitter = {};
}

Signals.prototype._signal = function(cbs, args) {
    for (var i = 0; i < cbs.length; i++) {
        var cb = cbs[i];
        cb.cb.apply(cb.this ? cb.this : this, args);
    }
};

Signals.prototype.registerSignal = function(ev) {
    if (!(ev in this._events)) {
        this._events[ev] = [];
    }

    var cbs = this._events[ev];

    this._emitter[ev] = (function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift(this);

        this._signal(cbs, args);
    }).bind(this);

    return this._emitter[ev];
};

Signals.prototype.on = function(ev, cb, _this) {
    if (!(ev in this._events)) {
        this._events[ev] = [{cb: cb, this: _this}];
    } else {
        this._events[ev].push({cb: cb, this: _this});
    }
};

Signals.prototype.emit = function(ev) {
    var args = Array.prototype.slice.call(arguments, 1);

    if (ev in this._emitter) {
        this._emitter[ev].apply(this, args);
     } else {
        if (ev in this._events) {
            args.unshift(this);

            this._signal(this._events[ev], args);
        }
    }
};

Signals.prototype.off = function(ev, cb, _this) {
    if (ev in this._events) {
        var evs = this._events[ev];

        for (var i = 0; i < evs.length; i++) {
            if (evs[i].cb === cb && evs[i].this === _this) {
                evs.splice(i, 1);
                break;
            }
        }

        if (evs.length === 0) {
            delete this._events[ev];
        }
    }
};

module.exports = Signals;

// vi:ts=4:et

},{}],35:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var utils = require('./utils/utils');

// TODO: this isn't great
global.Settings = utils.merge({
    backend: {
        url: function(u) {
            return '/' + u;
        }
    },

    frontend: {
        dataQuery: function(hash) {
            return '/d/' + hash;
        },

        url: function(u) {
        	return '/' + u;
        }
    },

    hooks: {}
}, global.Settings);

global.app = require('./app/app');

// vi:ts=4:et

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app/app":1,"./utils/utils":52}],36:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function Button(settings) {
    if (typeof settings === 'string') {
        settings = {
            value: settings
        };
    }

    Widget.call(this, 'button', this.create('div'), utils.merge({}, settings));

    this.e.addEventListener('click', this._onClick.bind(this));
    this.e.addEventListener('dblclick', this._onDblclick.bind(this));

    this._onClickEvent = this.registerSignal('click');
    this._onDblclickEvent = this.registerSignal('dblclick');
}

Button.prototype = Object.create(Widget.prototype);
Button.prototype.constructor = Button;

Button.prototype._valueUpdated = function() {
    if (typeof this._value === 'string') {
        this.e.textContent = this._value;
    } else if (typeof this._value.text !== 'undefined') {
        this.e.textContent = this._value.text;
    } else if (typeof this._value.markup !== 'undefined') {
        this.e.innerHTML = this._value.markup;
    }
};

Button.prototype._onClick = function(e) {
    if (this.sensitive()) {
        this._onClickEvent(e);
    }

    e.preventDefault();
    e.stopPropagation();
};

Button.prototype._onDblclick = function(e) {
    if (this.sensitive()) {
        this._onDblclickEvent(e);
    }

    e.preventDefault();
    e.stopPropagation();
};

module.exports = Button;

// vi:ts=4:et

},{"../utils/utils":52,"./widget":51}],37:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var Popup = require('./popup');
var utils = require('../utils/utils');
var MouseTracker = require('./mousetracker');
var math = require('../math/math');

function ColorPicker(settings) {
    var e = this.create('div', {
        children: this.create('div', {
            classes: 'color-background',
            children: this.create('div', {
                classes: 'color',
                children: this.create('div', {
                    classes: 'highlight'
                })
            })
        })
    });

    this._color = e.querySelector('.color');

    this._value = math.vec3(0, 0, 0);
    this._hsv = this._rgbToHsv(this._value);

    Widget.call(this, 'color-picker', e, utils.merge({
    }, settings));

    this._color.addEventListener('click', this._showPopup.bind(this));
}

ColorPicker.prototype = Object.create(Widget.prototype);
ColorPicker.prototype.constructor = ColorPicker;

ColorPicker.prototype._rgbToHsv = function(rgb, h) {
    var min = Math.min(rgb[0], rgb[1], rgb[2]);
    var max = Math.max(rgb[0], rgb[1], rgb[2]);

    var s;
    var v = max;

    var delta = max - min;

    if (delta !== 0) {
        if (max !== 0) {
            s = delta / max;
        } else {
            s = 0;
            h = -1;
        }

        if (rgb[0] === max) {
            h = (rgb[1] - rgb[2]) / delta;
        } else if (rgb[1] === max) {
            h = 2 + (rgb[2] - rgb[0]) / delta;
        } else {
            h = 4 + (rgb[0] - rgb[1]) / delta;
        }

        h *= 60;

        if (h < 0) {
            h += 360;
        }
    } else {
        if (typeof h === 'undefined') {
            h = 0;
        }

        s = 0;
    }

    if (rgb.length > 3) {
        return math.vec4(h, s, v, rgb[3]);
    } else {
        return math.vec3(h, s, v);
    }
};

ColorPicker.prototype._hsvToRgb = function(hsv) {
    var c = hsv[2] * hsv[1];
    var h = hsv[0] / 60;
    var x = c * (1 - Math.abs(h % 2 - 1));
    var rgb;

    if (h < 1) {
        rgb = [c, x, 0];
    } else if (h < 2) {
        rgb = [x, c, 0];
    } else if (h < 3) {
        rgb = [0, c, x];
    } else if (h < 4) {
        rgb = [0, x, c];
    } else if (h < 5) {
        rgb = [x, 0, c];
    } else {
        rgb = [c, 0, x];
    }

    var m = hsv[2] - c;

    if (hsv.length > 3) {
        return math.vec4(rgb[0] + m, rgb[1] + m, rgb[2] + m, hsv[3]);
    } else {
        return math.vec3(rgb[0] + m, rgb[1] + m, rgb[2] + m);
    }
};

ColorPicker.prototype._showPopup = function() {
    var content = this.create('div', {
        classes: 'ui-color-picker-popup',
        children: [
            this.create('div', {
                classes: 'hue',
                children: this.create('div', {
                    classes: 'pick'
                })
            }),

            this.create('div', {
                classes: 'area',
                children: this.create('div', {
                    classes: 'pick'
                })
            }),

            this.create('div', {
                classes: 'alpha',
                children: this.create('div', {
                    classes: 'fg',
                    children: this.create('div', {
                        classes: 'pick'
                    })
                })
            })
        ]
    });

    var hsv = this._rgbToHsv(this._value);

    var svpick = content.querySelector('.area .pick');
    var hpick = content.querySelector('.hue .pick');
    var svarea = content.querySelector('.area');
    var harea = content.querySelector('.hue');

    var alphaArea = content.querySelector('.alpha');
    var alphaPick = content.querySelector('.alpha .pick');

    hpick.style.top = ((hsv[0] / 360) * 100) + '%';

    svpick.style.left = (hsv[1] * 100) + '%';
    svpick.style.top = ((1 - hsv[2]) * 100) + '%';

    var bg = this._hsvToRgb([hsv[0], 1, 1]);
    svarea.style.backgroundColor = this._rgbToHex(bg);

    var svTracker = new MouseTracker(svarea);

    var updateSv = function(sender, e) {
        this._updateSv(svarea, svpick, e);
    };

    svTracker.on('mousedown', updateSv, this);
    svTracker.on('mouseup', updateSv, this);
    svTracker.on('mousemove', updateSv, this);

    var hTracker = new MouseTracker(harea);

    var updateH = function(sender, e) {
        this._updateH(harea, hpick, svarea, e);
    };

    hTracker.on('mousedown', updateH, this);
    hTracker.on('mouseup', updateH, this);
    hTracker.on('mousemove', updateH, this);

    if (this._value.length > 3) {
        alphaPick.style.left = (this._value[3] * 100) + '%';

        var alphaTracker = new MouseTracker(alphaArea);

        var updateAlpha = function(sender, e) {
            this._updateAlpha(alphaArea, alphaPick, e);
        };

        alphaTracker.on('mousedown', updateAlpha, this);
        alphaTracker.on('mouseup', updateAlpha, this);
        alphaTracker.on('mousemove', updateAlpha, this);
    } else {
        alphaArea.classList.add('hidden');
    }

    new Popup(content, this.e);
};

ColorPicker.prototype._clip = function(v, a, b) {
    if (v < a) {
        return a;
    } else if (v > b) {
        return b;
    } else {
        return v;
    }
};

ColorPicker.prototype._updateAlpha = function(alphaArea, alphaPick, e) {
    var pos = this.pagePosition(alphaArea);
    var w = alphaArea.offsetWidth;

    pos.x += 1;

    var alpha = (this._clip(e.pageX, pos.x, pos.x + w) - pos.x) / w;
    alphaPick.style.left = (alpha * 100) + '%';

    this.value(math.vec4(this._value[0], this._value[1], this._value[2], alpha));
};

ColorPicker.prototype._updateSv = function(svarea, svpick, e) {
    var pos = this.pagePosition(svarea);

    pos.x += 1;
    pos.y += 1;

    var w = svarea.clientWidth;
    var h = svarea.clientHeight;

    var x = (this._clip(e.pageX, pos.x, pos.x + w) - pos.x) / w;
    var y = 1 - (this._clip(e.pageY, pos.y, pos.y + h) - pos.y) / h;

    svpick.style.left = (x * 100) + '%';
    svpick.style.top = ((1 - y) * 100) + '%';

    this._hsv[1] = x;
    this._hsv[2] = y;

    this.value(this._hsvToRgb(this._hsv));
};

ColorPicker.prototype._updateH = function(harea, hpick, svarea, e) {
    var pos = this.pagePosition(harea);
    var h = harea.offsetHeight;

    pos.y += 1;

    var y = this._clip(e.pageY, pos.y, pos.y + h);

    this._hsv[0] = ((y - pos.y) / h) * 360;

    hpick.style.top = ((this._hsv[0] / 360) * 100) + '%';

    var bg = this._hsvToRgb([this._hsv[0], 1, 1]);
    svarea.style.backgroundColor = this._rgbToHex(bg);

    this.value(this._hsvToRgb(this._hsv));
};

ColorPicker.prototype._toHex = function(v) {
    v *= 255;

    var h = '0123456789abcdef';
    return h[v >> 4] + h[v & 0x0f];
};

ColorPicker.prototype._rgbToHex = function(rgb) {
    var ret = '#';

    for (var i =0 ; i < 3; i++) {
        ret += this._toHex(rgb[i]);
    }

    return ret;
};

ColorPicker.prototype._valueUpdated = function() {
    this._color.style.backgroundColor = this._rgbToHex(this._value);

    if (this._value.length > 3) {
        this._color.style.opacity = this._value[3];
    }

    this._hsv = this._rgbToHsv(this._value, this._hsv[0]);
};

module.exports = ColorPicker;

// vi:ts=4:et

},{"../math/math":18,"../utils/utils":52,"./mousetracker":41,"./popup":45,"./widget":51}],38:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var Spinner = require('./spinner');
var Progress = require('./progress');
var Spinner = require('./spinner');
var utils = require('../utils/utils');

function FilesReader(files, settings) {
    var e = this.create('table');

    this._files = {};

    var countdown = files.length;

    for (var i = 0; i < files.length; i++) {
        var f = files[i];
        var reader = new FileReader(f);

        var pos = f.name.lastIndexOf('/');
        var name;

        if (pos === -1) {
            name = f.name;
        } else {
            name = f.name.slice(pos + 1);
        }

        var prg = new Progress();

        var row = this.create('tr', {
            children: [
                this.create('td', {
                    classes: 'file',
                    textContent: name
                }),

                this.create('td', {
                    classes: 'progress',
                    children: prg.e
                }),

                this.create('td', {
                    classes: 'percentage',
                    textContent: '0%'
                })
            ]
        });

        var perc = row.querySelector('.percentage');

        prg.on('notify::value', (function(perc, p, v) {
            perc.textContent = Math.round(v * 100) + '%';
        }).bind(this, perc));

        e.appendChild(row);

        reader.onprogress = (function(prg, e) {
            var f = e.loaded / e.total;
            prg.value(f);
        }).bind(this, prg);

        reader.onloadend = (function(f, row, perc, e) {
            var ret = null;

            countdown--;

            if (e.loaded !== e.total) {
                row.classList.add('error');
                perc.textContent = '!';

                this._files[f.name].finished = true;
            } else {
                row.classList.add('ok');

                // Add spinner to indicate finishing up the load
                perc.textContent = '';

                var spinner = new Spinner();
                perc.appendChild(spinner.e);

                this._files[f.name].spinner = spinner;

                spinner.start();
                ret = e.target.result;
            }

            this._onLoaded(f, ret);

            if (countdown === 0) {
                this._onFinished();
            }
        }).bind(this, f, row, perc);

        this._files[f.name] = {
            file: f,
            row: row,
            percentage: perc,
            spinner: null,
            finished: false
        };

        reader.readAsText(f, 'utf-8');
    }

    Widget.call(this, 'files-reader', e, utils.merge({}, settings));

    this._onLoaded = this.registerSignal('loaded');
    this._onFinished = this.registerSignal('finished');
}

FilesReader.prototype = Object.create(Widget.prototype);
FilesReader.prototype.constructor = FilesReader;

FilesReader.prototype.finished = function(f, ok) {
    if (!(f.name in this._files)) {
        return;
    }

    var ff = this._files[f.name];

    if (!ff.finished) {
        ff.spinner.cancel();
        ff.percentage.removeChild(ff.spinner.e);

        if (ok) {
            ff.percentage.textContent = '✓';
        } else {
            ff.row.classList.remove('ok');
            ff.row.classList.remove('error');

            ff.percentage.textContent = '!';
        }

        ff.row.classList.add('finished');
        ff.finished = true;
    }
};

module.exports = FilesReader;

// vi:ts=4:et

},{"../utils/utils":52,"./progress":47,"./spinner":49,"./widget":51}],39:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function Grid(settings) {
    Widget.call(this, 'grid', this.create('table'), utils.merge({
        children: [],
        columns: 2
    }, settings));

    this._row = null;
    this._col = 0;
    this._spans = [];

    if (this._settings.children) {
        for (var i = 0; i < this._settings.children.length; i++) {
            this.add(this._settings.children[i]);
        }
    }
}

Grid.prototype = Object.create(Widget.prototype);
Grid.prototype.constructor = Grid;

Grid.prototype._reduceRowspan = function() {
    var i = 0;

    while (i < this._spans.length) {
        var rsp = this._spans[i];

        if (rsp.rowspan) {
            rsp.rowspan--;

            if (rsp.rowspan === 0) {
                this._spans.splice(i, 1);
                continue;
            } else {
                i++;
            }
        }

        if (this._col === rsp.column) {
            this._col += rsp.colspan;
        }
    }
};

Grid.prototype.add = function(child) {
    while (this._row === null || this._col >= this._settings.columns) {
        this._row = this.create('tr', {
            parent: this.e
        });

        this._col = 0;
        this._reduceRowspan();
    }

    this.create('td', {
        parent: this._row,
        children: child.e
    });

    this.children.push(child);

    if (typeof child._settings.colspan !== 'undefined' ||
        typeof child._settings.rowspan !== 'undefined') {
        var span = {
            colspan: child._settings.colspan || 1,
            rowspan: child._settings.rowspan || 1,
            column: this._col
        };

        this._col += span.colspan;

        for (var i = 0; i < this._spans; i++) {
            if (this._spans[i] > this._col) {
                this._spans[i].splice(i, 0, span);
                return;
            }
        }

        this._spans.push(span);
    } else {
        this._col++;
    }
};

module.exports = Grid;

// vi:ts=4:et

},{"../utils/utils":52,"./widget":51}],40:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function Label(settings) {
    Widget.call(this, 'label', this.create('span'), utils.merge({}, settings));
}

Label.prototype = Object.create(Widget.prototype);
Label.prototype.constructor = Label;

Label.prototype._valueUpdated = function() {
    if (typeof this._value === 'string') {
        this.e.textContent = this._value;
    } else if (typeof this._value.text !== 'undefined') {
        this.e.textContent = this._value.text;
    } else if (typeof this._value.markup !== 'undefined') {
        this.e.innerHTML = this._value.markup;
    }
};

module.exports = Label;

// vi:ts=4:et

},{"../utils/utils":52,"./widget":51}],41:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Signals = require('../signals/signals');

function MouseTracker(e) {
    Signals.call(this);

    e.addEventListener('mousedown', this._onMouseDown.bind(this));

    this._emitMouseDown = this.registerSignal('mousedown');
    this._emitMouseUp = this.registerSignal('mouseup');
    this._emitMouseMove = this.registerSignal('mousemove');
}

MouseTracker.prototype = Object.create(Signals.prototype);
MouseTracker.prototype.constructor = MouseTracker;

MouseTracker.prototype._onMouseDown = function(e) {
    this._onMouseMove = (function(e) {
        this._emitMouseMove(e);

        e.preventDefault();
        e.stopPropagation();
    }).bind(this);

    this._onMouseUp = (function(e) {
        window.removeEventListener('mousemove', this._onMouseMove);
        window.removeEventListener('mouseup', this._onMouseUp);

        this._emitMouseUp(e);

        e.preventDefault();
        e.stopPropagation();
    }).bind(this);

    window.addEventListener('mousemove', this._onMouseMove);
    window.addEventListener('mouseup', this._onMouseUp);

    this._emitMouseDown(e);

    e.preventDefault();
    e.stopPropagation();
};

module.exports = MouseTracker;

// vi:ts=4:et

},{"../signals/signals":34}],42:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function MultiSwitch(settings) {
    this._value = null;

    settings = utils.merge({
        values: [0, 1]
    }, settings);

    var cols = [];
    var n = settings.values.length;
    var p = Math.floor(1 / n * 100);

    var i;

    for (i = 0; i < n; i++) {
        cols.push(this.create('col', {
            width: p + '%'
        }));
    }

    var tds = [];

    this._values = [];
    this._valueMap = {};

    for (i = 0; i < n; i++) {
        var val = settings.values[i];

        if (typeof val !== 'object') {
            val = {
                title: null,
                name: val,
                value: val,
                sensitive: true
            };
        } else {
            val = utils.merge({
                sensitive: true,
                title: null
            }, val);

            val.sensitive = !!val.sensitive;
        }

        val.td = this.create('td', {
            textContent: val.name
        });

        if (!val.sensitive) {
            val.td.classList.add('insensitive');
        } else if (typeof settings.value === 'undefined' && typeof settings.bind === 'undefined') {
            // Set initial value to the first sensitive value
            settings.value = val.value;
        }

        if (val.title) {
            val.td.title = val.title;
        }

        this._values.push(val);
        this._valueMap[val.value] = val;

        if (val.sensitive) {
            val.td.addEventListener('click', (function(val, e) {
                this.value(val.value);

                e.preventDefault();
                e.stopPropagation();
            }).bind(this, val));
        }

        tds.push(val.td);
    }

    this._active = null;

    Widget.call(this, 'multi-switch', this.create('table', {
        children: [
            this.create('colgroup', {
                children: cols
            }),

            this.create('tr', {
                children: tds
            })
        ]
    }), settings);
}

MultiSwitch.prototype = Object.create(Widget.prototype);
MultiSwitch.prototype.constructor = MultiSwitch;

MultiSwitch.prototype._transformValue = function(v) {
    var val = this._valueMap[v];

    if (val && !val.sensitive) {
        return this._value;
    }

    return val;
};

MultiSwitch.prototype._valueUpdated = function() {
    var val = this._valueMap[this._value];

    if (val) {
        if (this._active !== null) {
            this._active.classList.remove('active');
        }

        this._active = val.td;
        this._active.classList.add('active');
    }
};

module.exports = MultiSwitch;

// vi:ts=4:et

},{"../utils/utils":52,"./widget":51}],43:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var MultiSwitch = require('./multiswitch');
var utils = require('../utils/utils');

function OnOff(settings) {
    this._value = false;

    MultiSwitch.call(this, utils.merge({
        values: [
            { name: 'Off', value: false },
            { name: 'On', value: true }
        ]
    }, settings));

    this.e.classList.add('ui-on-off');
}

OnOff.prototype = Object.create(MultiSwitch.prototype);
OnOff.prototype.constructor = OnOff;

OnOff.prototype._valueTransform = function(v) {
    return !!v;
};

module.exports = OnOff;

// vi:ts=4:et

},{"../utils/utils":52,"./multiswitch":42}],44:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');

function Panel(p) {
    Widget.call(this, 'panel', null, { wrap: p });

    if (this.e.classList.contains('vertical')) {
        this._orientation = Panel.Orientation.VERTICAL;
    } else {
        this._orientation = Panel.Orientation.HORIZONTAL;
    }

    var children = this.childElements();

    this.child1 = children[0];
    this.sep = children[1];
    this.child2 = children[2];

    this._onMousedown = this._onMousedownReal.bind(this);
    this._onMouseup = this._onMouseupReal.bind(this);
    this._onMousemove = this._onMousemoveReal.bind(this);

    this._onResized = this.registerSignal('resized');

    this.sep.addEventListener('mousedown', this._onMousedown);
}

Panel.prototype = Object.create(Widget.prototype);
Panel.prototype.constructor = Panel;

Panel.Orientation = {
    HORIZONTAL: 0,
    VERTICAL: 1
};

Panel.prototype.position = function(value) {
    if (typeof value === 'undefined') {
        if (this.child1.style.flexBasis) {
            return parseInt(this.child1.style.flexBasis);
        } else {
            return null;
        }
    }

    if (value !== null) {
        this.child1.style.flexBasis = value + 'px';
    }
};

Panel.prototype._onMousedownReal = function(e) {
    window.addEventListener('mousemove', this._onMousemove);
    window.addEventListener('mouseup', this._onMouseup);

    var p = this.pagePosition(this.sep);

    if (this._orientation == Panel.Orientation.VERTICAL) {
        this._doffset = e.pageY - p.y;
        document.body.style.cursor = 'ns-resize';
    } else {
        this._doffset = e.pageX - p.x;
        document.body.style.cursor = 'ew-resize';
    }

    e.preventDefault();
};

Panel.prototype._onMouseupReal = function(e) {
    window.removeEventListener('mousemove', this._onMousemove);
    window.removeEventListener('mouseup', this._onMouseup);

    document.body.style.cursor = '';

    e.preventDefault();
};

Panel.prototype._onMousemoveReal = function(e) {
    var d;

    var pagepos = this.pagePosition();

    if (this._orientation == Panel.Orientation.VERTICAL) {
        d = e.pageY - pagepos.y;
    } else {
        d = e.pageX - pagepos.x;
    }

    this.child1.style.flexBasis = (d - this._doffset) + 'px';

    this._onResized();

    e.preventDefault();
};

module.exports = Panel;

// vi:ts=4:et

},{"./widget":51}],45:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');

function Popup(child, on) {
    this._child = child;
    this._on = on;
    this._build();

    Widget.call(this, 'popup', null, { wrap: this._outer });

    this._onWindowMousedown = (function(e) {
        var ppos = this.pagePosition(this._outer);

        if (e.clientX < ppos.x || e.clientX > ppos.x + this._outer.offsetWidth ||
            e.clientY < ppos.y || e.clientY > ppos.y + this._outer.offsetHeight) {
            this.destroy();
        }
    }).bind(this);

    this._onWindowKeydown = (function(e) {
        if (e.keyCode === 27) {
            this.destroy();
        }
    }).bind(this);

    window.addEventListener('mousedown', this._onWindowMousedown);
    window.addEventListener('keydown', this._onWindowKeydown);

    this._onDestroy = this.registerSignal('destroy');
}

Popup.on = function(on, cb) {
    var popup = null;
    var widget = null;

    if (Widget.prototype.isPrototypeOf(on)) {
        widget = on;
        on = widget.e;
    }

    on.addEventListener('mousedown', function() {
        if (widget && !widget.sensitive()) {
            return;
        }

        if (!popup) {
            var f;

            f = function() {
                on.removeEventListener('mouseup', f);

                var r = function(p) {
                    popup = p;

                    if (p) {
                        popup = p;
                        popup.on('destroy', function() {
                            popup = null;
                        });
                    }
                };

                r(cb(r));
            };

            on.addEventListener('mouseup', f);
        }
    });
};

Popup.prototype = Object.create(Widget.prototype);
Popup.prototype.constructor = Popup;

Popup.prototype.destroy = function() {
    if (this._outer) {
        document.body.removeChild(this._outer);
        this._outer = null;

        window.removeEventListener('mousedown', this._onWindowMousedown);
        window.removeEventListener('keydown', this._onWindowKeydown);

        this._onDestroy();
    }
};

Popup.prototype.content = function(c) {
    if (typeof c === 'undefined') {
        return this._child;
    }

    this._content.removeChild(this._child);

    this._child = c;
    this._content.appendChild(this._child);
};

Popup.prototype._build = function() {
    var outer = document.createElement('div');
    outer.classList.add('ui-popup');

    document.body.appendChild(outer);

    var arrow = document.createElement('div');
    arrow.classList.add('arrow');

    outer.appendChild(arrow);

    var content = document.createElement('div');
    content.classList.add('content');
    content.appendChild(this._child);

    this._content = content;

    outer.appendChild(content);

    var epos = this.pagePosition(this._on);
    epos.width = this._on.offsetWidth;
    epos.height = this._on.offsetHeight;

    var medim = {
        width: outer.offsetWidth,
        height: outer.offsetHeight
    };

    var pagedim = {
        width: document.body.offsetWidth,
        height: document.body.offsetHeight
    };

    var pos = {
        x: epos.x + epos.width / 2 - medim.width / 2,
        y: epos.y + epos.height + 14
    };

    if (pos.x + medim.width > pagedim.width - 12) {
        pos.x = pagedim.width - medim.width - 12;
    }

    var apos = epos.x + epos.width / 2 - pos.x;

    if (apos < 24) {
        apos = 24;
    } else if (apos > medim.width - 24) {
        apos = medim.width - 24;
    }

    arrow.style.right = (medim.width - apos) + 'px';

    if (pos.y + medim.height > pagedim.height && epos.y - medim.height - 14 >= 0) {
        pos.y = epos.y - medim.height - 14;
        arrow.classList.add('down');
    } else {
        arrow.classList.add('up');
    }

    outer.style.right = (pagedim.width - (pos.x + medim.width)) + 'px';
    outer.style.top = pos.y + 'px';

    this._outer = outer;
};

module.exports = Popup;

// vi:ts=4:et

},{"./widget":51}],46:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var Button = require('./button');
var Program = require('../app/program');

function ProgramsBar(e, app) {
    Widget.call(this, 'programs-bar', null, { wrap: e });

    this._document = null;
    this._showDelete = null;

    this.document(app.document);

    app.on('notify::document', function() {
        this.document(app.document);
    }, this);

    this._ul = e.querySelector('ul');

    this._newProgram = new Button({ wrap: e.querySelector('#new-program') });
    this._newProgram.on('click', this._onNewProgramClick, this);

    this._newProgramName = e.querySelector('#new-program-name');
    this._newProgramName.addEventListener('keypress', this._onNewProgramNameKeypress.bind(this));
}

ProgramsBar.prototype = Object.create(Widget.prototype);
ProgramsBar.prototype.constructor = Widget;

ProgramsBar.prototype._onNewProgramNameKeypress = function(e) {
    if (e.keyCode === 13) {
        this._onNewProgramClick(this._newProgram, e);
    }
};

ProgramsBar.prototype.document = function(document) {
    if (typeof document === 'undefined') {
        return this._document;
    }

    if (this._document === document) {
        return;
    }

    var i, p;

    if (this._document !== null) {
        this._document.off('notify::active-program', this._onActiveProgramChanged, this);
        this._document.off('program-added', this._onProgramAdded, this);
        this._document.off('program-removed', this._onProgramRemoved, this);

        for (i = 0; i < this._document.programs.length; i++) {
            p = this._document.programs[i];
            this._onProgramRemoved(this._document, p, true);
        }
    }

    this._document = document;

    if (this._document !== null) {
        this._document.on('notify::active-program', this._onActiveProgramChanged, this);
        this._document.on('program-added', this._onProgramAdded, this);
        this._document.on('program-removed', this._onProgramRemoved, this);

        for (i = 0; i < this._document.programs.length; i++) {
            p = this._document.programs[i];
            this._onProgramAdded(this._document, p);
        }

        this._onActiveProgramChanged();
    }
};

ProgramsBar.prototype._uniqueProgramName = function(name) {
    var names = {};

    var i;

    for (i = 0; i < this._document.programs.length; i++) {
        names[this._document.programs[i].name()] = true;
    }

    i = 0;
    var uname;

    while (true) {
        uname = name;

        if (i !== 0) {
            uname += ' ' + i;
        }

        if (!(uname in names)) {
            break;
        }

        i++;
    }

    return uname;
};

ProgramsBar.prototype._onNewProgramClick = function(button, e) {
    var name = this._newProgramName.value.trim();

    if (name.length === 0) {
        this._newProgramName.focus();
        return;
    }

    var prg = Program.default();
    var uname = this._uniqueProgramName(name);

    prg.name(uname);
    this._document.addProgram(prg);
    this._document.activeProgram(prg);

    this._newProgramName.value = '';

    e.preventDefault();
    e.stopPropagation();
};

ProgramsBar.prototype._findByName = function(name) {
    return this._ul.querySelector('[data-program-name=' + JSON.stringify(name) + ']');
};

ProgramsBar.prototype._insertProgramItem = function(program, item) {
    var lis = this._ul.querySelectorAll('li');
    var found = null;

    for (var i = 0; i < lis.length; i++) {
        var attr = lis[i].getAttribute('data-program-name');
        if (!attr || program.name() < attr) {
            found = lis[i];
            break;
        }
    }

    this._ul.insertBefore(item, found);
};

ProgramsBar.prototype._displayName = function(program) {
    var name = program.name();

    if (program.isDefault()) {
        return '► ' + name;
    }

    return name;
};

ProgramsBar.prototype._onProgramNameChanged = function(program, prevname) {
    var item = this._findByName(prevname);

    if (item) {
        item.setAttribute('data-program-name', program.name());
        item.querySelector('span.name').textContent = this._displayName(program);

        this._ul.removeChild(item);
        this._insertProgramItem(program, item);
    }
};

ProgramsBar.prototype._onActiveProgramChanged = function() {
    var sel = this._ul.querySelector('li.selected');

    if (sel) {
        sel.classList.remove('selected');
    }

    var p = this._document.activeProgram();
    sel = this._findByName(p.name());

    if (sel) {
        sel.classList.add('selected');
    }

    if (this._showDelete !== null && this._showDelete.element !== sel) {
        this._onProgramToggleDelete(this._showDelete.element, this._showDelete.program);
    }
};

ProgramsBar.prototype._onProgramClick = function(program) {
    this._document.activeProgram(program);
};

ProgramsBar.prototype._onProgramToggleDelete = function(elem, program) {
    var del;

    if (elem.classList.contains('deleting')) {
        elem.classList.remove('deleting');

        del = elem.querySelector('div.delete');
        del.classList.remove('animate-in');

        this._showDelete = null;

        setTimeout(function() {
            elem.removeChild(del);
        }, 300);
    } else {
        elem.classList.add('deleting');

        del = document.createElement('div');
        del.classList.add('delete');
        del.setAttribute('title', 'Delete Program');

        var span = document.createElement('span');
        span.textContent = '✖';
        del.appendChild(span);

        elem.appendChild(del);

        // trigger re-layout
        del.offsetWidth; // jshint ignore:line
        del.classList.add('animate-in');

        del.addEventListener('click', (function(e) {
            this._document.removeProgram(program);
            e.preventDefault();
            e.stopPropagation();
        }).bind(this));

        this._showDelete = {
            element: elem,
            program: program
        };
    }
};

ProgramsBar.prototype._onProgramBeginEditName = function(elem, program) {
    if (elem.classList.contains('editing')) {
        return;
    }

    elem.classList.add('editing');
    var inp = document.createElement('input');
    inp.setAttribute('type', 'text');
    inp.value = program.name();

    elem.appendChild(inp);
    inp.select(0, program.name().length);

    inp.addEventListener('keydown', (function(e) {
        switch (e.keyCode) {
        case 27:
            // Escape, cancel
            if (inp.value === program.name()) {
                inp.blur();
            } else {
                inp.value = program.name();
                inp.select(0, inp.value.length);
            }
            break;
        case 13:
            // Enter, accept
            inp.blur();
            break;
        default:
            return;
        }

        e.stopPropagation();
        e.preventDefault();
    }).bind(this));

    inp.addEventListener('blur', (function() {
        elem.classList.remove('editing');
        elem.removeChild(inp);

        var name = inp.value.trim();

        if (name.length !== 0 && program.name() !== name) {
            // Make unique
            program.name(this._uniqueProgramName(name));
        }
    }).bind(this));
};

ProgramsBar.prototype._onProgramErrorChanged = function(program) {
    var elem = this._findByName(program.name());

    if (elem) {
        var e = program.error();

        if (e) {
            elem.classList.add('error');

            var errors = [];

            if (e.vertex !== null) {
                errors.push(e.vertex);
            }

            if (e.fragment !== null) {
                errors.push(e.fragment);
            }

            if (e.program !== null) {
                errors.push(e.program);
            }

            elem.setAttribute('title', errors.join('\n'));
        } else {
            elem.classList.remove('error');
            elem.setAttribute('title', '');
        }
    }
};

ProgramsBar.prototype._onProgramAdded = function(doc, program) {
    program.on('notify::name', this._onProgramNameChanged, this);
    program.on('notify::error', this._onProgramErrorChanged, this);

    var li = document.createElement('li');
    li.setAttribute('data-program-name', program.name());

    var span = document.createElement('span');
    span.classList.add('name');
    span.textContent = this._displayName(program);

    li.appendChild(span);

    li.addEventListener('click', (function(e) {
        this._onProgramClick(program);
        e.preventDefault();
        e.stopPropagation();
    }).bind(this));

    li.addEventListener('contextmenu', (function(e) {
        this._onProgramClick(program);

        if (!program.isDefault()) {
            this._onProgramToggleDelete(li, program);
        }

        e.preventDefault();
        e.stopPropagation();
    }).bind(this));

    li.addEventListener('dblclick', (function(e) {
        this._onProgramBeginEditName(li, program);

        e.preventDefault();
        e.stopPropagation();
    }).bind(this));

    if (program === this._document.activeProgram()) {
        li.classList.add('selected');
    }

    this._insertProgramItem(program, li);
    this._onProgramErrorChanged(program);
};

ProgramsBar.prototype._onProgramRemoved = function(doc, program, changingDoc) {
    program.off('notify::name', this._onProgramNameChanged, this);
    program.off('notify::error', this._onProgramErrorChanged, this);

    var item = this._findByName(program.name());

    if (item) {
        if (!changingDoc) {
            item.classList.add('removed');

            if (this._showDelete !== null && this._showDelete.element === item) {
                this._onProgramToggleDelete(item, program);
            }

            setTimeout((function() {
                this._ul.removeChild(item);
            }).bind(this), 300);
        } else {
            if (this._showDelete !== null && this._showDelete.element === item) {
                this._showDelete = null;
            }

            this._ul.removeChild(item);
        }
    }
};

module.exports = ProgramsBar;

// vi:ts=4:et

},{"../app/program":6,"./button":36,"./widget":51}],47:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function Progress(settings) {
	var e = this.create('div', {
		children: this.create('div', {
			classes: 'container',
			children: this.create('div', {
				classes: 'indicator'
			})
		})
	});

	this._indicator = e.querySelector('.indicator');
	this._value = 0;

    Widget.call(this, 'progress', e, utils.merge({}, settings));
}

Progress.prototype = Object.create(Widget.prototype);
Progress.prototype.constructor = Progress;

Progress.prototype._valueUpdated = function() {
	this._indicator.style.width = (this._value * 100) + '%';
};

module.exports = Progress;

// vi:ts=4:et

},{"../utils/utils":52,"./widget":51}],48:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function Slider(settings) {
    var e = this.create('div', {
        children: [
            this.create('div', {
                classes: 'trough',
                children: [
                    this.create('div', {
                        classes: 'bob'
                    })
                ]
            })
        ]
    });

    this._bob = e.querySelector('.bob');
    this._trough = e.querySelector('.trough');

    Widget.call(this, 'slider', e, utils.merge({
        min: 0,
        max: 1
    }, settings));

    this._bob.addEventListener('mousedown', this._onBobMousedown.bind(this));
    this._trough.addEventListener('click', this._onTroughClick.bind(this));

    this._trough.addEventListener('wheel', this._onTroughWheel.bind(this));
}

Slider.prototype = Object.create(Widget.prototype);
Slider.prototype.constructor = Slider;

Slider.prototype._onTroughWheel = function(e) {
    var delta = (e.deltaX + e.deltaY) / this._trough.offsetWidth;

    delta *= (this._settings.max - this._settings.min);

    this.value(this.value() + delta);

    e.preventDefault();
    e.stopPropagation();
};

Slider.prototype._updateFromPageX = function(x) {
    var pos = this.pagePosition(this._trough);
    var f = (x - pos.x) / this._trough.offsetWidth;

    this.value(f * (this._settings.max - this._settings.min) + this._settings.min);
};

Slider.prototype._onTroughClick = function(e) {
    this._updateFromPageX(e.pageX);
};

Slider.prototype._onBobMousedown = function(e) {
    this._onBobMousemove = (function(e) {
        this._updateFromPageX(e.pageX);

        e.preventDefault();
        e.stopPropagation();
    }).bind(this);

    this._onBobMouseup = (function(e) {
        window.removeEventListener('mousemove', this._onBobMousemove);
        window.removeEventListener('mouseup', this._onBobMouseup);

        e.preventDefault();
        e.stopPropagation();
    }).bind(this);

    window.addEventListener('mousemove', this._onBobMousemove);
    window.addEventListener('mouseup', this._onBobMouseup);

    e.preventDefault();
    e.stopPropagation();
};

Slider.prototype._clip = function(v) {
    if (v < this._settings.min) {
        return this._settings.min;
    } else if (v > this._settings.max) {
        return this._settings.max;
    }

    return v;
};

Slider.prototype._valueTransform = function(v) {
    return this._clip(v);
};

Slider.prototype._valueUpdated = function() {
    this._bob.style.left = ((this._value - this._settings.min) / (this._settings.max - this._settings.min) * 100) + '%';

    this._bob.title = this._value;
};

module.exports = Slider;

// vi:ts=4:et

},{"../utils/utils":52,"./widget":51}],49:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Widget = require('./widget');
var utils = require('../utils/utils');

function Spinner(settings) {
    settings = utils.merge({
        nframes: 31
    }, settings);

    Widget.call(this, 'spinner', this.create('div'), settings);

    this._animateId = 0;
    this._animateStart = null;
    this._framePeriod = 1 / (this._settings.nframes + 1);
}

Spinner.prototype = Object.create(Widget.prototype);
Spinner.prototype.constructor = Spinner;

Spinner.prototype.start = function() {
    this._animateId = requestAnimationFrame(this._animate.bind(this));
};

Spinner.prototype.cancel = function() {
    if (this._animateId !== 0) {
        cancelAnimationFrame(this._animateId);

        this._animateId = 0;
        this._animateStart = null;

        // Set back to initial
        this.e.style.backgroundPositionX = '';
        this.e.style.backgroundPositionY = '';
    }
};

Spinner.prototype._animate = function(stamp) {
    if (!this.e.parentNode || (document.compareDocumentPosition(this.e) & document.DOCUMENT_POSITION_CONTAINED_BY) === 0) {
        this.cancel();
        return;
    }

    if (this._animateStart === null) {
        this._animateStart = stamp;
    }

    // In seconds
    var elapsed = (stamp - this._animateStart) / 1000.0;
    var frame = Math.floor(elapsed / this._framePeriod % this._settings.nframes);

    // Skip first frame, which is empty
    frame += 1;

    var fx = Math.floor(frame % 8);
    var fy = Math.floor(frame / 8);

    this.e.style.backgroundPositionX = (-100 * fx) + '%';
    this.e.style.backgroundPositionY = (-100 * fy) + '%';

    this.start();
};

module.exports = Spinner;

/* vi:ts=4:et */

},{"../utils/utils":52,"./widget":51}],50:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

module.exports = {
	Label: require('./label'),
    MultiSwitch: require('./multiswitch'),
	OnOff: require('./onoff'),
	Grid: require('./grid'),
    Panel: require('./panel'),
    ProgramsBar: require('./programs-bar'),
    Button: require('./button'),
    Popup: require('./popup'),
    Slider: require('./slider'),
    ColorPicker: require('./colorpicker'),
    Spinner: require('./spinner'),
    Progress: require('./progress'),
    FilesReader: require('./filesreader'),
    Widget: require('./widget')
};

// vi:ts=4:et

},{"./button":36,"./colorpicker":37,"./filesreader":38,"./grid":39,"./label":40,"./multiswitch":42,"./onoff":43,"./panel":44,"./popup":45,"./programs-bar":46,"./progress":47,"./slider":48,"./spinner":49,"./widget":51}],51:[function(require,module,exports){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Signals = require('../signals/signals');

function Widget(clsname, e, settings) {
    Signals.call(this);

    if (settings.wrap) {
        this.e = settings.wrap;
    } else {
        this.e = e;
    }

    if (settings.title) {
        this.e.title = settings.title;
    }

    this.e.classList.add('ui-widget');

    if (clsname) {
        this.e.classList.add('ui-' + clsname);
    }

    this._sensitive = true;
    this._settings = settings;

    this.children = [];

    var notify = this.registerSignal('notify::value');

    this._onNotifyValue = (function() {
        notify(this._value);
    }).bind(this);

    this._onNotifySensitive = this.registerSignal('notify::sensitive');

    if (this._settings.bind) {
        var binding;

        if (typeof this._settings.bind === 'function') {
            binding = this._settings.bind;
        } else {
            var f = function(obj, prop, sender, value) {
                if (typeof value === 'undefined') {
                    return obj[prop];
                }

                obj[prop] = value;
            };

            if (Array.prototype.isPrototypeOf(this._settings.bind)) {
                binding = f.bind(this, this._settings.bind[0], this._settings.bind[1]);
            } else {
                binding = f.bind(this, this._settings.bind.object, this._settings.bind.property);
            }
        }

        this.on('notify::value', binding);
        this.value(binding());
    }

    if (typeof this._settings.value !== 'undefined') {
        this.value(this._settings.value);
    }

    if (typeof this._settings.sensitive !== 'undefined') {
        this.sensitive(this._settings.sensitive);
    }
}

Widget.prototype = Object.create(Signals.prototype);
Widget.prototype.constructor = Widget;

Widget.prototype.sensitive = function(value) {
    if (typeof value === 'undefined') {
        return this._sensitive;
    }

    value = !!value;

    if (value !== this._sensitive) {
        this._sensitive = value;

        if (value) {
            this.e.classList.remove('insensitive');
        } else {
            this.e.classList.add('insensitive');
        }

        this._onNotifySensitive();
    }
};

Widget.prototype._valueTransform = function(v) {
    return v;
};

Widget.prototype._valueUpdated = function() {
};

Widget.prototype.value = function(value) {
    if (typeof value === 'undefined') {
        return this._value;
    }

    value = this._valueTransform(value);

    if (this._value !== value) {
        this._value = value;

        this._valueUpdated();
        this._onNotifyValue();
    }
};

Widget.createUi = function(name, attributes) {
    var ret = document.createElement(name);

    if (!attributes) {
        attributes = {};
    }

    var i;

    for (var a in attributes) {
        var v = attributes[a];

        if (a === 'classes') {
            if (typeof v === 'string') {
                ret.classList.add(v);
            } else {
                for (i = 0; i < v.length; i++) {
                    ret.classList.add(v[i]);
                }
            }
        } else if (a === 'parent') {
            v.appendChild(ret);
        } else if (a === 'children') {
            if (typeof v === 'object' && Array.prototype.isPrototypeOf(v)) {
                for (i = 0; i < v.length; i++) {
                    ret.appendChild(v[i]);
                }
            } else {
                ret.appendChild(v);
            }
        } else {
            if (a in ret) {
                ret[a] = v;
            } else {
                ret.setAttribute(a, v);
            }
        }
    }

    return ret;
};

Widget.prototype.create = function(name, attributes) {
    return Widget.createUi(name, attributes);
};

Widget.prototype.childElements = function(e) {
    if (typeof e === 'undefined') {
        e = this.e;
    }

    var ret = [];

    for (var i = 0; i < e.childNodes.length; i++) {
        var c = e.childNodes[i];

        if (c.nodeType == document.ELEMENT_NODE) {
            ret.push(c);
        }
    }

    return ret;
};

Widget.prototype.pagePosition = function(e) {
    if (typeof e === 'undefined') {
        e = this.e;
    }

    var ret = {x: 0, y: 0};

    if (typeof e.getBoundingClientRect === 'function') {
        var rect = e.getBoundingClientRect();

        return {
            x: rect.left + document.body.scrollLeft,
            y: rect.top + document.body.scrollTop
        };
    } else {

        do {
            ret.x += e.offsetLeft;
            ret.y += e.offsetTop;

            e = e.offsetParent;
        } while (e !== null);
    }

    return ret;
};

module.exports = Widget;

// vi:ts=4:et

},{"../signals/signals":34}],52:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 Jesse van den Kieboom. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *    * Neither the name of Google Inc. nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var passObjects = [
    Int8Array.prototype,
    Uint8Array.prototype,
    Int16Array.prototype,
    Uint16Array.prototype,
    Int32Array.prototype,
    Uint32Array.prototype,
    Float32Array.prototype,
    Float64Array.prototype,
    Array.prototype
];

var Browser = {
    IsIE: (function() {
        return navigator.userAgent.indexOf('Trident/') !== -1 || navigator.userAgent.indexOf('MSIE') !== -1;
    })()
};

function merge() {
    var ret = {};

    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];

        if (typeof arg === 'undefined') {
            continue;
        }

        for (var k in arg) {
            if (arg.hasOwnProperty(k)) {
                if (typeof ret[k] === 'object' && typeof arg[k] === 'object' && passObjects.indexOf(Object.getPrototypeOf(arg[k])) === -1) {
                    ret[k] = merge(ret[k], arg[k]);
                } else {
                    ret[k] = arg[k];
                }
            }
        }
    }

    return ret;
}

var escapeDiv = document.createElement('div');
var escapeElement = document.createTextNode('');
escapeDiv.appendChild(escapeElement);

function htmlEscape(s) {
    escapeElement.data = s;
    return escapeDiv.innerHTML;
}

function api(url, method, data, options) {
    options = merge({
        success: function() {},
        error: function() {},
        backend: true,
        json: true
    }, options);

    var req = new XMLHttpRequest();

    req.onload = function(e) {
        var req = e.target;

        if (req.status === 200) {
            var ret;

            if (options.json) {
                try {
                    ret = JSON.parse(req.responseText);
                } catch (err) {
                    options.error(req, err);
                    return;
                }
            } else {
                ret = req.responseText;
            }

            options.success(req, ret);
        } else {
            options.error(req, null);
        }
    };

    req.onerror = function(e) {
        options.error(e.target, null);
    };

    if (options.backend) {
        url = global.Settings.backend.url(url);
    }

    req.open(method, url, true);

    if (options.json) {
        req.setRequestHeader('Content-Type', 'application/json');
    }

    if (typeof data !== 'undefined') {
        req.send(JSON.stringify(data));
    } else {
        req.send();
    }
}

function get(url, options) {
    return api(url, 'get', undefined, options);
}

function getQuery(url, query, options) {
    var first = true;

    for (var k in query) {
        if (first) {
            url += '?';
            first = false;
        } else {
            url += '&';
        }

        url += encodeURIComponent(k) + '=' + encodeURIComponent(query[k]);
    }

    return api(url, 'get', undefined, options);
}

function post(url, data, options) {
    return api(url, 'post', data, options);
}

exports.merge = merge;
exports.htmlEscape = htmlEscape;

exports.get = get;
exports.getQuery = getQuery;
exports.post = post;
exports.api = api;
exports.Browser = Browser;

// vi:ts=4:et

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],53:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2014-08-29
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  // IE 10+ (native saveAs)
  || (typeof navigator !== "undefined" &&
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  // Everyone else
  || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" &&
	    /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 for
		// the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 10
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module !== null) {
  module.exports = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}

},{}],54:[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwErrorTolerant: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseUnaryExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment, attacher;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 0x2E:  // . dot
        case 0x28:  // ( open bracket
        case 0x29:  // ) close bracket
        case 0x3B:  // ; semicolon
        case 0x2C:  // , comma
        case 0x7B:  // { open curly brace
        case 0x7D:  // } close curly brace
        case 0x5B:  // [
        case 0x5D:  // ]
        case 0x3A:  // :
        case 0x3F:  // ?
        case 0x7E:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 0x28) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 0x7B) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (U+003D) marks an assignment or comparison operator.
            if (code2 === 0x3D) {
                switch (code) {
                case 0x2B:  // +
                case 0x2D:  // -
                case 0x2F:  // /
                case 0x3C:  // <
                case 0x3E:  // >
                case 0x5E:  // ^
                case 0x7C:  // |
                case 0x25:  // %
                case 0x26:  // &
                case 0x2A:  // *
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };

                case 0x21: // !
                case 0x3D: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 0x3D) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
            }
        }

        // 4-character punctuator: >>>=

        ch4 = source.substr(index, 4);

        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 3-character punctuators: === !== >>> <<= >>=

        ch3 = ch4.substr(0, 3);

        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);

        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 1-character punctuators: < > = ! + - * % & | ^ /
        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    return scanOctalLiteral(start);
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var value;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }
        return value;
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                } else {
                    str += '\\';
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, pattern, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }


        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, range, value;

        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            });
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function Position(line, column) {
        this.line = line;
        this.column = column;
    }

    function SourceLocation(startLine, startColumn, line, column) {
        this.start = new Position(startLine, startColumn);
        this.end = new Position(line, column);
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        processComment: function (node) {
            var lastChild, trailingComments;

            if (node.type === Syntax.Program) {
                if (node.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                if (extra.trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.trailingComments;
                    extra.trailingComments = [];
                } else {
                    extra.trailingComments.length = 0;
                }
            } else {
                if (extra.bottomRightStack.length > 0 &&
                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                }
            }

            // Eating the stack.
            while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
                lastChild = extra.bottomRightStack.pop();
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                }
            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            }


            if (trailingComments) {
                node.trailingComments = trailingComments;
            }

            extra.bottomRightStack.push(node);
        },

        markEnd: function (node, startToken) {
            if (extra.range) {
                node.range = [startToken.start, index];
            }
            if (extra.loc) {
                node.loc = new SourceLocation(
                    startToken.startLineNumber === undefined ?  startToken.lineNumber : startToken.startLineNumber,
                    startToken.start - (startToken.startLineStart === undefined ?  startToken.lineStart : startToken.startLineStart),
                    lineNumber,
                    index - lineStart
                );
                this.postProcess(node);
            }

            if (extra.attachComment) {
                this.processComment(node);
            }
            return node;
        },

        postProcess: function (node) {
            if (extra.source) {
                node.loc.source = extra.source;
            }
            return node;
        },

        createArrayExpression: function (elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },

        createAssignmentExpression: function (operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                        Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createContinueStatement: function (label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },

        createDebuggerStatement: function () {
            return {
                type: Syntax.DebuggerStatement
            };
        },

        createDoWhileStatement: function (body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },

        createEmptyStatement: function () {
            return {
                type: Syntax.EmptyStatement
            };
        },

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },

        createForInStatement: function (left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },

        createFunctionDeclaration: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createFunctionExpression: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name
            };
        },

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },

        createLiteral: function (token) {
            return {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.start, token.end)
            };
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },

        createProgram: function (body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },

        createProperty: function (kind, key, value) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },

        createSwitchCase: function (test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },

        createSwitchStatement: function (discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },

        createUnaryExpression: function (operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument,
                prefix: true
            };
        },

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },

        createWithStatement: function (object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.start;
            error.lineNumber = token.lineNumber;
            error.column = token.start - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line;

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], startToken;

        startToken = lookahead;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body, startToken;

        previousStrict = strict;
        startToken = lookahead;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
    }

    function parseObjectPropertyKey() {
        var token, startToken;

        startToken = lookahead;
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return delegate.markEnd(delegate.createLiteral(token), startToken);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }

    function parseObjectProperty() {
        var token, key, id, value, param, startToken;

        token = lookahead;
        startToken = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
            }
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;

        startToken = lookahead;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, startToken;

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        type = lookahead.type;
        startToken = lookahead;

        if (type === Token.Identifier) {
            expr =  delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            } else {
                throwUnexpected(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = delegate.createLiteral(collectRegex());
            } else {
                expr = delegate.createLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpected(lex());
        }

        return delegate.markEnd(expr, startToken);
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, startToken;

        startToken = lookahead;
        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, startToken;

        startToken = lookahead;
        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var previousAllowIn, expr, args, property, startToken;

        startToken = lookahead;

        previousAllowIn = state.allowIn;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        state.allowIn = previousAllowIn;

        for (;;) {
            if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                break;
            }
            delegate.markEnd(expr, startToken);
        }

        return expr;
    }

    function parseLeftHandSideExpression() {
        var previousAllowIn, expr, property, startToken;

        startToken = lookahead;

        previousAllowIn = state.allowIn;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        state.allowIn = previousAllowIn;

        while (match('.') || match('[')) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
            delegate.markEnd(expr, startToken);
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                markers.pop();
                marker = markers[markers.length - 1];
                delegate.markEnd(expr, marker);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
            marker = markers.pop();
            delegate.markEnd(expr, marker);
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
            delegate.markEnd(expr, startToken);
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, left, right, node, startToken;

        token = lookahead;
        startToken = lookahead;

        node = left = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(left)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
        }

        return node;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead;

        expr = parseAssignmentExpression();

        if (match(',')) {
            expr = delegate.createSequenceExpression([ expr ]);

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

            delegate.markEnd(expr, startToken);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, startToken;

        startToken = lookahead;
        expect('{');

        block = parseStatementList();

        expect('}');

        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, startToken;

        startToken = lookahead;
        token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }

    function parseVariableDeclaration(kind) {
        var init = null, id, startToken;

        startToken = lookahead;
        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, startToken;

        startToken = lookahead;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return delegate.createIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return delegate.createDoWhileStatement(body, test);
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return delegate.createWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations, startToken;

        startToken = lookahead;
        token = lex();
        declarations = parseVariableDeclarationList();

        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                delegate.createForStatement(init, test, update, body) :
                delegate.createForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return delegate.createContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return delegate.createBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return delegate.createReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return delegate.createReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return delegate.createReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return delegate.createWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, startToken;

        startToken = lookahead;
        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return delegate.createSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return delegate.createSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return delegate.createThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, startToken;

        startToken = lookahead;
        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return delegate.createTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return delegate.createDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            startToken;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }

        startToken = lookahead;

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return delegate.markEnd(parseEmptyStatement(), startToken);
            case '(':
                return delegate.markEnd(parseExpressionStatement(), startToken);
            default:
                break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return delegate.markEnd(parseBreakStatement(), startToken);
            case 'continue':
                return delegate.markEnd(parseContinueStatement(), startToken);
            case 'debugger':
                return delegate.markEnd(parseDebuggerStatement(), startToken);
            case 'do':
                return delegate.markEnd(parseDoWhileStatement(), startToken);
            case 'for':
                return delegate.markEnd(parseForStatement(), startToken);
            case 'function':
                return delegate.markEnd(parseFunctionDeclaration(), startToken);
            case 'if':
                return delegate.markEnd(parseIfStatement(), startToken);
            case 'return':
                return delegate.markEnd(parseReturnStatement(), startToken);
            case 'switch':
                return delegate.markEnd(parseSwitchStatement(), startToken);
            case 'throw':
                return delegate.markEnd(parseThrowStatement(), startToken);
            case 'try':
                return delegate.markEnd(parseTryStatement(), startToken);
            case 'var':
                return delegate.markEnd(parseVariableStatement(), startToken);
            case 'while':
                return delegate.markEnd(parseWhileStatement(), startToken);
            case 'with':
                return delegate.markEnd(parseWithStatement(), startToken);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
        }

        consumeSemicolon();

        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;

        startToken = lookahead;
        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
    }

    function parseParams(firstRestricted) {
        var param, params = [], token, stricted, paramSet, key, message;
        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead;
                param = parseVariableIdentifier();
                key = '$' + token.value;
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[key] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return {
            params: params,
            stricted: stricted,
            firstRestricted: firstRestricted,
            message: message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;

        startToken = lookahead;

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;

        startToken = lookahead;
        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, startToken;

        skipComment();
        peek();
        startToken = lookahead;
        strict = false;

        body = parseSourceElements();
        return delegate.markEnd(delegate.createProgram(body), startToken);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            token,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            token = lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '1.2.2';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],55:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.2
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],56:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

Lexer.__doc__ = {"description":"Block Lexer","kind":"function","refid":"<anonymous>~Lexer"};


/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
}

Lexer.prototype.lex.__doc__ = {"description":"Preprocessing","kind":"function","refid":"<anonymous>~Lexer#lex"};
;

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
}

Lexer.prototype.token.__doc__ = {"description":"Lexing","kind":"function","refid":"<anonymous>~Lexer#token"};
;

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

InlineLexer.__doc__ = {"description":"Inline Lexer & Compiler","kind":"function","refid":"<anonymous>~InlineLexer"};


/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
}

InlineLexer.prototype.output.__doc__ = {"description":"Lexing/Compiling","kind":"function","refid":"<anonymous>~InlineLexer#output"};
;

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
}

InlineLexer.prototype.outputLink.__doc__ = {"description":"Compile Link","kind":"function","refid":"<anonymous>~InlineLexer#outputLink"};
;

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
}

InlineLexer.prototype.smartypants.__doc__ = {"description":"Smartypants Transformations","kind":"function","refid":"<anonymous>~InlineLexer#smartypants"};
;

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
}

InlineLexer.prototype.mangle.__doc__ = {"description":"Mangle Links","kind":"function","refid":"<anonymous>~InlineLexer#mangle"};
;

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.__doc__ = {"description":"Renderer","kind":"function","refid":"<anonymous>~Renderer"};


Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

Parser.__doc__ = {"description":"Parsing & Compiling","kind":"function","refid":"<anonymous>~Parser"};


/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
}

Parser.prototype.parse.__doc__ = {"description":"Parse Loop","kind":"function","refid":"<anonymous>~Parser#parse"};
;

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
}

Parser.prototype.next.__doc__ = {"description":"Next Token","kind":"function","refid":"<anonymous>~Parser#next"};
;

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
}

Parser.prototype.peek.__doc__ = {"description":"Preview Next Token","kind":"function","refid":"<anonymous>~Parser#peek"};
;

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
}

Parser.prototype.parseText.__doc__ = {"description":"Parse Text Tokens","kind":"function","refid":"<anonymous>~Parser#parseText"};
;

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
}

Parser.prototype.tok.__doc__ = {"description":"Parse Current Token","kind":"function","refid":"<anonymous>~Parser#tok"};
;

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

escape.__doc__ = {"description":"Helpers","kind":"function","refid":"<anonymous>~escape"};


function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

marked.__doc__ = {"description":"Marked","kind":"function","refid":"<anonymous>~marked"};


/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[35])


//# sourceMappingURL=site.min.js.map
